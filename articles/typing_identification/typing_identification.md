## Создание "Слепка" Клавиатурного Почерка: Идентификация пользователя с помощью машинного обучения и Scikit-learn (Практический пример)

В этой статье я покажу, как создать простую систему идентификации пользователя на основе анализа его уникального стиля набора текста (клавиатурного почерка). Мы будем использовать библиотеку машинного обучения Scikit-learn в Python. В отличие от предыдущих теоретических рассуждений, мы сосредоточимся на **конкретном примере кода**, который показывает основные этапы процесса.

**1. Имитация сбора данных: Создаем "виртуальные" нажатия клавиш**

В реальном мире первым шагом является сбор данных о нажатиях клавиш от пользователей. Мы уже обсуждали это, но, к сожалению, в данной ситуации у меня нет возможности подключиться напрямую к клавиатуре.  Вместо этого я **имитирую** этот процесс, создавая случайные данные, представляющие длительность нажатий клавиш.

Для этой цели я разработал функцию `generate_simulated_data()`:

```python
import numpy as np
import random

def generate_simulated_data(num_users=2, num_sessions=5, session_length=50):
    """Генерирует имитацию данных о длительности нажатий клавиш."""
    data = []
    labels = []
    for user_id in range(num_users):
        for session_id in range(num_sessions):
            mean_duration = random.randint(80, 150)
            std_dev = random.randint(10, 20)
            session_data = np.random.normal(mean_duration, std_dev, session_length)
            data.append(session_data)
            labels.append(f"user{user_id + 1}")
    return data, labels

data, labels = generate_simulated_data()
```

Эта функция генерирует данные для заданного количества пользователей (`num_users`), каждый из которых имеет несколько "сессий" набора текста (`num_sessions`). Каждая сессия состоит из набора случайных значений, представляющих длительность нажатия клавиш в миллисекундах. Я использую нормальное распределение (`np.random.normal()`), чтобы имитировать естественную изменчивость в скорости набора текста. Каждому пользователю назначается уникальный "средний" стиль набора текста (случайное значение `mean_duration`). Это, конечно, крайне упрощенная модель, но она позволяет продемонстрировать основную идею.

**Важно:** В реальном приложении вам потребуется заменить эту функцию на код, который загружает данные, собранные от реальных пользователей.

**2. Извлечение признаков: Упрощаем картину**

Как мы уже говорили, существует множество возможных признаков, которые можно извлечь из данных о нажатиях клавиш. Для простоты, в этом примере я буду использовать только один признак: **среднюю длительность нажатия клавиш в сессии**.

```python
X = np.array([np.mean(session) for session in data]).reshape(-1, 1)
y = np.array(labels)
```

Этот код вычисляет среднее значение для каждой сессии и преобразует данные в формат, понятный Scikit-learn. `reshape(-1, 1)` используется для преобразования одномерного массива в двумерный, что требуется большинством алгоритмов машинного обучения в Scikit-learn.

**3. Подготовка данных: Готовимся к обучению**

Перед тем, как обучать модель, необходимо подготовить данные. Это включает:

*   **Разделение данных:** Разделение данных на обучающую и тестовую выборки. Обучающая выборка используется для обучения модели, а тестовая – для оценки ее точности.
*   **Нормализация данных:** Масштабирование данных, чтобы все признаки имели одинаковый диапазон значений. Это помогает улучшить производительность модели.

```python
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)
```

Я использую `train_test_split` для разделения данных на 70% обучающей и 30% тестовой выборки. `StandardScaler` используется для нормализации данных. `fit_transform` применяется к обучающей выборке для вычисления параметров масштабирования, а `transform` применяется к тестовой выборке, используя эти параметры.

**4. Обучение модели: Создаем "слепок" клавиатурного почерка**

Теперь я могу обучить модель машинного обучения. Я буду использовать `RandomForestClassifier`, как и раньше.

```python
from sklearn.ensemble import RandomForestClassifier

model = RandomForestClassifier(n_estimators=100, random_state=42)
model.fit(X_train, y_train)
```

Я создаю экземпляр `RandomForestClassifier` с 100 деревьями (`n_estimators=100`) и обучаю его на обучающей выборке.

**5. Оценка модели: Измеряем точность "слепка"**

После обучения модели необходимо оценить ее точность на тестовой выборке.

```python
from sklearn.metrics import accuracy_score

predictions = model.predict(X_test)
accuracy = accuracy_score(y_test, predictions)
print(f"Точность модели: {accuracy}")
```

Я использую `accuracy_score` для вычисления точности модели, то есть, доли правильно классифицированных примеров.

**6. Использование модели: Идентификация нового пользователя**

Наконец, я могу использовать обученную модель для идентификации нового пользователя.

```python
def predict_user(session_data):
    """Предсказывает пользователя на основе данных сессии."""
    mean_duration = np.mean(session_data)
    scaled_data = scaler.transform([[mean_duration]])
    prediction = model.predict(scaled_data)[0]
    return prediction

new_session_data = np.random.normal(120, 15, 50)
predicted_user = predict_user(new_session_data)
print(f"Предсказанный пользователь: {predicted_user}")
```

Функция `predict_user` принимает данные новой сессии набора текста, вычисляет среднюю длительность нажатий, масштабирует данные и использует обученную модель для предсказания пользователя. `scaler.transform([[mean_duration]])` масштабирует данные, используя параметры масштабирования, вычисленные на обучающей выборке.

**Заключение:**

Этот пример демонстрирует основные шаги создания простой системы идентификации по "клавиатурному почерку". Хотя я использовал упрощенные данные и признаки, этот пример показывает, как можно использовать машинное обучение для анализа стиля набора текста и идентификации пользователей. В реальном приложении необходимо использовать более сложные методы сбора данных, извлечения признаков и обучения моделей для достижения высокой точности идентификации. Кроме того, важно помнить об этических аспектах сбора и использования данных о нажатиях клавиш.
