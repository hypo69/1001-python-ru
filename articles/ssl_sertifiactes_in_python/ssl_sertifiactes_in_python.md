Отличная статья! Очень понятно и по делу. Чтобы сделать её ещё более полной, можно добавить информацию про OpenSSL как инструмент диагностики и управления, а также упомянуть системные хранилища сертификатов.

Вот предлагаемые дополнения:

---

**Дополнение 1: Диагностика с помощью OpenSSL**

Иногда проблема может быть не в Python или его настройках, а в самом сервере или в сетевом окружении (например, корпоративных прокси, которые подменяют сертификаты). Чтобы проверить SSL-соединение независимо от Python, можно использовать утилиту командной строки **OpenSSL**.

Установите OpenSSL (если его еще нет; часто он уже есть в Linux/macOS, для Windows можно скачать с [официального сайта](https://www.openssl.org/source/) или через менеджеры пакетов вроде Chocolatey/Scoop).

Затем выполните команду в терминале:

```bash
# Замените <hostname> и <port> (обычно 443 для HTTPS)
openssl s_client -connect <hostname>:<port> -showcerts

# Пример для сайта Росстата:
openssl s_client -connect rosstat.gov.ru:443 -showcerts
```

Эта команда попытается установить SSL/TLS-соединение с сервером и покажет цепочку сертификатов, которую он предоставил. Обратите внимание на вывод:

*   **Certificate chain:** Показывает иерархию сертификатов от серверного до корневого.
*   **Verify return code:** В конце вывода будет строка типа `Verify return code: 0 (ok)` если проверка прошла успешно с точки зрения *локального хранилища OpenSSL*. Если будет другая ошибка (например, `unable to get local issuer certificate`), это подтвердит, что проблема в отсутствии доверенного корневого сертификата в том хранилище, которое использует OpenSSL.

Это помогает понять, корректно ли настроен сервер и видит ли ваша система (или её часть, отвечающая за OpenSSL) нужные корневые сертификаты. Иногда Python и OpenSSL могут использовать разные наборы корневых сертификатов, что тоже может быть причиной расхождений.

---

**Дополнение 2: Системные хранилища сертификатов и переменные окружения**

Python (через модуль `ssl`, который используют `urllib3` и `requests`) по умолчанию пытается найти доверенные корневые сертификаты. Место поиска зависит от операционной системы и настроек:

1.  **Использование `certifi`:** Как показано в статье, это самый надежный и кросс-платформенный способ, так как `certifi` поставляет свой собственный, регулярно обновляемый набор корневых сертификатов (Mozilla Trust Store). `requests` часто использует `certifi` по умолчанию, если он установлен.
2.  **Стандартные пути OpenSSL:** Модуль `ssl` может искать сертификаты в путях, которые ожидает найти библиотека OpenSSL (например, `/etc/ssl/certs` в Linux). Это поведение можно запросить явно:
    ```python
    import ssl
    import requests

    context = ssl.create_default_context() # Использует системные настройки
    # Не рекомендуется для requests напрямую, но показывает принцип
    # response = requests.get(url, cert=context.get_ca_certs()) # Не совсем так работает с requests
    # Правильнее - настроить ssl_context для urllib3 или использовать системные настройки, если requests их подхватит
    ```
    *Примечание*: Интеграция `requests` с системным хранилищем через `ssl.create_default_context()` не так проста, обычно проще указать путь к файлу или использовать `certifi`.

3.  **Хранилище Windows:** На Windows Python может пытаться использовать системное хранилище сертификатов Windows. Иногда это работает "из коробки", но не всегда надежно, особенно в старых версиях Python или при определенных установках. Скрипт `Install Certificates.command` / `.bat`, упомянутый в статье, как раз помогает связать Python с актуальным набором сертификатов (`certifi`).
4.  **Переменные окружения:** Можно явно указать Python (и другим инструментам, использующим OpenSSL), где искать сертификаты, с помощью переменных окружения:
    *   `SSL_CERT_FILE`: Путь к *файлу* с набором доверенных корневых сертификатов (в формате PEM).
    *   `SSL_CERT_DIR`: Путь к *директории*, содержащей отдельные файлы сертификатов (в формате PEM, с определенными именами хешей).
    ```bash
    # Пример для Linux/macOS
    export SSL_CERT_FILE=/path/to/my/ca-bundle.pem
    python your_script.py

    # Пример для Windows (cmd)
    set SSL_CERT_FILE=C:\path\to\my\ca-bundle.pem
    python your_script.py
    ```
    Это может быть полезно в корпоративных средах, где нужно доверять внутреннему Удостоверяющему Центру (CA), добавив его сертификат в пользовательский бандл.

---

**Дополнение 3: Создание сертификата с помощью OpenSSL (альтернатива PowerShell/makecert)**

OpenSSL — это стандартный инструмент для работы с сертификатами на всех платформах. Вот как создать самоподписанный сертификат с его помощью (одной командой):

```bash
openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -sha256 -days 365 -nodes -subj "/CN=localhost"
```

*   `req -x509`: Создать самоподписанный сертификат.
*   `-newkey rsa:2048`: Сгенерировать новый приватный ключ RSA длиной 2048 бит.
*   `-keyout key.pem`: Сохранить приватный ключ в файл `key.pem`.
*   `-out cert.pem`: Сохранить сертификат в файл `cert.pem`.
*   `-sha256`: Использовать SHA-256 для подписи.
*   `-days 365`: Срок действия сертификата — 1 год.
*   `-nodes`: Не шифровать приватный ключ (убрать `-nodes`, если нужен пароль).
*   `-subj "/CN=localhost"`: Установить Common Name (основное имя) сертификата как `localhost`. Можно добавить другие поля (`/C=RU/ST=Moscow/L=Moscow/O=MyOrg/OU=MyUnit/CN=localhost`).

Эта команда создаст два файла: `key.pem` (приватный ключ) и `cert.pem` (сертификат), которые можно использовать для настройки локального HTTPS-сервера (например, во Flask, Django, aiohttp).

