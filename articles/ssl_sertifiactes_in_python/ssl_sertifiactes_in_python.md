# Как я победил SSLCertVerificationError в Python (и вы тоже сможете)

Я хотел скачать Excel-файл с сайта Росстата, а в ответ получил страшную портянку с ошибкой `SSLCertVerificationError`. Если вы тоже её встретили — не паникуйте. В этой статье я покажу, что это за зверь, как его укротить и почему он вообще появляется. А ещё мы немного поговорим про SSL-сертификаты, инструменты диагностики вроде **OpenSSL**, системные хранилища и даже создадим свой сертификат с нуля. Поехали!

## Что такое SSLCertVerificationError?

Когда вы стучитесь к сайту по HTTPS, Python (точнее, библиотека `requests`, а под капотом — `urllib3`) пытается проверить подлинность SSL-сертификата. Это похоже на то, как вы проверяете, что говорите с настоящим человеком, а не с мошенником.

Если не удаётся найти подходящий корневой сертификат для доверия — Python поднимает ошибку:

```
SSLCertVerificationError: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: unable to get local issuer certificate (_ssl.c:1000)
```

## Как это выглядит в реальности?

Я пытался выполнить вот такой код:

```python
# ошибка SSL
import requests

url = "https://rosstat.gov.ru/storage/mediabank/tab5_v01.xlsx"
response = requests.get(url)
```

И получил `MaxRetryError`, внутри которого — `SSLCertVerificationError`. Полная трассировка ошибок оказалась внушительной, но суть всегда одна: Python не может проверить SSL-сертификат сайта.

## Почему это происходит?

На Windows такая ошибка чаще всего связана с отсутствием корневых сертификатов в том месте, где Python их ищет. В отличие от Linux и macOS, Windows не всегда ставит их для Python автоматически. Особенно если вы используете кастомную установку Python без полного набора `certifi` или если системные настройки не подхватываются корректно.

Иногда проблема может быть не в Python, а в самом сервере или в сетевом окружении (например, из-за корпоративных прокси, подменяющих сертификаты).

## Диагностика с помощью OpenSSL

Прежде чем исправлять что-то в Python, бывает полезно проверить само SSL-соединение с помощью внешнего инструмента, такого как **OpenSSL**. Это поможет понять, корректно ли настроен сервер и видит ли ваша система нужные корневые сертификаты.

Установите OpenSSL, если его нет (часто он уже есть в Linux/macOS; для Windows скачайте с [официального сайта](https://www.openssl.org/source/) или через менеджеры пакетов вроде Chocolatey/Scoop).

Затем выполните команду в терминале:

```bash
# Замените <hostname> и <port> (обычно 443 для HTTPS)
openssl s_client -connect <hostname>:<port> -showcerts

# Пример для сайта Росстата:
openssl s_client -connect rosstat.gov.ru:443 -showcerts
```

Эта команда покажет цепочку сертификатов сервера и результат проверки (`Verify return code`). Если вы видите ошибку вроде `unable to get local issuer certificate`, это подтверждает, что проблема в доверии к корневому сертификату на уровне системы или того хранилища, которое использует OpenSSL.

## Быстрое решение: отключаем проверку SSL (но осторожно)

```python
# Быстрое решение: отключаем проверку SSL (но осторожно)
import requests

url = "https://rosstat.gov.ru/storage/mediabank/tab5_v01.xlsx"
# Предупреждение: Отключение проверки безопасности!
response = requests.get(url, verify=False)

# Подавляем предупреждения InsecureRequestWarning (опционально)
import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

with open("tab5_v01.xlsx", "wb") as f:
    f.write(response.content)
```

⚠️ **Важно:** Я использую `verify=False` только для одноразовых скриптов и **только для сайтов, которым я абсолютно доверяю**. Это полностью отключает проверку SSL/TLS, делая ваше соединение уязвимым для атак "человек посередине" (MITM). **Никогда не используйте `verify=False` в продакшн-коде или при работе с чувствительными данными!**

## Постоянное решение 1: Устанавливаем/обновляем сертификаты для Python

Если вы установили Python с официального сайта (особенно на macOS или при некоторых установках Windows), может потребоваться связать Python с набором корневых сертификатов.

*   **На macOS:** Зайдите в папку `Applications/Python <версия>/` и запустите скрипт `Install Certificates.command`.
*   **На Windows:** Если при установке вы выбирали опцию, связанную с `pip` и `certifi`, подобный скрипт (`install_certificates.bat`) мог быть создан. Часто он находится в `C:\Users\<имя_пользователя>\AppData\Local\Programs\Python\Python<версия>\Scripts\` или аналогичной директории. Если его нет, этот метод может не сработать, и лучше использовать `certifi` напрямую.

Этот скрипт обычно устанавливает или обновляет пакет `certifi` и создает символическую ссылку, чтобы стандартный модуль `ssl` Python использовал сертификаты из `certifi`.

## Постоянное решение 2: Использовать certifi напрямую

Это самый надежный и кросс-платформенный способ явно указать, какие корневые сертификаты использовать. Сначала установите `certifi`:

```bash
pip install certifi
```

Затем используйте его в коде:

```python
# Использовать certifi напрямую
import requests
import certifi

url = "https://rosstat.gov.ru/storage/mediabank/tab5_v01.xlsx"
# Явно указываем путь к файлу с сертификатами из пакета certifi
response = requests.get(url, verify=certifi.where())

with open("tab5_v01.xlsx", "wb") as f:
    f.write(response.content)
```

Библиотека `requests` часто использует `certifi` по умолчанию, если он установлен, но явное указание `verify=certifi.where()` гарантирует использование именно этого набора сертификатов.

## Где Python ищет сертификаты? Системные хранилища и переменные окружения

Помимо `certifi`, модуль `ssl` Python (который лежит в основе HTTPS-запросов) может искать доверенные корневые сертификаты в других местах:

1.  **Стандартные пути OpenSSL:** На Linux и macOS модуль `ssl` может искать сертификаты в системных директориях, которые использует OpenSSL (например, `/etc/ssl/certs/ca-certificates.crt`, `/etc/pki/tls/certs/ca-bundle.crt` и т.д.). Поведение определяется при компиляции Python и OpenSSL.
2.  **Хранилище Windows:** На Windows Python может пытаться использовать системное хранилище сертификатов Windows ("cert store"). Это не всегда работает стабильно "из коробки" и может зависеть от версии Python и способа установки.
3.  **Переменные окружения:** Вы можете явно указать путь к доверенным сертификатам с помощью переменных окружения, которые учитываются OpenSSL и, следовательно, модулем `ssl` Python:
    *   `SSL_CERT_FILE`: Путь к *одному файлу* в формате PEM, содержащему все доверенные корневые сертификаты.
    *   `SSL_CERT_DIR`: Путь к *директории*, где каждый доверенный сертификат хранится в отдельном файле PEM с именем в виде хеша (см. документацию OpenSSL `c_rehash`).

    ```bash
    # Пример для Linux/macOS
    export SSL_CERT_FILE=/etc/ssl/certs/my_custom_ca_bundle.pem
    python your_script.py

    # Пример для Windows (cmd)
    set SSL_CERT_FILE=C:\certs\my_custom_ca_bundle.pem
    python your_script.py
    ```
    Это особенно полезно в корпоративных средах, где нужно добавить доверие к внутреннему Удостоверяющему Центру (CA).

## Немного теории: что вообще такое SSL-сертификат?

Представьте, что Алиса хочет безопасно поговорить с сайтом Бориса через интернет. Они оба не уверены, что общаются именно с тем, с кем нужно, и что их разговор не подслушивают.

1.  **Борис идет в Удостоверяющий Центр (CA):** Это доверенная организация (например, Let's Encrypt, DigiCert, GlobalSign). Борис доказывает CA, что он владеет доменом `boris-site.com`.
2.  **CA выпускает "паспорт" для сайта Бориса:** Это SSL/TLS-сертификат. Он содержит имя сайта (`boris-site.com`), открытый ключ Бориса, срок действия и цифровую подпись самого CA.
3.  **Алиса подключается к сайту Бориса:** Браузер (или Python) Алисы получает этот сертификат.
4.  **Проверка "паспорта":** Клиент Алисы выполняет несколько проверок:
    *   **Подлинность подписи:** Может ли клиент проверить цифровую подпись CA на сертификате Бориса, используя корневой сертификат этого CA, который уже есть у Алисы в списке доверенных?
    *   **Срок действия:** Не истек ли сертификат?
    *   **Имя сайта:** Соответствует ли имя в сертификате (`boris-site.com`) тому сайту, к которому Алиса подключается?
    *   **Статус отзыва:** Не был ли сертификат отозван CA (проверяется через OCSP или CRL, если настроено)?
5.  **Результат:** Если все проверки пройдены, устанавливается безопасное зашифрованное соединение. Если хотя бы одна проверка не удалась (например, не найден доверенный корневой сертификат CA, как в нашей ошибке) — соединение прерывается с ошибкой `SSLCertVerificationError`.

## Бонус: создаём свой самоподписанный сертификат

Если вы разрабатываете локальный веб-сервер или API и хотите использовать HTTPS (например, для тестирования), вам понадобится сертификат. Поскольку у вас нет публичного домена и вы не будете проходить проверку у публичного CA, вы можете создать *самоподписанный* сертификат — то есть, вы сами выступаете в роли CA.

**Способ 1: PowerShell (Windows)**

```powershell
# Создает сертификат для localhost и помещает его в личное хранилище компьютера
New-SelfSignedCertificate -DnsName "localhost", "127.0.0.1" -CertStoreLocation "cert:\LocalMachine\My" -NotAfter (Get-Date).AddYears(5)
```

**Способ 2: `makecert` (Windows, старый инструмент, может отсутствовать)**

```cmd
# Требует установки Windows SDK
makecert -r -pe -n "CN=localhost" -b 01/01/2024 -e 01/01/2030 -ss My -sr LocalMachine -a sha256 -len 2048
```

**Способ 3: OpenSSL (кросс-платформенный)**

Это универсальный способ, работающий на Windows, Linux и macOS.

```bash
# Создаст два файла: key.pem (приватный ключ) и cert.pem (сертификат)
openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -sha256 -days 3650 -nodes -subj "/CN=localhost" -addext "subjectAltName = DNS:localhost,IP:127.0.0.1"
```

*   `-x509`: Создать самоподписанный сертификат.
*   `-newkey rsa:2048`: Генерировать новый RSA ключ 2048 бит.
*   `-keyout key.pem`: Сохранить приватный ключ.
*   `-out cert.pem`: Сохранить сертификат.
*   `-sha256`: Использовать SHA-256 для подписи.
*   `-days 3650`: Срок действия 10 лет.
*   `-nodes`: Не шифровать приватный ключ паролем.
*   `-subj "/CN=localhost"`: Установить Common Name.
*   `-addext "subjectAltName = ..."`: Добавить альтернативные имена (важно для современных браузеров).

Полученные файлы `key.pem` и `cert.pem` можно использовать для настройки HTTPS в вашем локальном веб-сервере (Flask, Django, Node.js и т.д.). Имейте в виду, что браузеры и клиенты будут ругаться на такой сертификат ("не доверенный"), так как он подписан не известным CA, а вами. Для тестов придется вручную добавить его в исключения или в доверенные корневые сертификаты вашей системы.

## Заключение

Ошибки SSL, особенно `SSLCertVerificationError`, поначалу могут напугать, но теперь вы знаете:

-   Почему возникает эта ошибка (проблемы с проверкой цепочки доверия сертификатов).
-   Как быстро обойти её для доверенных источников (`verify=False`), но с большой осторожностью.
-   Как устранить её правильно: обновить сертификаты через скрипт установки или явно использовать `certifi`.
-   Как проверить SSL-соединение с помощью `openssl s_client`.
-   Где Python может искать сертификаты (системные хранилища, переменные окружения).
-   Как работает проверка SSL/TLS сертификатов на пальцах.
-   Как создать собственный самоподписанный сертификат для локальной разработки с помощью PowerShell, `makecert` или OpenSSL.

Надеюсь, эта статья помогла вам разобраться с проблемой. Если остались вопросы или есть чем дополнить — пишите в комментариях!

Удачной разработки, лёгкого кодинга и никаких `SSLError`! 💻✨🐍

