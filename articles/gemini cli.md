## Gemini CLI: Руководство с практическими примерами

**Gemini CLI** — это инструмент, который работает прямо в вашем терминале, понимает вашу кодовую базу и помогает исправлять ошибки с помощью запросов на естественном языке. Это ответ Google на Claude Code от Anthropic.
Вы можете использовать Gemini 2.5 Pro (при достижении лимита инструмент переключится на Gemini 2.5 Flash) и его контекстное окно в 1 миллион токенов для выполнения до 60 запросов в минуту и 1000 запросов в день, и все это бесплатно.


В этом руководстве я пошагово объясню, как настроить Gemini CLI на вашем локальном компьютере и использовать его для следующих задач:
*   Понимание и навигация по большим кодовым базам
*   Обнаружение и исправление ошибок
*   Написание и тестирование кода
*   Генерация документации и визуальных диаграмм

### Ключевые возможности Gemini CLI:
*   **Редактирование и рефакторинг:** Автоматически улучшает и упрощает ваш код под руководством ИИ.
*   **Обнаружение и исправление ошибок:** Находит баги и предлагает исправления.
*   **Понимание кода:** Gemini CLI может обобщать архитектуру, объяснять роли модулей или строить карты потоков выполнения.
*   **Генерация тестов:** Автоматически создает тестовые задания для `pytest`
*   **Поддержка документации:** Вы можете создавать структурированные markdown-документы, списки изменений (changelogs) и ответы на GitHub issues прямо в терминале.
*   **Исполнение команд:** Gemini CLI может выполнять команды оболочки, такие как `git`, `npm`, `pip` и другие, что позволяет вам управлять проектами без выхода из CLI.

---

### Шаг 1: Предварительные требования
Для начала установите Node.js (версия 18 или выше). Вы можете скачать установщик по вашему выбору или выполнить следующие bash-команды в вашем терминале:

```bash
# Скачивание и установка nvm (Node Version Manager):
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.3/install.sh | bash

# Инициализация nvm в текущей сессии терминала
. "$HOME/.nvm/nvm.sh"

# Скачивание и установка Node.js (например, версии 22):
nvm install 22

# Проверка версии Node.js:
node -v # Должно вывести "v22.17.0" или похожее

# Проверка версии npm:
npm -v # Должно вывести "10.9.2" или похожее
```
Эта настройка гарантирует, что ваша система готова к бесперебойной работе Gemini CLI.

### Шаг 2: Настройка Gemini CLI

#### Шаг 2.1: Установка Gemini CLI
Когда Node.js и npm установлены и проверены, установите Gemini CLI, выполнив следующую команду в вашем терминале:
```bash
npx https://github.com/google-gemini/gemini-cli
```
Или используйте `npm` для глобальной установки:
```bash
npm install -g @google/gemini-cli
gemini
```
После установки введите `gemini` в терминале, чтобы получить доступ к инструменту.



#### Шаг 2.2: Аутентификация
Вы можете использовать ваш личный аккаунт Google для аутентификации. Это предоставит вам до 60 запросов в минуту и 1000 запросов в день при использовании Gemini.
![First Run](../assets/gemini_cli/auth.png)
В этом руководстве я использовал **Вход через Google**, но вы также можете использовать **API-ключ** (установленный как переменная окружения или в файле `.env`) или аутентификацию через **Vertex AI**.

Чтобы сгенерировать новый API-ключ, войдите в **AI Studio** с вашим аккаунтом Google и нажмите "Создать API-ключ".
```bash
# Установка ключа как переменной окружения
export GEMINI_API_KEY="Your_API_Key"

# Или создайте файл .env
GEMINI_API_KEY="Your_API_Key"
```
Вы можете использовать команду `/auth` в текстовом поле для переключения метода аутентификации по мере необходимости.

---

### Шаг 3: Настройка проекта в Gemini CLI
![Start](../assets/gemini_cli/start.png)
Когда CLI запущен, мы можем начать взаимодействовать с Gemini из терминала. Есть два способа работы с проектом.

#### 1. Начать новый проект
Чтобы начать проект с нуля, выполните следующие команды:
```bash
cd new-project/
gemini
```
Внутри CLI используйте промпт для решения интересующей вас проблемы, например:
> Напиши код кодировщика для трансформера с нуля.

#### 2. Работать с существующим проектом
Если у вас уже есть кодовая база, вы можете работать с ней, выполнив следующие команды:
```bash
git clone https://github.com/AashiDutt/Google-Agent-Development-Kit-Demo
cd Google-Agent-Development-Kit-Demo
gemini
```
Внутри CLI используйте промпт, например:
> Предоставь мне сводку всех изменений, внесенных в кодовую базу сегодня.

---

### Шаг 4: Эксперименты с Gemini CLI
В этом руководстве мы будем работать с существующим проектом, который я использовал для написания руководства по **Google's Agent Development Kit (ADK)**. Репозиторий хранится на GitHub. С помощью Gemini CLI мы:
1.  Исследуем и поймем кодовую базу
2.  Обнаружим ошибку или проблему на GitHub или в файле
3.  Проведем рефакторинг кода и сгенерируем юнит-тесты
4.  Создадим markdown-отчет о внесенных изменениях
5.  Визуализируем кодовую базу, сгенерировав блок-схему

#### Исследование и понимание кодовой базы
Начнем с того, что попросим Gemini исследовать и объяснить кодовую базу.

**Промпт:** `Исследуй текущий каталог и опиши архитектуру проекта.`

Gemini CLI вернет структурированное резюме, объясняющее архитектуру:
*   **Пользовательский интерфейс:** Приложение на Streamlit (`travel_ui.py`) предоставляет интерфейс для взаимодействия.
*   **Оркестрация:** `host_agent` действует как центральный координатор.
*   **Специализированные агенты:** `flight_agent`, `stay_agent`, `activities_agent` для поиска авиабилетов, отелей и развлечений.
*   **Коммуникация:** Агенты общаются друг с другом через RESTful API на FastAPI.
*   **Общие компоненты:** `shared/schemas.py` определяет общие структуры данных.

Это помогло мне сориентироваться, не читая каждый файл вручную.

#### Анализ и исправление проблемы на GitHub
Давайте исследуем некоторые открытые проблемы из репозитория GitHub.

**Промпт:** `Вот проблема на GitHub: [@search https://github.com/AashiDutt/Google-Agent-Development-Kit-Demo/issues/1]. Проанализируй кодовую базу и предложи 3-шаговый план исправления. Какие файлы/функции следует изменить?`

Gemini CLI исследовал проблему:
*   Используя функцию `@search`, он получил данные с GitHub.
*   Определил основную причину как ошибку сериализации JSON (в данном случае, асинхронная функция `create_session()` не была вызвана с `await`).
*   Предложил изменения и обработку ответа в нескольких файлах.

Далее CLI ожидает ввода от пользователя для оценки изменений. Если пользователь согласен, он внесет предложенные изменения.

#### Внедрение и тестирование исправления
Теперь внедрим и протестируем предложенные Gemini исправления.

**Промпт:** `Напиши юнит-тест для этого изменения в pytest в файле test_shared.py.`

Gemini CLI:
*   Вставил `json.dumps()` перед отправкой полезной нагрузки задачи.
*   Создал `test_agents.py` для добавления юнит-тестов.
*   Добавил новый тестовый случай для проверки схемы и передачи вложенных сообщений агентов.

#### Генерация документации
Теперь, когда исправления внесены, давайте подведем итоги изменений и запишем их в Markdown в файле `.txt`.

**Промпт:** `Напиши markdown-сводку об ошибке, исправлении и тестовом покрытии. Отформатируй это как запись в журнале изменений под версией "v0.2.0".`

Затем, чтобы сохранить сводку в документ, я использовал следующий промпт:

**Промпт:** `Сохрани эту сводку в файл .txt и назови его summary.txt`

Gemini CLI использует инструмент `WriteFile` для сохранения файла `summary.txt` в каталоге проекта.

#### Генерация блок-схемы с использованием MCP
Этот раздел расширяет предыдущие эксперименты, где я исследую, как Gemini CLI использует **Model Context Protocol (MCP)** для поддержания сводок на уровне файлов и истории задач между промптами. Это дает Gemini "рабочую память" в рамках сессии.

**Промпт:** `Сгенерируй блок-схему, которая показывает, как агенты общаются через A2A (agent-to-agent) и как main.py управляет системой. Выдели, где произошла проблема и как она была исправлена.`

Эта визуализация стала возможной благодаря постоянной памяти Gemini, которая сохранила полный контекст нашего предыдущего исправления ошибки и структуры агента без необходимости повторной загрузки файлов.

### Доступные инструменты Gemini CLI
Некоторые инструменты, которые поддерживает Gemini CLI:
*   `ReadFile`, `WriteFile`, `Edit`
*   `FindFiles`, `ReadFolder`, `ReadManyFiles`
*   `Shell`, `SaveMemory`
*   `GoogleSearch` или `Search`, `WebFetch`

Эти инструменты помогают эффективно перемещаться, запрашивать и изменять большие кодовые базы.

### Заключение
В итоге, это руководство продемонстрировало, как Gemini CLI можно использовать для:
*   Понимания структуры многоагентной кодовой базы
*   Исправления проблемы на GitHub
*   Генерации юнит-тестов и markdown-документации для изменений
*   Визуализации потока данных

Gemini CLI сократил время, которое я обычно трачу на анализ файлов и ручное планирование исправлений. Хотя Gemini CLI все еще находится на ранней стадии и иногда может работать медленно при использовании через API, он уже соответствует возможностям Claude Code.