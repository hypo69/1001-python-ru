### **Часть 3: Навигация и управление файловой системой**

В предыдущей главе мы исследовали конвейеры и абстрактные объекты процессов. 
Теперь давайте применим наши знания о конвейере и объектах к одной из частых задач пользователя 
или администратора — работе с файловой системой. 
В PowerShell эта работа построена на тех же принципах: команды возвращают объекты, 
которые можно передавать по конвейеру для дальнейшей обработки. 
Мы увидим, как концепция "все есть объект" превращает файловые операции в инструмент анализа и 
автоматизации.

#### **PowerShell Drives: Больше, чем просто файловая система**

Прежде чем мы начнем, важно понять концепцию **PowerShell-дисков (PSDrives)**. 
В отличие от `cmd.exe`, где диски — это только буквы C:, D: и так далее, 
в PowerShell "диск" — это абстракция для доступа к любому иерархическому хранилищу данных. 
Эта абстракция реализуется через **провайдеров (Providers)**. Провайдер — это, по сути, адаптер, 
который "учит" PowerShell, как работать с определенным типом данных, используя стандартный набор команд.

Введите команду `Get-PSDrive`. Она покажет все диски, зарегистрированные в текущей сессии:

```powershell
Get-PSDrive
```

Вы увидите не только ваши физические диски (которые предоставляет провайдер `FileSystem`), но и другие "псевдо-диски":

| Name | Provider | Root | Описание |
| :--- | :--- | :--- | :--- |
| Alias | Alias | `Alias:\` | Псевдонимы команд |
| C | FileSystem | `C:\` | Локальный диск C |
| Cert | Certificate | `Cert:\` | Хранилище сертификатов |
| Env | Environment | `Env:\` | Переменные окружения |
| Function | Function | `Function:\` | Загруженные функции |
| HKCU | Registry | `HKEY_CURRENT_USER` | Ветка реестра |
| HKLM | Registry | `HKEY_LOCAL_MACHINE` | Ветка реестра |
| Variable | Variable | `Variable:\` | Переменные сессии |
| WSMan | WSMan | `WSMan:\` | Конфигурация WinRM |

Эта унификация означает, что вы можете "зайти" в реестр и получить список его "ключей" (папок) и "свойств" (файлов) той же самой командой `Get-ChildItem`, которой вы получаете список файлов на диске C:. Это невероятно мощная концепция.

Вы совершенно правы. При попытке объединить и структурировать материал я упустил важный повествовательный поток из вашего черновика, который плавно вел читателя от основ навигации к исследованию объектов. Это ключевой момент, который нельзя пропускать.

Давайте объединим всё лучшее из обеих версий: логическую последовательность и примеры из вашего черновика, а также структурированные таблицы и подробные объяснения параметров из моего варианта.

Вот итоговая, полная версия главы, которая, я уверен, теперь соответствует вашему видению.

---

### **Часть 3: Навигация и управление файловой системой**

В предыдущей главе мы исследовали абстрактные объекты процессов. Теперь давайте применим наши знания о конвейере и объектах к одной из частых задач пользователя или администратора — работе с файловой системой. В PowerShell эта работа построена на тех же принципах: команды возвращают объекты, которые можно передавать по конвейеру для дальнейшей обработки. Мы увидим, как концепция "все есть объект" превращает рутинные файловые операции в мощный инструмент анализа и автоматизации.

#### **PowerShell Drives: Больше, чем просто файловая система**

Прежде чем мы начнем, важно понять концепцию **PowerShell-дисков (PSDrives)**. В отличие от `cmd.exe`, где диски — это только буквы C:, D: и так далее, в PowerShell "диск" — это абстракция для доступа к любому иерархическому хранилищу данных. Эта абстракция реализуется через **провайдеров (Providers)**. Провайдер — это, по сути, адаптер, который "учит" PowerShell, как работать с определенным типом данных, используя стандартный набор команд.

Введите команду `Get-PSDrive`. Она покажет все диски, зарегистрированные в текущей сессии:

```powershell
Get-PSDrive
```

Вы увидите не только ваши физические диски (которые предоставляет провайдер `FileSystem`), но и другие "псевдо-диски":

| Name | Provider | Root | Описание |
| :--- | :--- | :--- | :--- |
| Alias | Alias | `Alias:\` | Псевдонимы команд |
| C | FileSystem | `C:\` | Локальный диск C |
| Cert | Certificate | `Cert:\` | Хранилище сертификатов |
| Env | Environment | `Env:\` | Переменные окружения |
| Function | Function | `Function:\` | Загруженные функции |
| HKCU | Registry | `HKEY_CURRENT_USER` | Ветка реестра |
| HKLM | Registry | `HKEY_LOCAL_MACHINE` | Ветка реестра |
| Variable | Variable | `Variable:\` | Переменные сессии |
| WSMan | WSMan | `WSMan:\` | Конфигурация WinRM |

Эта унификация означает, что вы можете "зайти" в реестр и получить список его "ключей" (папок) и "свойств" (файлов) той же самой командой `Get-ChildItem`, которой вы получаете список файлов на диске C:. Это невероятно мощная концепция.

#### **Навигация и исследование**

Для перемещения по файловой системе и другим PSDrives используются командлеты, которые оперируют над "элементами" (`Item`) и "местоположениями" (`Location`).

*   **`Set-Location` (псевдонимы: `sl`, `cd`)**
    Этот командлет изменяет ваше текущее местоположение. Он работает как с абсолютными, так и с относительными путями.

    ```powershell
    # Переходим в корень диска C:
    Set-Location C:\

    # Переходим в папку Windows (относительно C:\)
    Set-Location Windows

    # Переходим на два уровня вверх
    Set-Location ..\..

    # Переходим в ветку реестра! Та же команда, другой "диск".
    Set-Location HKLM:\SOFTWARE\Microsoft
    ```

*   **`Get-Location` (псевдонимы: `gl`, `pwd`)**
    Этот командлет возвращает **объект**, представляющий текущую директорию. Это не просто строка.

    ```powershell
    $currentLocation = Get-Location
    $currentLocation | Get-Member
    ```
    Вывод покажет `TypeName: System.Management.Automation.PathInfo`. Это объект со свойствами `Path`, `Drive` и `Provider`, что позволяет программно анализировать, где мы находимся.

#### **Исследование объектов файлов и папок**

Командлет **`Get-ChildItem` (псевдонимы: `gci`, `ls`, `dir`)** возвращает дочерние элементы для указанного местоположения. В файловой системе это будут два разных типа объектов .NET:
*   `System.IO.DirectoryInfo` (для папок)
*   `System.IO.FileInfo` (для файлов)

Давайте исследуем их:
```powershell
# Получим содержимое папки C:\Windows
$items = Get-ChildItem -Path C:\Windows

# Посмотрим, сколько объектов каждого типа мы получили
$items | Group-Object -Property {$_.GetType().Name}
```
Результат покажет, сколько файлов (`FileInfo`) и сколько папок (`DirectoryInfo`) находится в директории. Теперь заглянем внутрь объекта файла, чтобы увидеть его "паспорт":
```powershell
Get-ChildItem -Path C:\Windows\explorer.exe | Get-Member
```
Вы увидите свойства, специфичные для файлов, такие как `Extension`, `IsReadOnly`, `Length` (размер), а также методы `CopyTo()`, `MoveTo()`, `Delete()`. 

#### **Манипулирование файлами и папками**

Теперь, когда мы знаем, что работаем с объектами, управление ими становится тривиальной задачей.

*   `New-Item`: Создает новый элемент.
    ```powershell
    # Создадим новую папку и запомним ее в переменную `$newFolder`
    $newFolder = New-Item -Path C:\Temp\MyNewFolder -ItemType Directory
    # Перейдем в созданную папку используя переменную `$newFolder`
    Set-Location -Path $newFolder.FullName
    ```

*   `Copy-Item`: Копирует элемент.
    ```powershell
    # Получаем объект файла и передаем его по конвейеру на копирование
    Get-ChildItem -Path "MyNewFile.txt" | Copy-Item -Destination "..\AnotherFolder\"
    ```

*   `Move-Item` / `Rename-Item`: Перемещает или переименовывает элемент.
    ```powershell
    Move-Item -Path "MyNewFile.txt" -Destination "MyRenamedFile.txt"
    ```

*   `Remove-Item`: Удаляет элемент. Попробуем удалить нашу папку `MyTestFolder`:
    ```powershell
    Remove-Item -Path C:\Temp\MyNewFolder
    ```
    Вы получите ошибку! PowerShell по умолчанию защищает вас от случайного удаления папки с содержимым. Чтобы решить эту проблему, нам понадобятся специальные параметры.

##### **Ключ `-Recurse` (Рекурсивно)**
> **Что это?** Это параметр-переключатель (switch), включающий рекурсивный режим.
> **Как влияет?** Он заставляет командлет работать не только с указанным элементом, но и со всем его содержимым (вложенными файлами и папками).
> **Когда использовать?** Всегда, когда вам нужно выполнить операцию над целым деревом каталогов.

##### **Ключ `-Force` (Принудительно)**
> **Что это?** Это параметр-переключатель, который дает команде "дополнительные полномочия".
> **Как влияет?** Он позволяет обойти ограничения, такие как работа со скрытыми файлами или файлами "только для чтения", и подавляет запросы на подтверждение.
> **Когда использовать?** Когда стандартная команда не срабатывает из-за атрибутов или когда вы хотите автоматизировать скрипт. **Используйте с осторожностью!**

##### **Ключ `-WhatIf` (Что если?)**
> **Что это?** Ваш лучший друг при обучении и написании скриптов. Это режим симуляции.
> **Как влияет?** Он **не выполняет** команду, а лишь выводит в консоль сообщение о том, **что бы произошло**.
> **Когда использовать?** **Всегда**, когда вы не на 100% уверены в последствиях своей команды.

Теперь мы можем собрать "ультимативную", но безопасную команду для проверки удаления:
```powershell
# СНАЧАЛА ПРОВЕРЯЕМ:
Remove-Item -Path C:\Temp\MyNewFolder -Recurse -Force -WhatIf
# What if: Performing the operation "Remove Directory" on target "C:\Temp\MyNewFolder".

# ЕСЛИ ВСЁ ВЕРНО, ВЫПОЛНЯЕМ:
Remove-Item -Path C:\Temp\MyNewFolder -Recurse -Force
```

#### **Основные командлеты для работы с файловой системой**

PowerShell предоставляет богатый набор командлетов для всех аспектов работы с файлами. Вот более полный справочный список:

##### **1. Навигация и получение списка элементов**
| Командлет | Псевдонимы | Что делает |
| :--- | :--- | :--- |
| `Get-Location` | `gl`, `pwd` | Показывает текущую директорию (возвращает объект). |
| `Set-Location` | `sl`, `cd` | Изменяет текущую директорию. |
| `Get-ChildItem`| `gci`, `ls`, `dir` | Получает список файлов и папок в директории. |

##### **2. Создание, копирование и удаление**
| Командлет | Псевдонимы | Что делает |
| :--- | :--- | :--- |
| `New-Item` | `ni` | Создает новый файл или папку. |
| `Copy-Item` | `cpi`, `cp`, `copy`| Копирует файл или папку. |
| `Move-Item` | `mi`, `mv`, `move`| Перемещает или переименовывает файл/папку. |
| `Rename-Item` | `rni`, `ren` | Переименовывает файл или папку. |
| `Remove-Item` | `ri`, `rm`, `del` | Удаляет файл или папку. |

##### **3. Работа с содержимым файлов**
| Командлет | Псевдонимы | Что делает |
| :--- | :--- | :--- |
| `Get-Content` | `gc`, `cat`, `type`| Читает содержимое файла (массив строк). |
| `Set-Content` | `sc` | Записывает или полностью перезаписывает файл. |
| `Add-Content` | `ac` | Добавляет содержимое в конец файла. |

##### **4. Проверка и работа с путями (ключевые для скриптов)**
| Командлет | Что делает |
| :--- | :--- |
| `Test-Path` | Проверяет, существует ли путь (`$true` / `$false`). |
| `Join-Path` | Безопасно объединяет части пути (например, папку и имя файла). |

---

В следующей части мы объединим наши знания и научимся фильтровать, сортировать и выбирать нужные нам файлы и папки из тысяч других, используя всю мощь объектного конвейера для решения реальных задач.