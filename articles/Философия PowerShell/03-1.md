### **Часть 3: Навигация и управление файловой системой. Операторы логики. Введение в функции**

В предыдущей главе мы исследовали конвейеры и абстрактные объекты процессов. Теперь давайте применим наши знания о конвейере и объектах к одной из частых задач пользователя или администратора — работе с файловой системой. В PowerShell эта работа построена на тех же принципах: команды возвращают объекты, которые можно передавать по конвейеру для дальнейшей обработки. Мы увидим, как концепция "все есть объект" превращает файловые операции в инструмент анализа и автоматизации.

#### **Концепция PowerShell Drives (PSDrives)**

Прежде чем начать работать с файлами, важно понять концепцию **PowerShell-дисков (PSDrives)**. В отличие от `cmd.exe`, где диски — это только буквы `C:`, `D:` и так далее, в PowerShell "диск" — это абстракция для доступа к любому иерархическому хранилищу данных. Эта абстракция реализуется через **провайдеров (Providers)** — адаптеры, которые "учат" PowerShell работать с определённым типом данных, используя стандартный набор команд.

```powershell
Get-PSDrive
```
Результат покажет не только физические диски, но и псевдо-диски:

| Name | Provider | Root | Описание |
|------|----------|------|----------|
| Alias | Alias | Alias:\ | Псевдонимы команд |
| C | FileSystem | C:\ | Локальный диск C |
| Cert | Certificate | Cert:\ | Хранилище сертификатов |
| Env | Environment | Env:\ | Переменные окружения |
| Function | Function | Function:\ | Загруженные функции |
| HKCU | Registry | HKEY_CURRENT_USER | Ветка реестра |
| HKLM | Registry | HKEY_LOCAL_MACHINE | Ветка реестра |
| Variable | Variable | Variable:\ | Переменные сессии |
| WSMan | WSMan | WSMan:\ | Конфигурация WinRM |

> Эта унификация означает, что вы можете "зайти" в реестр (`Set-Location HKLM:`) и получить список его ключей той же командой `Get-ChildItem`, которой получаете список файлов на диске C:. Это невероятно мощная концепция.

---

### **1: Навигация и анализ**

Начнем с основ: как перемещаться по файловой системе и как исследовать ее содержимое.

#### **Простая навигация**
Это базовые команды, аналогичные тем, что есть в других оболочках, но в PowerShell они работают с объектами.

```powershell
# Узнать, где мы находимся (возвращает объект PathInfo)
Get-Location
# Псевдонимы: gl, pwd

# Переход в корень диска C:
Set-Location C:\
# Псевдонимы: sl, cd

# Показать содержимое текущей папки (возвращает коллекцию объектов FileInfo и DirectoryInfo)
Get-ChildItem
# Псевдонимы: gci, ls, dir
```

#### **Продвинутая навигация**
PowerShell отлично работает с путями и переменными окружения.

```powershell
# Абсолютный путь — полный путь от корня диска
Set-Location C:\Windows\System32

# Относительный путь — от текущей позиции
Set-Location ..\.. # Переход на два уровня вверх

# Переход в домашнюю папку текущего пользователя
Set-Location ~
```

#### **Фильтрация содержимого**
`Get-ChildItem` — это не просто аналог `dir`. Это мощный инструмент для поиска.

```powershell
# Найти все .exe файлы. Параметр -Filter работает очень быстро, так как фильтрация происходит на уровне файловой системы.
Get-ChildItem C:\Windows -Filter "*.exe"
```
**Анализ:** `Get-ChildItem` возвращает коллекцию объектов. Мы можем передать ее по конвейеру для дальнейшей фильтрации. Свойство `PSIsContainer` — это логическое значение (`$true` для папок, `$false` для файлов).

```powershell
# Показать только файлы
Get-ChildItem C:\Windows | Where-Object { $_.PSIsContainer -eq $false }

# Показать только папки
Get-ChildItem C:\Windows | Where-Object { $_.PSIsContainer -eq $true }
```

#### **Рекурсивный поиск и работа с атрибутами**
Что если нужный файл находится где-то глубоко во вложенных папках?

```powershell
# Найти файл hosts в системе, игнорируя ошибки "Доступ запрещен"
Get-ChildItem C:\ -Filter "hosts" -Recurse -ErrorAction SilentlyContinue
```
Здесь мы встречаем два важнейших параметра:
> **Ключ `-Recurse` (Рекурсивно)**
>
> **Что это?** Параметр-переключатель, который заставляет командлет работать не только с указанным элементом, но и со всем его содержимым (вложенными файлами и папками).

> **Ключ `-ErrorAction SilentlyContinue`**
>
> **Что это?** Инструкция, как поступать при возникновении ошибки. Значение `SilentlyContinue` говорит PowerShell: "Если столкнешься с ошибкой (например, 'Доступ запрещен'), проигнорируй ее и продолжай работу молча".

PowerShell также позволяет легко находить файлы по их атрибутам.
```powershell
# Показать скрытые файлы и папки с помощью специального параметра
Get-ChildItem C:\Windows -Hidden

# Показать файлы только для чтения, фильтруя по свойству объекта
Get-ChildItem C:\Windows -File | Where-Object { $_.IsReadOnly -eq $true }
```

#### **Анализ свойств файлов**

Предыдущие уровни научили нас находить и получать списки файлов. Но истинная сила PowerShell проявляется дальше — в возможности обрабатывать эти списки. Теперь мы можем **фильтровать, сортировать и выбирать нужные нам файлы и папки из тысяч других, используя всю мощь объектного конвейера.**

Вот где философия объектов раскрывается в полной мере. Каждый файл — это объект с десятками полезных свойств.

```powershell
# Получить информацию о конкретном файле
$file = Get-ChildItem C:\Windows\explorer.exe

# Посмотреть все его свойства и методы
$file | Get-Member
```
**Анализ:** Теперь мы можем использовать эти свойства для сортировки и группировки.

```powershell
# Сгруппировать все файлы в папке Windows по расширению и посчитать их количество
Get-ChildItem C:\Windows -File | Group-Object Extension | Sort-Object Count -Descending

# Найти 10 самых больших файлов
Get-ChildItem C:\Windows -File | Sort-Object Length -Descending | Select-Object -First 10
```
---

### **2: Создание и управление**

Теперь перейдем от анализа к действиям: созданию, изменению и перемещению файлов.

#### **Создание элементов**
```powershell
# Создать одну папку
New-Item -Path "C:\Temp\MyFolder" -ItemType Directory

# Создать пустой файл
New-Item -Path "C:\Temp\empty.txt" -ItemType File

# Создать файл и сразу записать в него содержимое
Set-Content -Path "C:\Temp\greeting.txt" -Value "Привет, PowerShell!"
```

#### **Работа с содержимым файлов**
```powershell
# Прочитать файл как массив строк
Get-Content C:\Temp\greeting.txt

# Добавить строку в конец файла
Add-Content C:\Temp\greeting.txt -Value "Новая строка!"

# Мониторинг файла в реальном времени (например, лога). Нажмите Ctrl+C для остановки.
Get-Content C:\Windows\WindowsUpdate.log -Wait -Tail 5
```

#### **Копирование и перемещение**
```powershell
# Скопировать файл
Copy-Item C:\Temp\greeting.txt C:\Temp\greeting_copy.txt

# Скопировать папку со всем содержимым. Снова используем -Recurse!
Copy-Item C:\Temp\MyFolder C:\Backup\MyFolder -Recurse

# Переименовать файл (перемещение в то же место с новым именем)
Move-Item C:\Temp\old_name.txt C:\Temp\new_name.txt
```
---

### **3: Безопасное удаление**

Это самая опасная часть, поэтому здесь особенно важны встроенные механизмы защиты PowerShell.

#### **Основы удаления**
```powershell
# Удалить один файл
Remove-Item C:\Temp\unwanted.txt

# Попытка удалить непустую папку вызовет ошибку. Нужно явно разрешить рекурсивное удаление.
Remove-Item C:\Temp\FullFolder -Recurse
```
Если в папке есть скрытые или системные файлы, даже `-Recurse` может потребовать подтверждения.
```powershell
# Принудительное удаление папки со всем ее содержимым
Remove-Item C:\Temp\Stubborn -Recurse -Force
```
> **Ключ `-Force` (Принудительно)**
>
> **Что это?** Параметр-переключатель, который дает команде "дополнительные полномочия" для обхода ограничений (атрибуты "только для чтения", скрытые файлы) и подавления большинства запросов на подтверждение.

Перед выполнением такой опасной команды всегда используйте главный спасательный круг PowerShell.

> **Ключ `-WhatIf` (Что если?)**
>
> **Что это?** Ваш лучший друг при обучении и написании скриптов. Он **не выполняет** команду, а лишь выводит в консоль сообщение о том, **что бы произошло**.
>
> **Когда использовать?** **Всегда** перед выполнением `Remove-Item`, `Move-Item` и других потенциально разрушительных операций.

```powershell
# Безопасная проверка перед удалением
Remove-Item C:\Temp\Important -Recurse -Force -WhatIf
# Результат: What if: Performing the operation "Remove Directory" on target "C:\Temp\Important".
```

#### **Продвинутое удаление по условию**
Сила конвейера позволяет строить очень точные команды для очистки.

```powershell
# Удалить все файлы в папке Temp старше 30 дней
Get-ChildItem C:\Temp -File | Where-Object { $_.LastWriteTime -lt (Get-Date).AddDays(-30) } | Remove-Item -WhatIf

# Удалить все пустые папки
Get-ChildItem C:\Temp -Directory | Where-Object { (Get-ChildItem $_.FullName).Count -eq 0 } | Remove-Item -WhatIf
```



### **4: Практические примеры**

Давайте применим все полученные знания для решения реальных задач. Эти примеры демонстрируют, как, комбинируя простые командлеты, можно создавать мощные инструменты автоматизации.

#### **Пример 1: Анализ дискового пространства**
Эта команда — классический пример мощи конвейера PowerShell. Мы находим все файлы, сортируем их по размеру, форматируем вывод для наглядности и выбираем 20 самых больших. Все это — одна строка кода, без необходимости писать циклы или сложные скрипты.

```powershell
# Используется вычисляемое свойство для форматирования вывода
Get-ChildItem C:\Users -File -Recurse -ErrorAction SilentlyContinue | 
    Sort-Object Length -Descending | 
    Select-Object FullName, @{Name="Size(MB)"; Expression={[math]::Round($_.Length/1MB,2)}} | 
    Select-Object -First 20
```
---


---

#### **Пример 2: Поиск дубликатов файлов**
Эта функция ищет файлы с одинаковым именем и размером — частые кандидаты на дубликаты. `Group-Object` является ключом к решению: он позволяет сгруппировать файлы по нескольким критериям сразу.

```powershell
function Find-DuplicateFiles {
    param(
        [Parameter(Mandatory=$true)]
        [string]$Path
    )
    
    Get-ChildItem $Path -File -Recurse -ErrorAction SilentlyContinue | 
        Group-Object Name, Length | # Группируем сразу по двум свойствам
        Where-Object { $_.Count -gt 1 } | # Находим группы, где больше одного элемента
        ForEach-Object {
            Write-Host "Найдены дубликаты: $($_.Name)" -ForegroundColor Yellow
            $_.Group | Select-Object FullName, Length, LastWriteTime
            Write-Host ""
        }
}
# Использование:
# Find-DuplicateFiles -Path "C:\Users\$env:USERNAME\Documents"
```

#### **Пример 3: Создание ZIP-архива с резервной копией**
Простое копирование папки — это тривиально. Гораздо полезнее создать единый, сжатый ZIP-архив с отметкой времени. Эта задача демонстрирует проверку путей, работу с датами и использование командлета `Compress-Archive`.

```powershell
function Backup-FolderToZip {
    param(
        [Parameter(Mandatory=$true)]
        [string]$SourcePath,

        [Parameter(Mandatory=$true)]
        [string]$DestinationPath
    )

    # 1. Проверяем, существует ли исходная папка
    if (-not (Test-Path $SourcePath)) {
        Write-Error "Ошибка: Исходная папка '$SourcePath' не найдена."
        return
    }

    # 2. Формируем имя файла архива с датой и временем
    $timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
    $archiveFileName = "Backup_{0}_{1}.zip" -f (Split-Path $SourcePath -Leaf), $timestamp
    $fullArchivePath = Join-Path $DestinationPath $archiveFileName

    # 3. Создаем директорию назначения, если ее нет
    if (-not (Test-Path $DestinationPath)) {
        New-Item -Path $DestinationPath -ItemType Directory -Force | Out-Null
    }

    # 4. Создаем архив
    Write-Host "Создание архива '$fullArchivePath'..." -ForegroundColor Green
    Compress-Archive -Path "$SourcePath\*" -DestinationPath $fullArchivePath -Force

    Write-Host "Резервное копирование успешно завершено!" -ForegroundColor Cyan
}

# Использование:
# Backup-FolderToZip -SourcePath "C:\MyImportantData" -DestinationPath "D:\Backups"
```

#### **Пример 4: Автоматическая организация файлов по типу**
У многих есть папка "Загрузки", где царит хаос. Этот скрипт автоматически раскладывает файлы по подпапкам в зависимости от их расширения. Здесь используется логика оператора `switch` для классификации файлов.

```powershell
function Organize-FilesByType {
    param(
        [Parameter(Mandatory=$true)]
        [string]$SourceDirectory
    )

    Get-ChildItem -Path $SourceDirectory -File | ForEach-Object {
        $file = $_
        $destinationSubFolder = switch -Wildcard ($file.Extension.ToLower()) {
            '.jpg','.jpeg','.png','.gif'  { "Images" }
            '.doc','.docx','.pdf','.txt' { "Documents" }
            '.zip','.rar','.7z'          { "Archives" }
            '.mp3','.wav','.flac'        { "Music" }
            '.mp4','.mkv','.avi'         { "Videos" }
            default                      { "Other" }
        }

        # Создаем целевую папку, если она не существует
        $targetDirectory = Join-Path $SourceDirectory $destinationSubFolder
        if (-not (Test-Path $targetDirectory)) {
            New-Item -Path $targetDirectory -ItemType Directory | Out-Null
        }

        # Перемещаем файл
        Write-Host "Перемещение '$($file.Name)' в '$destinationSubFolder'"
        Move-Item -Path $file.FullName -Destination $targetDirectory
    }
}

# Использование:
# Organize-FilesByType -SourceDirectory "C:\Users\$env:USERNAME\Downloads"
```

#### **Пример 5: Генерация отчета о размере директорий**
Команда `Get-ChildItem` для папки не показывает ее общий размер. Этот скрипт решает данную проблему: он обходит все подпапки в указанном месте, вычисляет их суммарный размер и экспортирует результат в CSV-файл для дальнейшего анализа. Это отличный пример создания **пользовательских объектов** и экспорта структурированных данных.

```powershell
function Get-DirectorySizeReport {
    param(
        [Parameter(Mandatory=$true)]
        [string]$BasePath,

        [Parameter(Mandatory=$true)]
        [string]$ReportCsvPath
    )

    Write-Host "Сбор данных о размерах директорий... Это может занять время."
    $reportData = Get-ChildItem -Path $BasePath -Directory | ForEach-Object {
        $currentDir = $_
        # Для каждой папки рекурсивно получаем все файлы и суммируем их размер
        $sizeBytes = (Get-ChildItem -Path $currentDir.FullName -Recurse -File -ErrorAction SilentlyContinue | 
                      Measure-Object -Property Length -Sum).Sum
        
        # Создаем кастомный объект с нужными нам полями
        [PSCustomObject]@{
            DirectoryName = $currentDir.Name
            Path          = $currentDir.FullName
            SizeMB        = [math]::Round($sizeBytes / 1MB, 2)
            LastModified  = $currentDir.LastWriteTime
        }
    }

    # Сортируем результат по размеру и экспортируем в CSV
    $reportData | Sort-Object SizeMB -Descending | Export-Csv -Path $ReportCsvPath -NoTypeInformation -Encoding UTF8

    Write-Host "Отчет сохранен в '$ReportCsvPath'" -ForegroundColor Green
}

# Использование:
# Get-DirectorySizeReport -BasePath "C:\Program Files" -ReportCsvPath "C:\Temp\DirectoryReport.csv"
```
---
### **Справочник командлетов для работы с файловой системой**

#### **Основные командлеты**
Этот список включает в себя самые необходимые командлеты, которые покрывают 90% повседневных задач.

| Командлет | Основное назначение | Псевдонимы |
| :--- | :--- | :--- |
| `Get-ChildItem` | Получить список файлов и папок в директории. | `gci`, `ls`, `dir` |
| `Set-Location` | Переместиться в другую директорию. | `sl`, `cd` |
| `Get-Location` | Показать текущую директорию. | `gl`, `pwd` |
| `New-Item` | Создать новый файл или папку. | `ni` |
| `Remove-Item` | Удалить файл или папку. | `ri`, `rm`, `del` |
| `Copy-Item` | Скопировать файл или папку. | `cpi`, `cp`, `copy` |
| `Move-Item` | Переместить файл или папку. | `mi`, `mv`, `move` |
| `Rename-Item` | Переименовать файл или папку. | `rni`, `ren` |
| `Get-Content` | Прочитать содержимое файла. | `gc`, `cat`, `type`|
| `Set-Content` | Записать/перезаписать содержимое файла. | `sc` |
| `Add-Content` | Добавить содержимое в конец файла. | `ac` |
| `Test-Path` | Проверить, существует ли файл или папка (`true`/`false`). | `test` |

#### **Расширенный список командлетов (сгруппированный по функциям)**

##### **1. Навигация и получение элементов**
| Командлет | Основное назначение |
| :--- | :--- |
| `Get-ChildItem` | Получает список дочерних элементов (файлов, папок, ключей реестра). |
| `Get-Location` | Возвращает объект, представляющий текущее местоположение. |
| `Set-Location` | Устанавливает текущее рабочее местоположение. |

##### **2. Создание, удаление и модификация элементов**
| Командлет | Основное назначение |
| :--- | :--- |
| `New-Item` | Создает новый элемент (файл, папку, ключ реестра). |
| `Remove-Item` | Удаляет один или несколько элементов. |
| `Copy-Item` | Копирует элемент из одного места в другое. |
| `Move-Item` | Перемещает элемент из одного места в другое. |
| `Rename-Item` | Переименовывает элемент. |

##### **3. Работа с содержимым файлов**
| Командлет | Основное назначение |
| :--- | :--- |
| `Get-Content` | Получает содержимое файла в виде массива строк. |
| `Set-Content` | Записывает или заменяет содержимое файла. |
| `Add-Content` | Добавляет содержимое в конец файла. |
| `Clear-Content`| Удаляет все содержимое из файла, оставляя сам файл пустым. |

##### **4. Работа с путями**
| Командлет | Основное назначение |
| :--- | :--- |
| `Test-Path` | Проверяет, существуют ли все элементы в пути. |
| `Join-Path` | Объединяет путь и дочерний путь в единый, корректно сформированный путь. |
| `Split-Path` | Возвращает указанную часть пути (папку, имя файла или расширение). |
| `Resolve-Path`| Преобразует относительный путь в полный, абсолютный путь. |

##### **5. Работа со свойствами и правами (ACL)**
| Командлет | Основное назначение |
| :--- | :--- |
| `Get-ItemProperty`| Получает свойства указанного элемента (например, `LastWriteTime`, `Attributes`). |
| `Set-ItemProperty`| Изменяет свойства указанного элемента. |
| `Get-Acl` | Получает дескриптор безопасности (список прав доступа) для файла или папки. |
| `Set-Acl` | Применяет указанный дескриптор безопасности к файлу или папке. |

---
### **Заключение и лучшие практики**

Работа с файловой системой в PowerShell — это мощный инструмент, который превращает простые операции в элегантные решения для автоматизации.

1.  **Используйте `-WhatIf`**: Всегда проверяйте опасные операции перед их выполнением.
2.  **Обрабатывайте ошибки**: Используйте `-ErrorAction SilentlyContinue` в скриптах, чтобы избежать их остановки из-за ошибок доступа.
3.  **Оптимизируйте производительность**: Используйте `-Filter` вместо `Where-Object` для первичной фильтрации, так как он работает на более низком уровне и значительно быстрее.
4.  **Помните, что всё есть объект**: Файлы и папки — это объекты .NET с богатым набором свойств и методов. Используйте `Get-Member` для их исследования.

В следующей части мы изучим, как работать с другими хранилищами данных, такими как реестр Windows и переменные окружения, используя те же самые командлеты.
Также мы введем понятие `функция` и научимся интерактивно работать с оболочкой