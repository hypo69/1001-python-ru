## Часть 2: Конвейер (Pipeline), Get-Member, переменные, файл *.ps1* и экспорт результатов

В первой части мы установили ключевой принцип: PowerShell работает с **объектами**, а не с текстом. Теперь мы соберем воедино основные инструменты, которые делают PowerShell таким мощным: научимся передавать объекты по **конвейеру**, "просвечивать" их с помощью **`Get-Member`**, сохранять результаты в **переменные** и автоматизировать все это в **файлах скриптов (`.ps1`)** с **экспортом** результатов в удобные форматы.

### Что такое конвейер (`|`)?
Конвейер в PowerShell это механизм передачи полноценных .NET объектов (а не просто текста) от одной команды 
к другой, где каждый следующий командлет получает структурированные объекты со всеми их свойствами и методами.

Символ `|` (вертикальная черта) — это оператор конвейера. Его задача — взять результат (вывод) команды, стоящей слева от него, и передать его на вход команде, стоящей справа.

`Команда 1 (создает объекты)` → `|` → `Команда 2 (получает и обрабатывает объекты)` → `|` → `Команда 3 (получает обработанные объекты)` → | ...

#### Классический UNIX-конвейер: Поток текста

В `bash` по конвейеру передается **поток байтов**, который обычно интерпретируется как текст.

```bash
# Найти все процессы 'nginx' и посчитать их количество
ps -ef | grep 'nginx' | wc -l
```
Здесь `ps` выводит текст, `grep` фильтрует этот текст, а `wc` считает строки. Каждая утилита ничего не знает о "процессах", она работает только со строками.

#### PowerShell-конвейер: Поток объектов
**Пример:** Давайте получим все процессы, отсортируем их по использованию CPU и выберем 5 самых "прожорливых".

```powershell
Get-Process | Sort-Object -Property CPU -Descending | Select-Object -First 5
```
![1](assets/02/1.png)

Здесь `Get-Process` создает **объекты** процессов. `Sort-Object` получает эти **объекты** и сортирует их по свойству `CPU`. `Select-Object` получает отсортированные **объекты** и выбирает первые 5. 

Вы наверняка заметили в команде выше слова, начинающиеся с дефиса (-): -Property, -Descending, -First. Это параметры.
Параметры — это настройки, переключатели и инструкции для командлета. Они позволяют управлять тем, КАК команда будет выполнять свою работу. Без параметров команда часто работает в режиме по умолчанию, а с параметрами вы даете ей конкретные указания.
Основные типы параметров:

 

    -Параметр со значением: требует дополнительной информации.
        ... -Property CPU: Мы говорим Sort-Object, по какому свойству сортировать. CPU — это значение параметра.
        ... -First 5: Мы говорим Select-Object, сколько объектов выбрать. 5 — это значение параметра.
    - Параметр-переключатель (флаг): Не требует значения. Само его наличие в команде включает или выключает определенное поведение.
        ... -Descending: Этот флаг говорит Sort-Object изменить порядок сортировки на обратный (от большего к меньшему). Ему не нужно дополнительное значение — он сам по себе инструкция.

```powershell
Get-Process -Name 'svchost' | Measure-Object
```

Эта команда отвечает на очень простой вопрос: 
**"Сколько именно процессов с именем `svchost.exe` сейчас запущено в моей системе?"**


### 2. Get-Member (Инспектор объектов)

Мы знаем, что по конвейеру "текут" объекты. Но как узнать, из чего они состоят? Какие у них есть свойства и какие действия (методы) с ними можно совершать?

командлет **`Get-Member`** (псевдоним: `gm`) главный инструмент для исследования. 
Прежде чем работать с объектом, пропустите его через `Get-Member`, чтобы увидеть все его возможности. 

Давайте "просветим" объекты, которые создает `Get-Process`:
```powershell
Get-Process | Get-Member
```
![2](assets/02/2.png)

Разберем каждую часть вывода Get-Member
TypeName: System.Diagnostics.Process - Это полное, официальное "имя типа" объекта из библиотеки .NET. Это его "паспорт".
Эта строка говорит вам, что все объекты, которые возвращает Get-Process, являются объектами типа System.Diagnostics.Process. 
Это гарантирует, что у них у всех будет одинаковый набор свойств и методов. 
Вы можете [загуглить](https://www.google.com/search?q=System.Diagnostics.Process+site%3Amicrosoft.com) "System.Diagnostics.Process", чтобы найти официальную документацию Microsoft с еще более подробной информацией.


### 3. Переменные (Обычные и специальная `$_`)

Что если нам нужно сохранить результат команды для дальнейшего использования? Для этого существуют **переменные**.

#### Обычные переменные (`$myVariable`)

**Переменная** — это именованное хранилище в памяти. В PowerShell ее имя всегда начинается со знака доллара (`$`).

Давайте посчитаем, сколько всего памяти используют процессы `svchost`, и сохраним этот результат.
```powershell
# 1. Выполняем команду и сохраняем ее сложный объект-результат в переменную $svchostMemory
$svchostMemory = Get-Process -Name svchost | Measure-Object -Property WorkingSet64 -Sum

# 2. Теперь мы можем работать с сохраненным объектом. Достаем из него свойство Sum
$memoryInMB = $svchostMemory.Sum / 1MB

# 3. Выводим результат на экран, используя новую переменную
Write-Host "Все процессы svchost используют $memoryInMB МБ памяти."
```
Использование переменных позволяет сохранять сложные результаты, делать код чище и использовать данные многократно.

#### Специальная переменная `$_`

Внутри конвейера существует особая, автоматическая переменная **`$_`** (или ее более современный аналог **`$PSItem`**).

> **`$_` — это "текущий объект" на конвейерной ленте.**

Она используется внутри блоков `{...}` у таких командлетов, как `Where-Object` и `ForEach-Object`, чтобы ссылаться на тот объект, который обрабатывается в данный момент.

**Пример:** Найдем все процессы, запущенные за последний час.
```powershell
$oneHourAgo = (Get-Date).AddHours(-1)

# Для каждого процесса ($_), который идет по конвейеру, мы сравниваем его свойство StartTime
Get-Process | Where-Object { $_.StartTime -gt $oneHourAgo }
```
Здесь `$_` поочередно представляет каждый объект процесса, позволяя нам проверить его свойство `StartTime`.

### 4. Файл *.ps1* (Создание скриптов)

Когда ваша цепочка команд становится полезной, вы захотите сохранить ее для многократного использования. Для этого и нужны **скрипты** — текстовые файлы с расширением **`.ps1`**.

#### Разрешение на запуск скриптов
По умолчанию в Windows запрещен запуск локальных скриптов. Чтобы это исправить **для текущего пользователя**, выполните один раз в PowerShell **от имени администратора**:
```powershell
Set-ExecutionPolicy RemoteSigned -Scope CurrentUser
```
Это безопасная настройка, которая разрешает запускать ваши собственные скрипты и скрипты, подписанные доверенным издателем.

#### Пример скрипта `system_monitor.ps1`
Создайте файл с таким именем и вставьте в него код ниже. Этот скрипт собирает информацию о системе и генерирует отчеты.

```powershell
# system_monitor.ps1
#requires -Version 5.1

<#
.SYNOPSIS
    Скрипт для создания отчета о состоянии системы.
.DESCRIPTION
    Собирает информацию о процессах, службах и дисковом пространстве и генерирует отчеты.
.PARAMETER OutputPath
    Путь для сохранения отчетов. По умолчанию 'C:\Temp'.
.EXAMPLE
    .\system_monitor.ps1 -OutputPath "C:\Reports"
#>
param(
    [Parameter(Mandatory=$false)]
    [string]$OutputPath = "C:\Temp"
)

# --- Блок 1: Подготовка ---
Write-Host "Подготовка к созданию отчета..." -ForegroundColor Cyan
if (!(Test-Path $OutputPath)) {
    New-Item -ItemType Directory -Path $OutputPath -Force | Out-Null
}

# --- Блок 2: Сбор данных ---
Write-Host "Сбор информации..." -ForegroundColor Green
$processes = Get-Process | Sort-Object CPU -Descending
$services = Get-Service | Group-Object Status | Select-Object Name, Count

# --- Блок 3: Вызов функции для экспорта (см. следующий раздел) ---
Export-Results -Processes $processes -Services $services -OutputPath $OutputPath

Write-Host "Отчеты успешно сохранены в папке $OutputPath" -ForegroundColor Magenta
```
*Примечание: функция `Export-Results` будет определена в следующем разделе как пример хорошей практики.*

### 5. Экспорт результатов

Чистые данные — это хорошо, но часто их нужно представить в удобном для человека или другой программы виде. PowerShell предлагает множество командлетов для экспорта.

| Метод                               | Команда                                            | Описание                                                                            |
| ----------------------------------- | -------------------------------------------------- | ----------------------------------------------------------------------------------- |
| **Простой текст**                   | `... \| Out-File C:\Temp\data.txt`                 | Перенаправляет текстовое представление в файл.                                      |
| **CSV (для Excel)**                 | `... \| Export-Csv C:\Temp\data.csv -NoTypeInfo`   | Экспортирует объекты в CSV. `-NoTypeInfo` убирает служебную первую строку.     |
| **HTML-отчет**                      | `... \| ConvertTo-Html -Title "Отчет"`             | Создает HTML-код из объектов.                                                       |
| **JSON (для API, веб)**             | `... \| ConvertTo-Json`                            | Преобразует объекты в формат JSON.                                                  |
| **XML (родной формат PowerShell)** | `... \| Export-Clixml C:\Temp\data.xml`            | Сохраняет объекты со всеми типами данных. Их можно идеально восстановить через `Import-Clixml`. |

#### Дополнение к скрипту: функция экспорта
Давайте добавим в наш скрипт `system_monitor.ps1` функцию, которая будет заниматься экспортом. Поместите этот код **перед** вызовом `Export-Results`.

```powershell
function Export-Results {
    param(
        $Processes,
        $Services,
        $OutputPath
    )

    $timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm"

    # Экспорт в CSV
    $Processes | Select-Object -First 20 | Export-Csv (Join-Path $OutputPath "processes_$timestamp.csv") -NoTypeInformation
    $Services | Export-Csv (Join-Path $OutputPath "services_$timestamp.csv") -NoTypeInformation

    # Создание красивого HTML-отчета
    $htmlReportPath = Join-Path $OutputPath "report_$timestamp.html"
    $processesHtml = $Processes | Select-Object -First 10 Name, Id, CPU | ConvertTo-Html -Fragment -PreContent "<h2>Топ-10 процессов по CPU</h2>"
    $servicesHtml = $Services | ConvertTo-Html -Fragment -PreContent "<h2>Статистика служб</h2>"

    ConvertTo-Html -Head "<title>Отчет о системе</title>" -Body "<h1>Отчет о системе от $(Get-Date)</h1> $($processesHtml) $($servicesHtml)" | Out-File $htmlReportPath
}
```
Теперь наш скрипт не просто собирает данные, но и аккуратно сохраняет их в двух форматах: CSV для анализа и HTML для быстрого просмотра.

### Заключение

1.  **Конвейер (`|`)** — это ваш главный инструмент для объединения команд и обработки объектов.
2.  **`Get-Member`** — ваш "рентген", который показывает, из чего состоят объекты.
3.  **Переменные (`$var`, `$_`)** позволяют сохранять данные и обращаться к текущему объекту в конвейере.
4.  **Файлы `.ps1`** превращают ваши команды в переиспользуемые инструменты автоматизации.
5.  **Командлеты экспорта** (`Export-Csv`, `ConvertTo-Html`) позволяют делиться результатами вашей работы.

**В следующей части мы применим эти знания для навигации и управления файловой системой, исследуя объекты `System.IO.DirectoryInfo` и `System.IO.FileInfo`.**