
## Часть 2: Конвейер (Pipeline), переменные, файл **.ps1*, экспорт результатов.

В первой части мы установили ключевой принцип: PowerShell работает с **объектами**, а не с текстом. 
Теперь давайте разберем **конвейер (pipeline)**. Конвейер — это сердце PowerShell, 
понимание того, как объекты "текут" по нему - ключевое для автоматизации.
Освоив конвейер, вы научитесь строить сложные команды из простых блоков, как из конструктора LEGO.

### Что такое конвейер (`|`)?
Конвейер в PowerShell это механизм передачи полноценных .NET объектов (а не просто текста) от одной команды 
к другой, где каждый следующий командлет получает структурированные объекты со всеми их свойствами и методами.

Символ `|` (вертикальная черта) — это оператор конвейера. Его задача — взять результат (вывод) команды, стоящей слева от него, и передать его на вход команде, стоящей справа.

`Команда 1 (создает объекты)` → `|` → `Команда 2 (получает и обрабатывает объекты)` → `|` → `Команда 3 (получает обработанные объекты)` → | ...

#### Классический UNIX-конвейер: Поток текста

В `bash` по конвейеру передается **поток байтов**, который обычно интерпретируется как текст.

```bash
# Найти все процессы 'nginx' и посчитать их количество
ps -ef | grep 'nginx' | wc -l
```
Здесь `ps` выводит текст, `grep` фильтрует этот текст, а `wc` считает строки. Каждая утилита ничего не знает о "процессах", она работает только со строками.

#### PowerShell-конвейер: Поток объектов

PowerShell по конвейеру передает **полноценные объекты .NET**. Следующая команда в цепочке получает не просто строки, а структурированные сущности со всеми их свойствами и методами.

Команда:
```powershell
Get-Process -Name 'svchost' | Measure-Object
```
![1](assets/02/1.png)
Эта команда отвечает на очень простой вопрос: 
**"Сколько именно процессов с именем `svchost.exe` сейчас запущено в моей системе?"**


### Разбор по шагам

#### **Шаг 1: `Get-Process -Name 'svchost'`**

Эта часть команды обращается к операционной системе и просит найти **все без исключения** запущенные процессы, у которых имя исполняемого файла — `svchost.exe`.
В отличие от процессов типа `notepad` (которых обычно один или два), процессов `svchost` в системе всегда **много**. Команда вернет **массив (коллекцию) объектов**, 
где каждый объект — это отдельный, полноценный процесс `svchost` со своим уникальным ID, использованием памяти и т.д.
PowerShell нашел в системе, например, 89 процессов `svchost` и теперь держит в руках коллекцию из 89 объектов.

#### **Шаг 2: `|` (Оператор конвейера)**

Этот символ берет коллекцию из 89 объектов `svchost`, полученную на первом шаге, и начинает передавать их **по одному** на вход следующей команде.

#### **Шаг 3: `Measure-Object`**

Поскольку мы вызвали `Measure-Object` без параметров (таких как `-Property`, `-Sum` и т.д.), он выполняет свою операцию **по умолчанию** — просто считает количество "предметов", которые ему передали.
Раз, два, три ... После того как все объекты посчитаны, `Measure-Object` создает **свой собственный объект-результат**, в котором есть свойство `Count`, равное итоговому числу.


**`Count: 89`** — это и есть ответ на наш вопрос. Запущено 89 процессов `svchost`. 
Остальные поля пустые, потому что мы не просили `Measure-Object` выполнять более сложные вычисления.

#### Что такое параметры?

**Параметры** — это настройки или инструкции для командлета. Они позволяют управлять тем, 
**КАК** команда будет выполнять свою работу. Без параметров команда работает в режиме по умолчанию 
(как `Measure-Object`, который просто считает). С параметрами вы даете ей конкретные указания.

Параметры в PowerShell всегда начинаются с дефиса (`-`), за которым следует имя параметра. Некоторые параметры требуют **значения** (аргумента). Например: `-Name 'svchost'`. Здесь `-Name` — это параметр, а `'svchost'` — его значение. Другие параметры — это **переключатели (флаги)**. Их простое наличие в команде включает определенную функцию. Например: `-Sum`, `-Average`, `-Maximum`. Им не нужно значение, они сами по себе являются инструкцией.

Параметры `Measure-Object` определяют, **ЧТО ДЕЛАТЬ с входящими объектами**, чтобы создать **НОВЫЙ объект-результат**.

1.  **Входящие объекты (`svchost`):** Они поступают в `Measure-Object` из конвейера. Параметры `Measure-Object` **не изменяют** эти оригинальные объекты.
2.  **Параметры (Инструкции):** Они говорят `Measure-Object`: "Когда будешь обрабатывать входящие объекты, обрати внимание вот на это свойство и выполни вот такое вычисление".
3.  **Объект-результат:** На основе этих инструкций `Measure-Object` формирует свой итоговый объект, в котором будут заполнены соответствующие поля (`Sum`, `Average` и т.д.).

### Пример с `svchost` и параметрами

Давайте изменим нашу задачу. Теперь мы хотим не просто посчитать процессы `svchost`, 
а узнать, **сколько всего оперативной памяти (в мегабайтах) они потребляют вместе**.

Для этого нам понадобятся параметры:
*   `-Property WorkingSet64`: Эта инструкция говорит `Measure-Object`: "Из каждого объекта `svchost`, который к тебе придет, возьми числовое значение из свойства `WorkingSet64` (это использование памяти в байтах)".
*   `-Sum`: Эта инструкция-флаг говорит: "Сложи все эти значения, которые ты взял из свойства `WorkingSet64`".

Наша новая команда будет выглядеть так:
```powershell
Get-Process -Name 'svchost' | Measure-Object -Property WorkingSet64 -Sum
```
1.  `Get-Process` все так же найдет 89 объектов `svchost`.
2.  Конвейер `|` все так же передаст их в `Measure-Object`.
3.  Но теперь `Measure-Object` работает по-новому:
    *   Он берет первый объект `svchost`, смотрит его свойство `.WorkingSet64` (например, `25000000` байт) и запоминает это число.
    *   Берет второй объект, смотрит его `.WorkingSet64` (например, `15000000` байт) и прибавляет к предыдущему.
    *   ...и так далее для всех 89 объектов.
4.  В итоге `Measure-Object` создаст объект-результат, но теперь он будет другим.

### Новый результат
![3](assets/02/3.png)

*   **`Count: 92`**: Он по-прежнему посчитал все объекты.
*   **`Sum: 568435456`**:  Это общая сумма всех значений `WorkingSet64` в байтах.
*   **`Property: WorkingSet64`**: Это поле теперь тоже заполнено, оно информирует нас, какое именно свойство было использовано для вычислений.

Чтобы получить результат в мегабайтах, мы можем сохранить этот объект-результат в переменную и поработать с его свойством `Sum`:

```powershell
$svchostMemory = Get-Process -Name 'svchost' | Measure-Object -Property WorkingSet64 -Sum
$memoryInMB = $svchostMemory.Sum / 1MB
Write-Host "Все процессы svchost используют $memoryInMB МБ памяти."
```
Переменная — это именованное хранилище в памяти, которое содержит какое-либо значение. 
Этим значением может быть что угодно: текст, число, дата или, что самое важное для PowerShell, 
целый объект или даже коллекция объектов. Имя переменной в PowerShell всегда начинается со знака доллара ($).
Примеры: $name, $counter, $processList.
Что такое специальная переменная $_?

$_ — это сокращение для "текущий объект" или "вот эта штука".
Представьте себе конвейер на заводе. По нему едут разные детали (объекты). 
$_ — это та самая деталь, которая находится прямо сейчас перед вами (или перед роботом-обработчиком).
Источник (Get-Process) — высыпает на конвейер целую коробку с деталями (всеми процессами).
Конвейер (|) — заставляет эти детали двигаться по ленте по одной.
Обработчик (Where-Object или ForEach-Object) — это робот, который смотрит на каждую деталь.
Переменная $_ — это та самая деталь, которая сейчас находится в "руках" у робота.
Когда робот закончит с одной деталью, конвейер подает ему следующую, и $_ теперь будет указывать уже на нее.



**Как посмотреть, какие службы "живут" в конкретном `svchost`?**


```powershell
# Показать ID процесса svchost и список служб внутри каждого
Get-Process -Name svchost | Select-Object Id, Services
```
Эта команда покажет вам таблицу с двумя колонками: ID процесса `svchost` и перечень имен служб, 
которые в нем работают. Это отличный способ "заглянуть внутрь" каждого "дома".

![1](assets/02/1.png)

— В колонке Services ничего нет, — скажете вы, глядя на результат на мониторе

— Это не так, — отвечу я вам. И вот почему:

PowerShell по умолчанию не отображает всё содержимое свойства Services — особенно если вы смотрите на результат в табличном виде (Format-Table). Это свойство содержит массив, и его нужно явно запросить, чтобы увидеть.

Отличный вопрос! Это одна из самых частых и важных "ловушек" для начинающих, и ее понимание открывает новый уровень владения PowerShell.

### Короткий ответ:

Колонка `Services` **не пуста**. На самом деле, она заполнена **объектами**. Проблема в том, что стандартный табличный вид PowerShell (`Format-Table`), который используется по умолчанию, не знает, как отобразить **целую коллекцию объектов** внутри одной маленькой ячейки таблицы. Поэтому он просто оставляет ее пустой.

Представьте, что в каждой строке под заголовком `Services` лежит невидимая коробка, набитая визитками (объектами служб). Вы видите коробку (пустую ячейку), но не видите, что внутри.

---

### Подробное объяснение: Почему так происходит?

1.  **Тип данных свойства `Services`:** Если бы мы "просветили" один из объектов `svchost` рентгеном (`Get-Member`), мы бы увидели, что свойство `Services` — это не простой текст, а **коллекция (массив) объектов** типа `System.ServiceProcess.ServiceController`. Каждый из этих объектов — это полноценная служба со своими свойствами (`DisplayName`, `Status` и т.д.).

2.  **Ограничение табличного вида:** Табличный вид (`Format-Table`) отлично подходит для отображения простых, "плоских" данных: строк, чисел, дат. Когда он натыкается на ячейку, в которую нужно поместить целую коллекцию других объектов, он сдается и показывает пустое место.

### Как увидеть содержимое? (Решения)

Вот три способа "открыть коробку" и увидеть службы. Выбирайте тот, который подходит для вашей задачи.

#### Решение 1: Использовать `Format-List` (Самый простой способ)

`Format-List` (псевдоним `fl`) отображает каждый объект в виде списка его свойств. В отличие от таблицы, у него достаточно места, чтобы показать содержимое сложных свойств.

**Команда:**
```powershell
Get-Process -Name svchost | Select-Object Id, Services | Format-List
```
**Результат будет выглядеть примерно так:**

```
Id       : 788
Services : {AudioEndpointBuilder, Audiosrv, FontCache...}

Id       : 988
Services : {BrokerInfrastructure, DcomLaunch, Power, SystemEventsBroker}

Id       : 1384
Services : {Themes, UsoSvc, WaaSMedicSvc, WpnService}

...
```
Теперь вы четко видите, что в свойстве `Services` для каждого ID процесса находится список имен служб!

#### Решение 2: "Развернуть" свойство с помощью `Select-Object -ExpandProperty` (Самый мощный способ)

Этот метод берет коллекцию, которая лежит внутри свойства `Services`, и **"выворачивает" ее наружу**. Каждый элемент вложенной коллекции становится отдельным объектом в конвейере.

**Команда:**
```powershell
Get-Process -Name svchost | Select-Object -ExpandProperty Services
```
**Результат:**
Теперь вы получите **список самих объектов служб**, а не процессов. У каждого будет свое имя, статус и т.д.

```
Status   Name               DisplayName
------   ----               -----------
Running  AudioEndpointBuilder Windows Audio Endpoint Builder
Running  Audiosrv           Windows Audio
Running  FontCache          Windows Font Cache Service
...
```
Этот способ идеален, если вы хотите дальше работать именно со службами (например, отсортировать их по имени или отфильтровать только запущенные).

#### Решение 3: Создать вычисляемое свойство (Самый "красивый" способ для таблиц)

Вы можете сказать `Select-Object` создать новую, "виртуальную" колонку, в которой все имена служб будут объединены в одну строку через запятую.

**Команда:**
```powershell
Get-Process -Name svchost | Select-Object Id, @{Name="ServiceNames"; Expression={$_.Services.DisplayName -join ", "}}
```
**Результат будет именно таким, как вы ожидали:**
```
  Id ServiceNames
  -- ------------
 788 AudioEndpointBuilder, Audiosrv, FontCache...
 988 BrokerInfrastructure, DcomLaunch, Power, SystemEventsBroker
1384 Themes, UsoSvc, WaaSMedicSvc, WpnService
...
```
**Как это работает:**
*   `@{Name="..."; Expression={...}}` — синтаксис для создания вычисляемого свойства.
*   `$_.Services.DisplayName` — для текущего процесса (`$_`) берет его свойство `Services` (коллекцию служб) и у **каждой службы в этой коллекции** забирает ее свойство `DisplayName`.
*   `-join ", "` — объединяет все полученные имена в одну строку, разделяя их запятой с пробелом.

### Итог

| Метод                                       | Что делает                                                                    | Когда использовать                                                  |
|---------------------------------------------|-------------------------------------------------------------------------------|---------------------------------------------------------------------|
| **`Format-List`**                           | Показывает содержимое сложных свойств в виде списка.                          | Для быстрой диагностики и просмотра "что внутри".                   |
| **`Select-Object -ExpandProperty Services`** | "Разворачивает" коллекцию служб, делая каждую службу отдельным объектом.     | Когда вы хотите дальше фильтровать, сортировать или работать со службами. |
| **Вычисляемое свойство**                    | Создает новую колонку с отформатированными данными для удобного чтения в таблице. | Когда вам нужен красивый и компактный отчет в табличном виде.          |

## Строительные блоки конвейера

Давайте рассмотрим основные командлеты, которые вы будете использовать в конвейере каждый день.

### 1. Источник (Source): `Get-Process`

Начнем с командлета, который **генерирует объекты**. `Get-Process` возвращает коллекцию объектов, каждый из которых представляет один запущенный процесс.

```powershell
Get-Process
```

Вы увидите таблицу с информацией: Handles, NPM, PM, WS, CPU, ID и ProcessName.

**Важно:** То, что вы видите в консоли — это не сам объект, а лишь его **форматированное представление**. PowerShell "знает", как лучше всего отобразить объекты типа `Process`. Чтобы увидеть *все* свойства объекта, используйте `Format-List`:

```powershell
# Показать все свойства для процессов с именем "powershell"
Get-Process -Name "powershell" | Format-List *
```

### 2. Исследователь (Inspector): `Get-Member`

Как узнать, из чего состоят эти объекты? Для этого существует "рентгеновский аппарат" — командлет `Get-Member` (псевдоним `gm`). Он анализирует структуру объекта и показывает все его свойства и методы.

```powershell
Get-Process | Get-Member
```

**Результат:**
```
   TypeName: System.Diagnostics.Process

Name        MemberType     Definition
----        ----------     ----------
Kill        Method         void Kill()
Refresh     Method         void Refresh()
...
Company     Property       string Company {get;}
CPU         Property       double CPU {get;}
Id          Property       int Id {get;}
ProcessName Property       string ProcessName {get;}
StartTime   Property       datetime StartTime {get;}
...
```
*   **TypeName**: Тип объекта (`System.Diagnostics.Process`).
*   **Method**: 🛠️ Действие, которое можно совершить с объектом (`.Kill()`, `.Refresh()`).
*   **Property**: 🧱 Свойство или характеристика объекта (`Id`, `ProcessName`, `StartTime`).

`Get-Member` — ваш главный инструмент для исследования. Если не знаете, как получить данные из объекта, пропустите его через `Get-Member`.

### 3. Фильтр (Filter): `Where-Object` и переменная `$_`

Это один из самых важных командлетов. `Where-Object` (псевдоним `Where` или `?`) позволяет отфильтровать объекты в конвейере, пропуская дальше только те, которые соответствуют вашему условию.

Внутри блока `Where-Object` используется специальная переменная `$_`.

> **`$_` — это текущий объект в конвейере.**

Представьте, что объекты идут по конвейеру один за другим. `$_` — это тот самый объект, который находится на "проверочном пункте" `Where-Object` в данный момент.

```powershell
# 1. Get-Process получает ВСЕ процессы.
# 2. Они по одному передаются в Where-Object.
# 3. Для каждого объекта ($_), PowerShell проверяет, равно ли его свойство ProcessName строке 'notepad'.
# 4. Если да, объект проходит дальше. Если нет, отбрасывается.

Get-Process | Where-Object { $_.ProcessName -eq 'notepad' }
```

Теперь, зная о свойстве `StartTime` (из `Get-Member`), мы можем легко найти все процессы, запущенные за последний час:

```powershell
$oneHourAgo = (Get-Date).AddHours(-1)
Get-Process | Where-Object { $_.StartTime -gt $oneHourAgo }
```

### 4. Отбор и трансформация (Selector): `Select-Object`

`Select-Object` (псевдоним `Select`) используется для выбора нужных свойств или для создания новых, вычисляемых свойств.

```powershell
# Выбрать только имя, ID и загрузку процессора
Get-Process | Sort-Object CPU -Descending | Select-Object -First 10 | Select-Object ProcessName, Id, CPU
```

А теперь магия — **создадим новое свойство "на лету"**:

```powershell
# Добавим свойство MemoryMB, которое будет содержать память в мегабайтах
Get-Process | Select-Object ProcessName, @{Name="MemoryMB"; Expression={ [Math]::Round($_.WorkingSet64 / 1MB, 2) }}
```
*   `@{...}` — это синтаксис для создания хеш-таблицы (словаря).
*   `Name` — имя нашего нового свойства.
*   `Expression` — блок кода, который вычисляет значение. И здесь мы снова используем `$_` для доступа к текущему объекту!

### 5. Выполнение действий (Actor): `ForEach-Object`

`ForEach-Object` (псевдоним `ForEach` или `%`) выполняет указанное действие **для каждого объекта**, прошедшего по конвейеру.

```powershell
# Остановить все "зависшие" процессы Блокнота
# Параметр -WhatIf не выполнит действие, а покажет, что БЫ произошло. Используйте его для безопасности!
Get-Process notepad | Where-Object { -not $_.Responding } | ForEach-Object { $_.Kill() } -WhatIf
```

### 6. Группировка и подсчет: `Group-Object` и `Measure-Object`

Эти командлеты позволяют агрегировать данные.

*   `Group-Object`: Группирует объекты по значению свойства.
*   `Measure-Object`: Считает количество объектов, находит сумму, среднее и т.д.

```powershell
# Сгруппировать все процессы по компании-производителю и отсортировать по количеству
Get-Process | Where-Object Company | Group-Object Company | Sort-Object Count -Descending

# Посчитать, сколько всего запущено процессов
Get-Process | Measure-Object # Свойство Count в результате
```

---

## От консоли к автоматизации: Сохранение результатов и создание скриптов

После того как вы построили идеальную команду в конвейере, результат нужно сохранить или превратить в скрипт для многократного использования.

### Сохранение результатов

| Метод                               | Команда                                                                                                        | Описание                                                                            |
| ----------------------------------- | -------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------- |
| **Простой текст**                   | `Get-Process > C:\Temp\procs.txt`                                                                              | Перенаправляет текстовое представление в файл (перезаписывает). Используйте `>>` для добавления. |
| **Текст с контролем**               | `Get-Process \| Out-File C:\Temp\procs.txt -Encoding utf8`                                                      | `Out-File` дает больше контроля, например, над кодировкой.                          |
| **CSV (для Excel)**                 | `Get-Process \| Export-Csv C:\Temp\procs.csv -NoTypeInformation`                                                | Экспортирует объекты в CSV. `-NoTypeInformation` убирает служебную первую строку.     |
| **JSON (для API, веб)**             | `Get-Service \| ConvertTo-Json \| Out-File C:\Temp\services.json`                                               | Преобразует объекты в формат JSON.                                                  |
| **HTML-отчет**                      | `Get-Process \| ConvertTo-Html -Title "Отчет" \| Out-File C:\Temp\report.html`                                  | Создает готовый HTML-файл из объектов.                                              |
| **XML (родной формат PowerShell)** | `Get-Process \| Export-Clixml C:\Temp\procs.xml`                                                              | Сохраняет объекты со всеми типами данных. Их можно идеально восстановить через `Import-Clixml`. |

### Пример: создание красивого HTML-отчета

```powershell
Get-Process |
  Sort-Object CPU -Descending |
  Select-Object -First 10 Name, Id, @{Name="Memory(MB)";Expression={[Math]::Round($_.WorkingSet/1MB,2)}} |
  ConvertTo-Html -Title "System Processes Report" -PreContent "<h1>Топ-10 процессов по CPU</h1>" |
  Out-File "C:\Temp\processes_report.html"

# Открыть отчет в браузере по умолчанию
Invoke-Item "C:\Temp\processes_report.html"
```

### Создание вашего первого скрипта (`.ps1`)

Скрипт — это просто текстовый файл с набором команд PowerShell и расширением `.ps1`.

#### Политика выполнения скриптов
По умолчанию в Windows запрещен запуск локальных скриптов. Чтобы это исправить для текущего пользователя, выполните один раз в PowerShell от имени администратора:
```powershell
Set-ExecutionPolicy RemoteSigned -Scope CurrentUser
```

#### Пример продвинутого скрипта: Мониторинг системы

Создайте файл `system_monitor.ps1` и вставьте в него этот код. Он собирает информацию о системе и генерирует комплексный HTML-отчет.

```powershell
# system_monitor.ps1
#requires -Version 5.1

<#
.SYNOPSIS
    Скрипт для создания отчета о состоянии системы.
.DESCRIPTION
    Собирает информацию о процессах, службах и дисковом пространстве и генерирует отчеты в CSV и HTML.
.PARAMETER OutputPath
    Путь для сохранения отчетов. По умолчанию 'C:\Temp'.
.EXAMPLE
    .\system_monitor.ps1 -OutputPath "C:\Reports"
#>

param(
    [Parameter(Mandatory=$false)]
    [string]$OutputPath = "C:\Temp"
)

# --- Блок 1: Подготовка ---
Write-Host "Подготовка к созданию отчета..." -ForegroundColor Cyan

# Проверка и создание папки для отчетов
if (!(Test-Path $OutputPath)) {
    New-Item -ItemType Directory -Path $OutputPath -Force | Out-Null
}

# --- Блок 2: Сбор данных ---
Write-Host "Собираем информацию о процессах..." -ForegroundColor Green
$processes = Get-Process | Select-Object Name, Id, CPU, @{Name="MemoryMB";Expression={[Math]::Round($_.WorkingSet/1MB,2)}} | Sort-Object CPU -Descending

Write-Host "Собираем информацию о службах..." -ForegroundColor Green
$services = Get-Service | Group-Object Status | Select-Object Name, Count

Write-Host "Собираем информацию о дисках..." -ForegroundColor Green
$disks = Get-CimInstance -ClassName Win32_LogicalDisk | Where-Object { $_.DriveType -eq 3 } |
    Select-Object DeviceID,
        @{Name="SizeGB";Expression={[Math]::Round($_.Size/1GB,2)}},
        @{Name="FreeSpaceGB";Expression={[Math]::Round($_.FreeSpace/1GB,2)}},
        @{Name="PercentFree";Expression={[Math]::Round(($_.FreeSpace/$_.Size)*100,2)}}

# --- Блок 3: Создание HTML отчета ---
Write-Host "Формируем HTML-отчет..." -ForegroundColor Yellow

$timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm"
$reportPath = Join-Path $OutputPath "system_report_$timestamp.html"

$htmlHeader = @"
<!DOCTYPE html>
<html>
<head>
    <title>Отчет о состоянии системы - $(Get-Date)</title>
    <style>
        body { font-family: 'Segoe UI', sans-serif; margin: 20px; background-color: #f4f4f4; color: #333; }
        table { border-collapse: collapse; width: 80%; margin: 20px auto; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        th, td { border: 1px solid #ddd; padding: 12px; text-align: left; }
        th { background-color: #0078D4; color: white; }
        tr:nth-child(even) { background-color: #f2f2f2; }
        h1, h2 { color: #005A9E; text-align: center; }
        .container { max-width: 1200px; margin: auto; background: white; padding: 20px; border-radius: 8px; }
    </style>
</head>
<body>
<div class="container">
    <h1>Отчет о состоянии системы</h1>
    <p style="text-align:center;">Создан: $(Get-Date)</p>
"@

# Преобразуем каждую часть данных в HTML-фрагмент
$processesHtml = $processes | Select-Object -First 10 | ConvertTo-Html -As Table -Fragment -PreContent "<h2>Топ-10 процессов по использованию CPU</h2>"
$servicesHtml = $services | ConvertTo-Html -As Table -Fragment -PreContent "<h2>Статистика служб</h2>"
$disksHtml = $disks | ConvertTo-Html -As Table -Fragment -PreContent "<h2>Использование дискового пространства</h2>"

$htmlFooter = @"
</div>
</body>
</html>
"@

# Собираем все части вместе
$htmlContent = $htmlHeader + $processesHtml + $servicesHtml + $disksHtml + $htmlFooter
$htmlContent | Out-File $reportPath -Encoding UTF8

Write-Host "Отчет успешно сохранен: $reportPath" -ForegroundColor Magenta
# Invoke-Item $reportPath # Раскомментируйте, чтобы автоматически открывать отчет
```

### Заключение


2.  **Исследуйте**: `Get-Member` — ваш лучший друг.
3.  **Используйте `$_`**: Это ваш ключ к текущему объекту в конвейере.
4.  **Безопасность прежде всего**: Применяйте `-WhatIf` для команд, вносящих изменения.
5.  **Автоматизируйте**: Сохраняйте удачные команды в `.ps1`-скрипты.

**В следующей части мы применим эти знания для навигации и управления файловой системой, исследуя объекты `System.IO.DirectoryInfo` и `System.IO.FileInfo`.**