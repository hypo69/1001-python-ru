### **Часть 2: Конвейер (Pipeline) и работа с объектами.**

В первой главе мы установили ключевой принцип: PowerShell работает с объектами, а не с текстом. Теперь давайте разберем главный механизм, который делает эту работу такой элегантной и мощной — **конвейер (pipeline)**. Освоив конвейер, вы научитесь строить сложные команды из простых блоков, как из конструктора LEGO. Это концепция, заимствованная из UNIX, но кардинально переосмысленная Microsoft.

#### **Что такое конвейер (`|`)? От текста к объектам.**

Символ `|` (вертикальная черта) — это оператор конвейера. Его задача — взять результат (вывод) команды, стоящей слева от него, и передать его на вход команде, стоящей справа.

**Классический UNIX-конвейер:**
В `sh` или `bash` по конвейеру передается **поток байтов**, который обычно интерпретируется как **текст**. Например:

```bash
# Найти все процессы, запущенные пользователем 'root', и посчитать их количество
ps -ef | grep 'root' | wc -l
```

Здесь `ps` выводит текст, `grep` фильтрует этот текст по строке 'root', а `wc -l` считает количество оставшихся строк. Каждая утилита ничего не знает о "процессах", она работает только со строками.

**PowerShell: Конвейер объектов**
PowerShell по конвейеру передаются **полноценные объекты .NET**. Следующая команда в цепочке получает не просто строки, а структурированные сущности со всеми их свойствами и методами.

Давайте посмотрим на аналогичную задачу в PowerShell:

```powershell
Get-Process | Where-Object { $_.UserName -like '*SYSTEM*' } | Measure-Object
```

Здесь `Get-Process` возвращает **массив объектов** `System.Diagnostics.Process`. `Where-Object` получает **каждый объект целиком** и проверяет его свойство `UserName`. `Measure-Object` получает отфильтрованные объекты и считает их количество. Никакого "парсинга" текста не происходит на всем протяжении цепочки.

#### **Командлет `Get-Process`: Получаем поток объектов**

Давайте начнем с простого и наглядного командлета `Get-Process`. Без параметров он возвращает коллекцию объектов, каждый из которых представляет один запущенный на вашем компьютере процесс.

**Практика:**
Введите в консоль:

```powershell
Get-Process
```

Вы увидите таблицу с информацией о процессах: количество "хэндлов" (Handles), использование памяти (NPM, PM, WS) и процессора (CPU), ID процесса и его имя (ProcessName).

**Важный нюанс:** То, что вы видите в консоли — это не сам объект, а лишь его **форматированное представление**. PowerShell имеет сложную систему форматирования вывода. По умолчанию, для объектов типа `System.Diagnostics.Process` он применяет специальный файл форматирования (`.format.ps1xml`), который определяет, какие свойства и в каком виде показать в виде таблицы.

Чтобы увидеть "сырые" свойства объекта без форматирования, можно использовать `Format-List`:

```powershell
Get-Process -Name "powershell" | Format-List *
```

Эта команда покажет **все** свойства объекта процесса PowerShell, а не только те, что отображаются в таблице по умолчанию.

#### **Командлет `Get-Member`: Рентгеновский аппарат для объектов**

Как нам узнать, из чего состоят эти объекты? Какая еще информация в них скрыта, помимо той, что мы видим? Для этого существует диагностический командлет `Get-Member` (псевдоним `gm`). Он не меняет объекты, а лишь анализирует их структуру (этот процесс называется **рефлексия**) и показывает нам все доступные "кирпичики": свойства, методы и события.

**Практика: Соединяем команды в конвейер**

Теперь давайте соединим наши две команды. Мы возьмем объекты, которые возвращает `Get-Process`, и передадим их **по одному** на анализ в `Get-Member`.

```powershell
Get-Process | Get-Member
```

Результат будет выглядеть примерно так:

```
   TypeName: System.Diagnostics.Process

Name                       MemberType     Definition
----                       ----------     ----------
Kill                       Method         void Kill(), void Kill(bool entireProcessTree)
Refresh                    Method         void Refresh()
Start                      Method         static System.Diagnostics.Process Start(string fileName)
WaitForExit                Method         bool WaitForExit(int milliseconds), void WaitForExit()
...
Company                    Property       string Company {get;}
CPU                        Property       double CPU {get;}
HasExited                  Property       bool HasExited {get;}
Handles                    Property       int Handles {get;}
Id                         Property       int Id {get;}
MainModule                 Property       System.Diagnostics.ProcessModule MainModule {get;}
ProcessName                Property       string ProcessName {get;}
Responding                 Property       bool Responding {get;}
StartTime                  Property       datetime StartTime {get;}
...
```

**Разберем вывод подробнее:**

*   **TypeName:** PowerShell сообщает нам, с каким типом объектов мы работаем — `System.Diagnostics.Process`. Это класс из библиотеки .NET. Все процессы, возвращаемые `Get-Process`, будут этого типа.
*   **Name:** Имя "члена" объекта (свойства или метода).
*   **MemberType:**
    *   **Method:** Действие, которое можно совершить с объектом. Например, у каждого процесса есть метод `Kill()`, который позволяет его принудительно завершить. Методы всегда имеют скобки `()`, в которых могут быть параметры. Метод `Start` является `static`, то есть он принадлежит классу `Process` в целом, а не конкретному экземпляру.
    *   **Property:** Свойство или характеристика объекта. Например, `Id` (уникальный идентификатор процесса), `ProcessName` (имя процесса), `StartTime` (время запуска) или `Responding` (отвечает ли приложение на запросы системы). Это "переменные" внутри объекта.
    *   **ScriptProperty/AliasProperty:** Это свойства, добавленные самим PowerShell для удобства. Например, свойство `CPU` на самом деле является `ScriptProperty` — PowerShell "на лету" вычисляет его значение при обращении.

`Get-Member` — это ваш самый надежный инструмент для исследования PowerShell. Если вы не знаете, как получить ту или иную информацию из объекта, пропустите его через `Get-Member`, и вы увидите все его скрытые возможности.

**Пример использования полученных знаний:**

Теперь, зная о свойстве `StartTime`, мы можем легко найти все процессы, запущенные за последний час:

```powershell
$oneHourAgo = (Get-Date).AddHours(-1)
Get-Process | Where-Object { $_.StartTime -gt $oneHourAgo }
```
*(Не волнуйтесь, если синтаксис пока не до конца понятен, мы подробно разберем переменные, `Where-Object` и операторы сравнения в следующих главах.)*


**В следующей части мы применим эти знания для навигации и управления файловой системой, исследуя объекты `System.IO.DirectoryInfo` и `System.IO.FileInfo`.**