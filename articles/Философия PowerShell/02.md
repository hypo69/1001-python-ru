
## Часть 2: Конвейер (Pipeline)

В первой части мы установили ключевой принцип: PowerShell работает с **объектами**, а не с текстом. 
Теперь давайте разберем **конвейер (pipeline)**. Конвейер — это сердце PowerShell, 
понимание того, как объекты "текут" по нему - ключевое для автоматизации.
Освоив конвейер, вы научитесь строить сложные команды из простых блоков, как из конструктора LEGO.

### Что такое конвейер (`|`)?
Конвейер в PowerShell это механизм передачи полноценных .NET объектов (а не просто текста) от одной команды 
к другой, где каждый следующий командлет получает структурированные объекты со всеми их свойствами и методами.

Символ `|` (вертикальная черта) — это оператор конвейера. Его задача — взять результат (вывод) команды, стоящей слева от него, и передать его на вход команде, стоящей справа.

`Команда 1 (создает объекты)` → `|` → `Команда 2 (получает и обрабатывает объекты)` → `|` → `Команда 3 (получает обработанные объекты)` → | ...

#### Классический UNIX-конвейер: Поток текста

В `bash` по конвейеру передается **поток байтов**, который обычно интерпретируется как текст.

```bash
# Найти все процессы 'nginx' и посчитать их количество
ps -ef | grep 'nginx' | wc -l
```
Здесь `ps` выводит текст, `grep` фильтрует этот текст, а `wc` считает строки. Каждая утилита ничего не знает о "процессах", она работает только со строками.

#### PowerShell-конвейер: Поток объектов

PowerShell по конвейеру передает **полноценные объекты .NET**. Следующая команда в цепочке получает не просто строки, а структурированные сущности со всеми их свойствами и методами.

Команда:
```powershell
Get-Process -Name 'svchost' | Measure-Object
```
Эта команда отвечает на очень простой вопрос: 
**"Сколько именно процессов с именем `svchost.exe` сейчас запущено в моей системе?"**


### Разбор по шагам

#### **Шаг 1: `Get-Process -Name 'svchost'`**

Эта часть команды обращается к операционной системе и просит найти **все без исключения** запущенные процессы, у которых имя исполняемого файла — `svchost.exe`.
В отличие от процессов типа `notepad` (которых обычно один или два), процессов `svchost` в системе всегда **много**. Команда вернет **массив (коллекцию) объектов**, 
где каждый объект — это отдельный, полноценный процесс `svchost` со своим уникальным ID, использованием памяти и т.д.
PowerShell нашел в системе, например, 15 процессов `svchost` и теперь держит в руках коллекцию из 15 объектов.

#### **Шаг 2: `|` (Оператор конвейера)**

Этот символ берет коллекцию из 15 объектов `svchost`, полученную на первом шаге, и начинает передавать их **по одному** на вход следующей команде.

#### **Шаг 3: `Measure-Object`**

Поскольку мы вызвали `Measure-Object` без параметров (таких как `-Property`, `-Sum` и т.д.), он выполняет свою операцию **по умолчанию** — просто считает количество "предметов", которые ему передали.
Раз, два, три ... После того как все объекты посчитаны, `Measure-Object` создает **свой собственный объект-результат**, в котором есть свойство `Count`, равное итоговому числу.

### Ожидаемый результат

Вы увидите на экране что-то вроде этого (точное число будет зависеть от вашей системы):
```
Count    : 15
Average  :
Sum      :
Maximum  :
Minimum  :
Property :
```
*   **`Count: 15`** — это и есть ответ на наш вопрос. Запущено 15 процессов `svchost`.
*   Остальные поля (`Average`, `Sum` и т.д.) пустые, потому что мы не просили `Measure-Object` измерять какое-либо числовое свойство (например, память или загрузку CPU) у этих объектов. Мы просто попросили их посчитать.



Отличное дополнение! Вы затронули самую суть того, как PowerShell работает. Давайте подробно разберем, что такое параметры и как они связывают команду с объектами.

Я дополню предыдущее объяснение новым разделом.

---

*(Начало предыдущего объяснения остается без изменений...)*

### Шаг 3: `Measure-Object`

Поскольку мы вызвали `Measure-Object` без параметров, он выполняет свою операцию **по умолчанию** — просто считает количество "предметов", которые ему передали. Раз, два, три... После того как все объекты посчитаны, `Measure-Object` создает **свой собственный объект-результат**, в котором есть свойство `Count`, равное итоговому числу.

### Ожидаемый результат

```
Count    : 15
Average  :
Sum      :
Maximum  :
Minimum  :
Property :
```
*   **`Count: 15`** — это и есть ответ на наш вопрос. Запущено 15 процессов `svchost`.
*   Остальные поля пустые, потому что мы не просили `Measure-Object` выполнять более сложные вычисления.

---


#### Что такое параметры?

**Параметры — это настройки или инструкции для командлета.** Они позволяют вам управлять тем, 
**КАК** команда будет выполнять свою работу. Без параметров команда работает в режиме по умолчанию 
(как `Measure-Object`, который просто считает). С параметрами вы даете ей конкретные указания.

Параметры в PowerShell всегда начинаются с дефиса (`-`), за которым следует имя параметра.

*   Некоторые параметры требуют **значения** (аргумента). Например: `-Name 'svchost'`. Здесь `-Name` — это параметр, а `'svchost'` — его значение.
*   Другие параметры — это **переключатели (флаги)**. Их простое наличие в команде включает определенную функцию. Например: `-Sum`, `-Average`, `-Maximum`. Им не нужно значение, они сами по себе являются инструкцией.

Параметры `Measure-Object` определяют, **ЧТО ДЕЛАТЬ с входящими объектами**, чтобы создать **НОВЫЙ объект-результат**.

1.  **Входящие объекты (`svchost`):** Они поступают в `Measure-Object` из конвейера. Параметры `Measure-Object` **не изменяют** эти оригинальные объекты.
2.  **Параметры (Инструкции):** Они говорят `Measure-Object`: "Когда будешь обрабатывать входящие объекты, обрати внимание вот на это свойство и выполни вот такое вычисление".
3.  **Объект-результат:** На основе этих инструкций `Measure-Object` формирует свой итоговый объект, в котором будут заполнены соответствующие поля (`Sum`, `Average` и т.д.).

### Пример с `svchost` и параметрами

Давайте изменим нашу задачу. Теперь мы хотим не просто посчитать процессы `svchost`, 
а узнать, **сколько всего оперативной памяти (в мегабайтах) они потребляют вместе**.

Для этого нам понадобятся параметры:
*   `-Property WorkingSet64`: Эта инструкция говорит `Measure-Object`: "Из каждого объекта `svchost`, который к тебе придет, возьми числовое значение из свойства `WorkingSet64` (это использование памяти в байтах)".
*   `-Sum`: Эта инструкция-флаг говорит: "Сложи все эти значения, которые ты взял из свойства `WorkingSet64`".

Наша новая команда будет выглядеть так:
```powershell
Get-Process -Name 'svchost' | Measure-Object -Property WorkingSet64 -Sum
```

#### Что произойдет теперь?
1.  `Get-Process` все так же найдет 15 объектов `svchost`.
2.  Конвейер `|` все так же передаст их в `Measure-Object`.
3.  Но теперь `Measure-Object` работает по-новому:
    *   Он берет первый объект `svchost`, смотрит его свойство `.WorkingSet64` (например, `25000000` байт) и запоминает это число.
    *   Берет второй объект, смотрит его `.WorkingSet64` (например, `15000000` байт) и прибавляет к предыдущему.
    *   ...и так далее для всех 15 объектов.
4.  В итоге `Measure-Object` создаст объект-результат, но теперь он будет другим.

### Новый ожидаемый результат
```
Count    : 15
Average  :
Sum      : 568435456
Maximum  :
Minimum  :
Property : WorkingSet64
```

*   **`Count: 15`**: Он по-прежнему посчитал все объекты.
*   **`Sum: 568435456`**:  Это общая сумма всех значений `WorkingSet64` в байтах.
*   **`Property: WorkingSet64`**: Это поле теперь тоже заполнено, оно информирует нас, какое именно свойство было использовано для вычислений.



Чтобы получить результат в мегабайтах, мы можем сохранить этот объект-результат в переменную и поработать с его свойством `Sum`:

```powershell
$svchostMemory = Get-Process -Name 'svchost' | Measure-Object -Property WorkingSet64 -Sum
$memoryInMB = $svchostMemory.Sum / 1MB
Write-Host "Все процессы svchost используют $memoryInMB МБ памяти."
```

Таким образом, **параметр**, позволяет точно указать, как обрабатывать передаваемые по конвейеру объекты для получения нужного результата.


**Как посмотреть, какие службы "живут" в конкретном `svchost`?**


```powershell
# Показать ID процесса svchost и список служб внутри каждого
Get-Process -Name svchost | Select-Object Id, Services
```
Эта команда покажет вам таблицу с двумя колонками: ID процесса `svchost` и перечень имен служб, 
которые в нем работают. Это отличный способ "заглянуть внутрь" каждого "дома".

---

## Строительные блоки конвейера

Давайте рассмотрим основные командлеты, которые вы будете использовать в конвейере каждый день.

### 1. Источник (Source): `Get-Process`

Начнем с командлета, который **генерирует объекты**. `Get-Process` возвращает коллекцию объектов, каждый из которых представляет один запущенный процесс.

```powershell
Get-Process
```

Вы увидите таблицу с информацией: Handles, NPM, PM, WS, CPU, ID и ProcessName.

**Важно:** То, что вы видите в консоли — это не сам объект, а лишь его **форматированное представление**. PowerShell "знает", как лучше всего отобразить объекты типа `Process`. Чтобы увидеть *все* свойства объекта, используйте `Format-List`:

```powershell
# Показать все свойства для процессов с именем "powershell"
Get-Process -Name "powershell" | Format-List *
```

### 2. Исследователь (Inspector): `Get-Member`

Как узнать, из чего состоят эти объекты? Для этого существует "рентгеновский аппарат" — командлет `Get-Member` (псевдоним `gm`). Он анализирует структуру объекта и показывает все его свойства и методы.

```powershell
Get-Process | Get-Member
```

**Результат:**
```
   TypeName: System.Diagnostics.Process

Name        MemberType     Definition
----        ----------     ----------
Kill        Method         void Kill()
Refresh     Method         void Refresh()
...
Company     Property       string Company {get;}
CPU         Property       double CPU {get;}
Id          Property       int Id {get;}
ProcessName Property       string ProcessName {get;}
StartTime   Property       datetime StartTime {get;}
...
```
*   **TypeName**: Тип объекта (`System.Diagnostics.Process`).
*   **Method**: 🛠️ Действие, которое можно совершить с объектом (`.Kill()`, `.Refresh()`).
*   **Property**: 🧱 Свойство или характеристика объекта (`Id`, `ProcessName`, `StartTime`).

`Get-Member` — ваш главный инструмент для исследования. Если не знаете, как получить данные из объекта, пропустите его через `Get-Member`.

### 3. Фильтр (Filter): `Where-Object` и переменная `$_`

Это один из самых важных командлетов. `Where-Object` (псевдоним `Where` или `?`) позволяет отфильтровать объекты в конвейере, пропуская дальше только те, которые соответствуют вашему условию.

Внутри блока `Where-Object` используется специальная переменная `$_`.

> **`$_` — это текущий объект в конвейере.**

Представьте, что объекты идут по конвейеру один за другим. `$_` — это тот самый объект, который находится на "проверочном пункте" `Where-Object` в данный момент.

```powershell
# 1. Get-Process получает ВСЕ процессы.
# 2. Они по одному передаются в Where-Object.
# 3. Для каждого объекта ($_), PowerShell проверяет, равно ли его свойство ProcessName строке 'notepad'.
# 4. Если да, объект проходит дальше. Если нет, отбрасывается.

Get-Process | Where-Object { $_.ProcessName -eq 'notepad' }
```

Теперь, зная о свойстве `StartTime` (из `Get-Member`), мы можем легко найти все процессы, запущенные за последний час:

```powershell
$oneHourAgo = (Get-Date).AddHours(-1)
Get-Process | Where-Object { $_.StartTime -gt $oneHourAgo }
```

### 4. Отбор и трансформация (Selector): `Select-Object`

`Select-Object` (псевдоним `Select`) используется для выбора нужных свойств или для создания новых, вычисляемых свойств.

```powershell
# Выбрать только имя, ID и загрузку процессора
Get-Process | Sort-Object CPU -Descending | Select-Object -First 10 | Select-Object ProcessName, Id, CPU
```

А теперь магия — **создадим новое свойство "на лету"**:

```powershell
# Добавим свойство MemoryMB, которое будет содержать память в мегабайтах
Get-Process | Select-Object ProcessName, @{Name="MemoryMB"; Expression={ [Math]::Round($_.WorkingSet64 / 1MB, 2) }}
```
*   `@{...}` — это синтаксис для создания хеш-таблицы (словаря).
*   `Name` — имя нашего нового свойства.
*   `Expression` — блок кода, который вычисляет значение. И здесь мы снова используем `$_` для доступа к текущему объекту!

### 5. Выполнение действий (Actor): `ForEach-Object`

`ForEach-Object` (псевдоним `ForEach` или `%`) выполняет указанное действие **для каждого объекта**, прошедшего по конвейеру.

```powershell
# Остановить все "зависшие" процессы Блокнота
# Параметр -WhatIf не выполнит действие, а покажет, что БЫ произошло. Используйте его для безопасности!
Get-Process notepad | Where-Object { -not $_.Responding } | ForEach-Object { $_.Kill() } -WhatIf
```

### 6. Группировка и подсчет: `Group-Object` и `Measure-Object`

Эти командлеты позволяют агрегировать данные.

*   `Group-Object`: Группирует объекты по значению свойства.
*   `Measure-Object`: Считает количество объектов, находит сумму, среднее и т.д.

```powershell
# Сгруппировать все процессы по компании-производителю и отсортировать по количеству
Get-Process | Where-Object Company | Group-Object Company | Sort-Object Count -Descending

# Посчитать, сколько всего запущено процессов
Get-Process | Measure-Object # Свойство Count в результате
```

---

## От консоли к автоматизации: Сохранение результатов и создание скриптов

После того как вы построили идеальную команду в конвейере, результат нужно сохранить или превратить в скрипт для многократного использования.

### Сохранение результатов

| Метод                               | Команда                                                                                                        | Описание                                                                            |
| ----------------------------------- | -------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------- |
| **Простой текст**                   | `Get-Process > C:\Temp\procs.txt`                                                                              | Перенаправляет текстовое представление в файл (перезаписывает). Используйте `>>` для добавления. |
| **Текст с контролем**               | `Get-Process \| Out-File C:\Temp\procs.txt -Encoding utf8`                                                      | `Out-File` дает больше контроля, например, над кодировкой.                          |
| **CSV (для Excel)**                 | `Get-Process \| Export-Csv C:\Temp\procs.csv -NoTypeInformation`                                                | Экспортирует объекты в CSV. `-NoTypeInformation` убирает служебную первую строку.     |
| **JSON (для API, веб)**             | `Get-Service \| ConvertTo-Json \| Out-File C:\Temp\services.json`                                               | Преобразует объекты в формат JSON.                                                  |
| **HTML-отчет**                      | `Get-Process \| ConvertTo-Html -Title "Отчет" \| Out-File C:\Temp\report.html`                                  | Создает готовый HTML-файл из объектов.                                              |
| **XML (родной формат PowerShell)** | `Get-Process \| Export-Clixml C:\Temp\procs.xml`                                                              | Сохраняет объекты со всеми типами данных. Их можно идеально восстановить через `Import-Clixml`. |

### Пример: создание красивого HTML-отчета

```powershell
Get-Process |
  Sort-Object CPU -Descending |
  Select-Object -First 10 Name, Id, @{Name="Memory(MB)";Expression={[Math]::Round($_.WorkingSet/1MB,2)}} |
  ConvertTo-Html -Title "System Processes Report" -PreContent "<h1>Топ-10 процессов по CPU</h1>" |
  Out-File "C:\Temp\processes_report.html"

# Открыть отчет в браузере по умолчанию
Invoke-Item "C:\Temp\processes_report.html"
```

### Создание вашего первого скрипта (`.ps1`)

Скрипт — это просто текстовый файл с набором команд PowerShell и расширением `.ps1`.

#### Политика выполнения скриптов
По умолчанию в Windows запрещен запуск локальных скриптов. Чтобы это исправить для текущего пользователя, выполните один раз в PowerShell от имени администратора:
```powershell
Set-ExecutionPolicy RemoteSigned -Scope CurrentUser
```

#### Пример продвинутого скрипта: Мониторинг системы

Создайте файл `system_monitor.ps1` и вставьте в него этот код. Он собирает информацию о системе и генерирует комплексный HTML-отчет.

```powershell
# system_monitor.ps1
#requires -Version 5.1

<#
.SYNOPSIS
    Скрипт для создания отчета о состоянии системы.
.DESCRIPTION
    Собирает информацию о процессах, службах и дисковом пространстве и генерирует отчеты в CSV и HTML.
.PARAMETER OutputPath
    Путь для сохранения отчетов. По умолчанию 'C:\Temp'.
.EXAMPLE
    .\system_monitor.ps1 -OutputPath "C:\Reports"
#>

param(
    [Parameter(Mandatory=$false)]
    [string]$OutputPath = "C:\Temp"
)

# --- Блок 1: Подготовка ---
Write-Host "Подготовка к созданию отчета..." -ForegroundColor Cyan

# Проверка и создание папки для отчетов
if (!(Test-Path $OutputPath)) {
    New-Item -ItemType Directory -Path $OutputPath -Force | Out-Null
}

# --- Блок 2: Сбор данных ---
Write-Host "Собираем информацию о процессах..." -ForegroundColor Green
$processes = Get-Process | Select-Object Name, Id, CPU, @{Name="MemoryMB";Expression={[Math]::Round($_.WorkingSet/1MB,2)}} | Sort-Object CPU -Descending

Write-Host "Собираем информацию о службах..." -ForegroundColor Green
$services = Get-Service | Group-Object Status | Select-Object Name, Count

Write-Host "Собираем информацию о дисках..." -ForegroundColor Green
$disks = Get-CimInstance -ClassName Win32_LogicalDisk | Where-Object { $_.DriveType -eq 3 } |
    Select-Object DeviceID,
        @{Name="SizeGB";Expression={[Math]::Round($_.Size/1GB,2)}},
        @{Name="FreeSpaceGB";Expression={[Math]::Round($_.FreeSpace/1GB,2)}},
        @{Name="PercentFree";Expression={[Math]::Round(($_.FreeSpace/$_.Size)*100,2)}}

# --- Блок 3: Создание HTML отчета ---
Write-Host "Формируем HTML-отчет..." -ForegroundColor Yellow

$timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm"
$reportPath = Join-Path $OutputPath "system_report_$timestamp.html"

$htmlHeader = @"
<!DOCTYPE html>
<html>
<head>
    <title>Отчет о состоянии системы - $(Get-Date)</title>
    <style>
        body { font-family: 'Segoe UI', sans-serif; margin: 20px; background-color: #f4f4f4; color: #333; }
        table { border-collapse: collapse; width: 80%; margin: 20px auto; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        th, td { border: 1px solid #ddd; padding: 12px; text-align: left; }
        th { background-color: #0078D4; color: white; }
        tr:nth-child(even) { background-color: #f2f2f2; }
        h1, h2 { color: #005A9E; text-align: center; }
        .container { max-width: 1200px; margin: auto; background: white; padding: 20px; border-radius: 8px; }
    </style>
</head>
<body>
<div class="container">
    <h1>Отчет о состоянии системы</h1>
    <p style="text-align:center;">Создан: $(Get-Date)</p>
"@

# Преобразуем каждую часть данных в HTML-фрагмент
$processesHtml = $processes | Select-Object -First 10 | ConvertTo-Html -As Table -Fragment -PreContent "<h2>Топ-10 процессов по использованию CPU</h2>"
$servicesHtml = $services | ConvertTo-Html -As Table -Fragment -PreContent "<h2>Статистика служб</h2>"
$disksHtml = $disks | ConvertTo-Html -As Table -Fragment -PreContent "<h2>Использование дискового пространства</h2>"

$htmlFooter = @"
</div>
</body>
</html>
"@

# Собираем все части вместе
$htmlContent = $htmlHeader + $processesHtml + $servicesHtml + $disksHtml + $htmlFooter
$htmlContent | Out-File $reportPath -Encoding UTF8

Write-Host "Отчет успешно сохранен: $reportPath" -ForegroundColor Magenta
# Invoke-Item $reportPath # Раскомментируйте, чтобы автоматически открывать отчет
```

### Заключение



1.  **Помните о потоке**: `Get` → `Where` → `Sort` → `Select` → `Export`.
2.  **Исследуйте**: `Get-Member` — ваш лучший друг.
3.  **Используйте `$_`**: Это ваш ключ к текущему объекту в конвейере.
4.  **Безопасность прежде всего**: Применяйте `-WhatIf` для команд, вносящих изменения.
5.  **Автоматизируйте**: Сохраняйте удачные команды в `.ps1`-скрипты.

**В следующей части мы применим эти знания для навигации и управления файловой системой, исследуя объекты `System.IO.DirectoryInfo` и `System.IO.FileInfo`.**