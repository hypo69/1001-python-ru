# Часть 2: Конвейер (Pipeline), работа с объектами и создание файла скриптов.

В первой главе мы установили ключевой принцип: PowerShell работает с объектами, а не с текстом. 
Теперь давайте разберем главный механизм, который делает работу PowerShell элегантной и мощной — **конвейер (pipeline)**. 
Освоив конвейер, вы научитесь строить сложные команды из простых блоков, как из конструктора LEGO. 
Это концепция, заимствованная из UNIX, но кардинально переосмысленная Microsoft.

## Что такое конвейер (`|`)?

Символ `|` (вертикальная черта) — это оператор конвейера. Его задача — взять результат (вывод) команды, стоящей слева от него, и передать его на вход команде, стоящей справа.

### Классический UNIX-конвейер

В `sh` или `bash` по конвейеру передается **поток байтов**, который обычно интерпретируется как **текст**. Например:

```bash
# Найти все процессы, запущенные пользователем 'root', и посчитать их количество
ps -ef | grep 'root' | wc -l
```

Здесь `ps` выводит текст, `grep` фильтрует этот текст по строке 'root', а `wc -l` считает количество оставшихся строк. Каждая утилита ничего не знает о "процессах", она работает только со строками.

### PowerShell: Конвейер объектов

PowerShell по конвейеру передаются **полноценные объекты .NET**. Следующая команда в цепочке получает не просто строки, а структурированные сущности со всеми их свойствами и методами.

Давайте посмотрим на аналогичную задачу в PowerShell:

```powershell
Get-Process | Where-Object { $_.UserName -like '*SYSTEM*' } | Measure-Object
```

Здесь `Get-Process` возвращает **массив объектов** `System.Diagnostics.Process`. `Where-Object` получает **каждый объект целиком** и проверяет его свойство `UserName`. `Measure-Object` получает отфильтрованные объекты и считает их количество. Никакого "парсинга" текста не происходит на всем протяжении цепочки.

## Командлет `Get-Process`: Получаем поток объектов

Давайте начнем с простого и наглядного командлета `Get-Process`. Без параметров он возвращает коллекцию объектов, каждый из которых представляет один запущенный на вашем компьютере процесс.

Введите в консоль:

```powershell
Get-Process
```

Вы увидите таблицу с информацией о процессах: количество "хэндлов" (Handles), использование памяти (NPM, PM, WS) и процессора (CPU), ID процесса и его имя (ProcessName).

**Важный нюанс:** То, что вы видите в консоли — это не сам объект, а лишь его **форматированное представление**. PowerShell имеет сложную систему форматирования вывода. По умолчанию, для объектов типа `System.Diagnostics.Process` он применяет специальный файл форматирования (`.format.ps1xml`), который определяет, какие свойства и в каком виде показать в виде таблицы.

Чтобы увидеть "сырые" свойства объекта без форматирования, можно использовать `Format-List`:

```powershell
Get-Process -Name "powershell" | Format-List *
```

Эта команда покажет **все** свойства объекта процесса PowerShell, а не только те, что отображаются в таблице по умолчанию.

## Командлет `Get-Member`: Рентгенаппарат для объектов

Как нам узнать, из чего состоят эти объекты? Какая еще информация в них скрыта, помимо той, что мы видим? Для этого существует диагностический командлет `Get-Member` (псевдоним `gm`). Он не меняет объекты, а лишь анализирует их структуру (этот процесс называется **рефлексия**) и показывает нам все доступные "кирпичики": свойства, методы и события.

### Практика: Соединяем команды в конвейер

Теперь давайте соединим наши две команды. Мы возьмем объекты, которые возвращает `Get-Process`, и передадим их **по одному** на анализ в `Get-Member`.

```powershell
Get-Process | Get-Member
```

Результат будет выглядеть примерно так:

```
   TypeName: System.Diagnostics.Process

Name                       MemberType     Definition
----                       ----------     ----------
Kill                       Method         void Kill(), void Kill(bool entireProcessTree)
Refresh                    Method         void Refresh()
Start                      Method         static System.Diagnostics.Process Start(string fileName)
WaitForExit                Method         bool WaitForExit(int milliseconds), void WaitForExit()
...
Company                    Property       string Company {get;}
CPU                        Property       double CPU {get;}
HasExited                  Property       bool HasExited {get;}
Handles                    Property       int Handles {get;}
Id                         Property       int Id {get;}
MainModule                 Property       System.Diagnostics.ProcessModule MainModule {get;}
ProcessName                Property       string ProcessName {get;}
Responding                 Property       bool Responding {get;}
StartTime                  Property       datetime StartTime {get;}
...
```

**Разберем вывод подробнее:**

- **TypeName:** PowerShell сообщает нам, с каким типом объектов мы работаем — `System.Diagnostics.Process`. Это класс из библиотеки .NET. Все процессы, возвращаемые `Get-Process`, будут этого типа.
- **Name:** Имя "члена" объекта (свойства или метода).
- **MemberType:**
  - **Method:** Действие, которое можно совершить с объектом. Например, у каждого процесса есть метод `Kill()`, который позволяет его принудительно завершить. Методы всегда имеют скобки `()`, в которых могут быть параметры. Метод `Start` является `static`, то есть он принадлежит классу `Process` в целом, а не конкретному экземпляру.
  - **Property:** Свойство или характеристика объекта. Например, `Id` (уникальный идентификатор процесса), `ProcessName` (имя процесса), `StartTime` (время запуска) или `Responding` (отвечает ли приложение на запросы системы). Это "переменные" внутри объекта.
  - **ScriptProperty/AliasProperty:** Это свойства, добавленные самим PowerShell для удобства. Например, свойство `CPU` на самом деле является `ScriptProperty` — PowerShell "на лету" вычисляет его значение при обращении.

`Get-Member` — это ваш самый надежный инструмент для исследования PowerShell. Если вы не знаете, как получить ту или иную информацию из объекта, пропустите его через `Get-Member`, и вы увидите все его скрытые возможности.

## Неочевидные возможности конвейера

### 1. Вызов методов прямо в конвейере

Знаете ли вы, что в конвейере можно вызывать методы объектов напрямую?

```powershell
# Остановить все заблокированные процессы блокнота
Get-Process notepad | Where-Object { -not $_.Responding } | ForEach-Object { $_.Kill() }

# Обновить информацию о процессах и показать их память
Get-Process | ForEach-Object { $_.Refresh(); $_ } | Select-Object Name, WorkingSet64
```

### 2. Создание объектов "на лету" в конвейере

```powershell
# Создать список чисел и обработать их как объекты
1..10 | ForEach-Object { 
    [PSCustomObject]@{
        Number = $_
        Square = $_ * $_
        IsEven = ($_ % 2) -eq 0
    }
} | Where-Object IsEven | Format-Table
```

### 3. Работа с вложенными свойствами

```powershell
# Получить детальную информацию о модулях процессов
Get-Process powershell | Select-Object -ExpandProperty Modules | 
    Where-Object { $_.ModuleName -like "*.dll" } | 
    Group-Object Company | 
    Sort-Object Count -Descending
```

### 4. Использование конвейера для файловых операций

```powershell
# Найти все большие файлы и переместить их в архивную папку
Get-ChildItem C:\Temp -Recurse -File | 
    Where-Object { $_.Length -gt 100MB } | 
    Move-Item -Destination "C:\Archive" -WhatIf
```

### 5. Конвейер для работы с сетевыми данными

```powershell
# Проверить доступность нескольких серверов и вывести отчет
"google.com", "microsoft.com", "github.com" | 
    ForEach-Object { Test-NetConnection $_ -Port 80 -InformationLevel Quiet } |
    Measure-Object -Sum
```

## Продвинутые техники работы с конвейером

### Группировка и сортировка

```powershell
# Группировка процессов по компании-разработчику
Get-Process | Where-Object Company | 
    Group-Object Company | 
    Sort-Object Count -Descending | 
    Select-Object Name, Count
```

### Агрегация данных

```powershell
# Подсчет общего использования памяти по типам процессов
Get-Process | Group-Object ProcessName | ForEach-Object {
    [PSCustomObject]@{
        ProcessName = $_.Name
        Count = $_.Count
        TotalMemoryMB = ($_.Group | Measure-Object WorkingSet -Sum).Sum / 1MB
    }
} | Sort-Object TotalMemoryMB -Descending | Format-Table -AutoSize
```

### Работа с несколькими типами объектов

```powershell
# Получить информацию о файлах и папках с разной обработкой
Get-ChildItem | ForEach-Object {
    if ($_.PSIsContainer) {
        [PSCustomObject]@{
            Name = $_.Name
            Type = "Folder"
            ItemCount = (Get-ChildItem $_.FullName).Count
            Size = "N/A"
        }
    } else {
        [PSCustomObject]@{
            Name = $_.Name
            Type = "File"
            ItemCount = "N/A"
            Size = "{0:N2} KB" -f ($_.Length / 1KB)
        }
    }
}
```

## Важные особенности конвейера

### Потоковая обработка

Конвейер PowerShell работает **потоково** — это означает, что объекты передаются по одному, а не все сразу. Это позволяет эффективно обрабатывать большие объемы данных:

```powershell
# Эта команда начнет выводить результаты сразу, не дожидаясь получения всех файлов
Get-ChildItem C:\ -Recurse | Where-Object { $_.Length -gt 1GB }
```

### Остановка конвейера

Некоторые командлеты могут остановить конвейер досрочно:

```powershell
# Select-Object -First останавливает конвейер после получения нужного количества объектов
Get-Process | Sort-Object CPU -Descending | Select-Object -First 5
```

### Переменная `$_` (текущий объект)

В конвейере переменная `$_` всегда ссылается на текущий обрабатываемый объект:

```powershell
Get-Process | Where-Object { $_.ProcessName -eq "notepad" } | ForEach-Object { 
    Write-Host "Process $($_.ProcessName) uses $($_.WorkingSet / 1MB) MB of memory"
}
```

## Отладка конвейера

### Использование `Tee-Object` для промежуточного вывода

```powershell
# Сохранить промежуточный результат для отладки
Get-Process | 
    Tee-Object -Variable AllProcesses | 
    Where-Object { $_.CPU -gt 10 } | 
    Tee-Object -Variable HighCpuProcesses |
    Sort-Object CPU -Descending
```

### Пошаговая отладка конвейера

```powershell
# Добавляем Write-Host для отслеживания каждого шага
Get-Process | ForEach-Object { 
    Write-Host "Processing: $($_.ProcessName)" -ForegroundColor Yellow
    $_
} | Where-Object { $_.WorkingSet -gt 50MB } | ForEach-Object {
    Write-Host "Found large process: $($_.ProcessName)" -ForegroundColor Green
    $_
}
```

## Практические примеры

### Анализ использования дискового пространства

```powershell
Get-ChildItem C:\ -Directory | ForEach-Object {
    $size = (Get-ChildItem $_.FullName -Recurse -ErrorAction SilentlyContinue | 
             Measure-Object -Property Length -Sum).Sum
    [PSCustomObject]@{
        Folder = $_.Name
        SizeGB = [Math]::Round($size / 1GB, 2)
    }
} | Sort-Object SizeGB -Descending | Format-Table
```

### Мониторинг производительности

```powershell
# Создать отчет о топ-процессах по использованию ресурсов
Get-Process | Where-Object { $_.CPU -gt 0 } | 
    Sort-Object CPU -Descending | 
    Select-Object -First 10 ProcessName, CPU, 
        @{Name="MemoryMB";Expression={[Math]::Round($_.WorkingSet/1MB,2)}} |
    Format-Table -AutoSize
```

**Пример использования полученных знаний:**

Теперь, зная о свойстве `StartTime`, мы можем легко найти все процессы, запущенные за последний час:

```powershell
$oneHourAgo = (Get-Date).AddHours(-1)
Get-Process | Where-Object { $_.StartTime -gt $oneHourAgo }
```

## Сохранение результатов в файлы и создание скриптов

После того как вы освоили работу с конвейером, естественным желанием становится сохранение полученных результатов для дальнейшего использования или создание скриптов для автоматизации рутинных задач.

### Сохранение результатов в файлы

PowerShell предлагает несколько способов сохранения данных:

#### 1. Перенаправление вывода с помощью `>`

```powershell
# Сохранить список процессов в текстовый файл
Get-Process > C:\Temp\processes.txt

# Добавить данные к существующему файлу
Get-Service >> C:\Temp\system_info.txt
```

#### 2. Использование `Out-File` для большего контроля

```powershell
# Сохранить с указанием кодировки
Get-Process | Out-File -FilePath "C:\Temp\processes.txt" -Encoding UTF8

# Сохранить с определенной шириной строки
Get-Process | Format-Table | Out-File -FilePath "C:\Temp\processes_table.txt" -Width 200
```

#### 3. Экспорт в структурированные форматы

```powershell
# Экспорт в CSV для работы в Excel
Get-Process | Select-Object Name, CPU, WorkingSet | Export-Csv -Path "C:\Temp\processes.csv" -NoTypeInformation

# Экспорт в JSON для веб-приложений
Get-Service | ConvertTo-Json | Out-File "C:\Temp\services.json"

# Экспорт в XML
Get-EventLog -LogName System -Newest 100 | Export-Clixml "C:\Temp\system_events.xml"
```

#### 4. Сохранение HTML-отчетов

```powershell
# Создание красивого HTML-отчета
Get-Process | Select-Object Name, CPU, 
    @{Name="Memory(MB)";Expression={[Math]::Round($_.WorkingSet/1MB,2)}} | 
    ConvertTo-Html -Title "System Processes Report" -PreContent "<h1>Процессы системы</h1>" |
    Out-File "C:\Temp\processes_report.html"
```

### Создание и сохранение скриптов

#### Базовая структура скрипта PowerShell

Создайте файл с расширением `.ps1` и добавьте следующую структуру:

```powershell
# system_monitor.ps1
#Requires -Version 5.1

<#
.SYNOPSIS
    Скрипт мониторинга системы
.DESCRIPTION
    Собирает информацию о процессах, службах и дисковом пространстве
.PARAMETER OutputPath
    Путь для сохранения отчетов
.EXAMPLE
    .\system_monitor.ps1 -OutputPath "C:\Reports"
#>

param(
    [Parameter(Mandatory=$false)]
    [string]$OutputPath = "C:\Temp"
)

# Проверка существования папки
if (!(Test-Path $OutputPath)) {
    New-Item -ItemType Directory -Path $OutputPath -Force
}

# Получение информации о процессах
Write-Host "Собираем информацию о процессах..." -ForegroundColor Green
$processes = Get-Process | Where-Object { $_.CPU -gt 0 } | 
    Select-Object Name, CPU, 
        @{Name="MemoryMB";Expression={[Math]::Round($_.WorkingSet/1MB,2)}} |
    Sort-Object CPU -Descending

# Получение информации о службах
Write-Host "Собираем информацию о службах..." -ForegroundColor Green
$services = Get-Service | Group-Object Status | ForEach-Object {
    [PSCustomObject]@{
        Status = $_.Name
        Count = $_.Count
    }
}

# Получение информации о дисках
Write-Host "Собираем информацию о дисках..." -ForegroundColor Green
$disks = Get-CimInstance -ClassName Win32_LogicalDisk | Where-Object { $_.DriveType -eq 3 } |
    Select-Object DeviceID, 
        @{Name="SizeGB";Expression={[Math]::Round($_.Size/1GB,2)}},
        @{Name="FreeSpaceGB";Expression={[Math]::Round($_.FreeSpace/1GB,2)}},
        @{Name="PercentFree";Expression={[Math]::Round(($_.FreeSpace/$_.Size)*100,2)}}

# Сохранение результатов
$timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm"

$processes | Export-Csv -Path "$OutputPath\processes_$timestamp.csv" -NoTypeInformation
$services | Export-Csv -Path "$OutputPath\services_$timestamp.csv" -NoTypeInformation
$disks | Export-Csv -Path "$OutputPath\disks_$timestamp.csv" -NoTypeInformation

# Создание сводного HTML-отчета
$html = @"
<!DOCTYPE html>
<html>
<head>
    <title>Отчет о состоянии системы - $(Get-Date)</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        table { border-collapse: collapse; width: 100%; margin: 20px 0; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #4CAF50; color: white; }
        h2 { color: #4CAF50; }
    </style>
</head>
<body>
    <h1>Отчет о состоянии системы</h1>
    <p>Создан: $(Get-Date)</p>
    
    <h2>Топ-10 процессов по использованию CPU</h2>
    $($processes | Select-Object -First 10 | ConvertTo-Html -Fragment)
    
    <h2>Статистика служб</h2>
    $($services | ConvertTo-Html -Fragment)
    
    <h2>Использование дискового пространства</h2>
    $($disks | ConvertTo-Html -Fragment)
</body>
</html>
"@

$html | Out-File "$OutputPath\system_report_$timestamp.html" -Encoding UTF8

Write-Host "Отчеты сохранены в: $OutputPath" -ForegroundColor Yellow
Write-Host "HTML-отчет: system_report_$timestamp.html" -ForegroundColor Yellow
```

#### Полезные функции для скриптов

```powershell
# Функция для логирования
function Write-Log {
    param(
        [string]$Message,
        [string]$Level = "INFO"
    )
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $logMessage = "[$timestamp] [$Level] $Message"
    Write-Host $logMessage
    $logMessage | Out-File -FilePath "C:\Temp\script.log" -Append
}

# Функция для отправки email-отчетов
function Send-EmailReport {
    param(
        [string]$ReportPath,
        [string]$SmtpServer = "smtp.company.com",
        [string]$To = "admin@company.com"
    )
    
    try {
        Send-MailMessage -SmtpServer $SmtpServer -To $To -From "reports@company.com" `
            -Subject "Отчет о системе - $(Get-Date -Format 'dd.MM.yyyy')" `
            -Body "Во вложении отчет о состоянии системы." `
            -Attachments $ReportPath
        Write-Log "Email-отчет отправлен успешно"
    }
    catch {
        Write-Log "Ошибка отправки email: $_" -Level "ERROR"
    }
}
```

### Автоматизация выполнения скриптов

#### 1. Создание задачи в планировщике Windows

```powershell
# Создание задачи для ежедневного выполнения в 9:00
$action = New-ScheduledTaskAction -Execute 'PowerShell.exe' -Argument '-File "C:\Scripts\system_monitor.ps1"'
$trigger = New-ScheduledTaskTrigger -Daily -At 9am
$settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries

Register-ScheduledTask -TaskName "SystemMonitoring" -Action $action -Trigger $trigger -Settings $settings -Description "Ежедневный мониторинг системы"
```

#### 2. Использование конфигурационных файлов

Создайте файл `config.json`:
```json
{
    "OutputPath": "C:\\Reports",
    "EmailSettings": {
        "SmtpServer": "smtp.company.com",
        "To": "admin@company.com",
        "From": "reports@company.com"
    },
    "ProcessThreshold": 10,
    "DiskThreshold": 80
}
```

И используйте его в скрипте:
```powershell
# Загрузка конфигурации
$config = Get-Content "config.json" | ConvertFrom-Json

# Использование настроек
$outputPath = $config.OutputPath
$processThreshold = $config.ProcessThreshold
```

### Рекомендации по созданию скриптов

1. **Всегда добавляйте комментарии** и документацию
2. **Используйте параметры** для гибкости
3. **Обрабатывайте ошибки** с помощью `try-catch`
4. **Логируйте важные события**
5. **Тестируйте скрипты** в безопасной среде
6. **Используйте `-WhatIf`** для операций изменения данных
7. **Создавайте резервные копии** перед изменениями

### Пример универсального скрипта с конвейером

```powershell
# universal_processor.ps1
param(
    [Parameter(Mandatory=$true)]
    [string]$InputType,
    
    [Parameter(Mandatory=$false)]
    [string]$Filter = "*",
    
    [Parameter(Mandatory=$false)]
    [string]$OutputFormat = "CSV"
)

$data = switch ($InputType) {
    "Processes" { Get-Process | Where-Object Name -like $Filter }
    "Services" { Get-Service | Where-Object Name -like $Filter }
    "Files" { Get-ChildItem -Path $Filter -Recurse }
    default { throw "Неподдерживаемый тип: $InputType" }
}

$timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
$filename = "$InputType`_$timestamp"

switch ($OutputFormat.ToUpper()) {
    "CSV" { $data | Export-Csv "$filename.csv" -NoTypeInformation }
    "JSON" { $data | ConvertTo-Json | Out-File "$filename.json" }
    "HTML" { $data | ConvertTo-Html | Out-File "$filename.html" }
    "XML" { $data | Export-Clixml "$filename.xml" }
}

Write-Host "Данные сохранены в файл: $filename.$($OutputFormat.ToLower())"
```

Использование:
```powershell
.\universal_processor.ps1 -InputType "Processes" -Filter "chrome*" -OutputFormat "JSON"
.\universal_processor.ps1 -InputType "Files" -Filter "C:\Temp\*.log" -OutputFormat "CSV"
```

## Заключение

Конвейер — это сердце PowerShell. Понимание того, как объекты "текут" по конвейеру и как каждый командлет их обрабатывает, откроет перед вами безграничные возможности автоматизации. Помните:

1. **Каждый объект обрабатывается индивидуально**
2. **Используйте `Get-Member` для исследования объектов**
3. **Переменная `$_` — ваш ключ к текущему объекту**
4. **Конвейер работает потоково — эффективно для больших данных**
5. **Отладка с помощью `Tee-Object` и `Write-Host` поможет понять поток данных**
6. **Сохраняйте результаты в подходящих форматах для дальнейшего использования**
7. **Создавайте переиспользуемые скрипты для автоматизации рутинных задач**

**В следующей части мы применим эти знания для навигации и управления файловой системой, исследуя объекты `System.IO.DirectoryInfo` и `System.IO.FileInfo`.**