### **Глава 0. Что было до PowerShell**

Чтобы по-настоящему оценить революцию, которую совершил PowerShell, мы должны совершить путешествие в прошлое. Мы должны понять, в каком мире жили системные администраторы Windows, какими инструментами они пользовались, и с какими неразрешимыми проблемами сталкивались каждый день. Это история о фрагментации, текстовых мучениях и постоянном поиске обходных путей.

#### **Эпоха зарождения: MS-DOS и `COMMAND.COM` (1981)**

Все началось в 1981 году с выходом MS-DOS 1.0. Ее командным интерпретатором была оболочка `COMMAND.COM`. Для автоматизации рутинных задач использовались **пакетные файлы (`.bat`)** — простые текстовые файлы с последовательностью консольных команд. И все заверте...

> **Пример консольной команды:**
> `dir C:\DOS /s > C:\dos_files.txt`
> Эта команда рекурсивно (`/s`) просматривала содержимое папки `C:\DOS` и перенаправляла (`>`) текстовый вывод в файл `dos_files.txt`.

Что в это время было в других ОС? В мире Unix уже с 1979 года существовала **оболочка Борна (`sh`)**, которая была на световые годы впереди. Она имела переменные, циклы и, что самое главное, **конвейер (`|`)**, позволявший связывать вывод одной утилиты со входом другой. Администраторы Unix уже тогда строили элегантные однострочники, в то время как пользователи MS-DOS были ограничены простейшими скриптами, где все данные были просто текстом.

#### **Графическая эра: Windows 95, WSH и вирус "ILOVEYOU"**

С выходом Windows 95 мир стал графическим. Именно тогда, в 1995 году, появился **Диспетчер устройств (Device Manager)** — графическая утилита для управления оборудованием. Он был удобен для пользователей, но для автоматизации администраторам все еще приходилось полагаться на `.bat`-файлы.

В попытке дать более мощный инструмент, Microsoft в 1996 году представила **VBScript**, а затем, в Windows 98, среду **Windows Script Host (WSH)**. Это был прорыв, который позволил писать сложные сценарии. Но эта мощь принесла с собой и огромные проблемы:
1.  **Фрагментация:** Не было единого подхода. Для управления файлами нужно было знать `Scripting.FileSystemObject`. Для управления пользователями — погружаться в дебри **ADSI**. Для получения системной информации — изучать **WMI**. Каждая технология была отдельным миром.
2.  **Отсутствие обнаруживаемости:** Не было способа просто спросить у системы: "А что я могу сделать с этой службой?". Автодополнение или справка по объектам отсутствовали.
3.  **Уязвимости:** Скрипты `.vbs` исполнялись по умолчанию простым двойным щелчком. Это привело к катастрофе в мае 2000 года, когда почтовый червь **"ILOVEYOU"**, написанный на VBScript, нанес мировой экономике ущерб в миллиарды долларов, наглядно показав опасность мощного, но небезопасного инструмента.

#### **Инженерная мысль в действии: примеры `.bat`-файлов**

Несмотря на все ограничения, администраторы проявляли чудеса изобретательности, создавая сложные скрипты. Рассмотрим два классических примера.

**Пример 1: Резервное копирование (`backup.bat`)**
Задача: создать ежедневную резервную копию папки в директорию с текущей датой.

```bat
@echo off
REM Классический BAT-скрипт для резервного копирования

set SOURCE_DIR="C:\MyImportantData"
set BACKUP_ROOT="D:\Backups"

REM --- "Магия" для получения даты в формате ГГГГ-ММ-ДД ---
set YEAR=%date:~6,4%
set MONTH=%date:~3,2%
set DAY=%date:~0,2%
set TODAY_FOLDER=%YEAR%-%MONTH%-%DAY%
set BACKUP_DEST=%BACKUP_ROOT%\%TODAY_FOLDER%

echo Starting backup of %SOURCE_DIR% to %BACKUP_DEST%

if not exist %BACKUP_DEST% mkdir %BACKUP_DEST%

REM Используем robocopy, так как он надежнее xcopy
robocopy %SOURCE_DIR% %BACKUP_DEST% /E /LOG:%BACKUP_DEST%\_backup_log.txt

if %ERRORLEVEL% GEQ 8 (
    echo WARNING: Robocopy encountered serious errors!
) else (
    echo Robocopy finished successfully.
)

echo Backup completed.
pause
```**Разбор полетов:** Этот скрипт хрупок. "Магия" с датой сломается в любом регионе с другим форматом даты. Чтобы узнать, что произошло, нужно вручную открыть и прочитать текстовый лог-файл.

**Пример 2: Установка драйвера звуковой карты (`install_sound_driver.bat`)**
До PowerShell не было встроенной команды для установки драйверов. Администраторы использовали утилиту **`DevCon.exe`**, которая появилась вместе с Windows 2000 Driver Development Kit, но **не входила в состав ОС**. Ее нужно было скачивать отдельно.

```bat
@echo off
REM Скрипт для установки драйвера звуковой карты Realtek

REM Убедимся, что devcon.exe лежит рядом
if not exist devcon.exe (
    echo ERROR: DevCon.exe not found!
    goto :eof
)

REM Путь к INF-файлу драйвера
set INF_FILE="C:\Drivers\RealtekHD\HDX.inf"

REM Аппаратный ID. Его нужно было заранее узнать из Диспетчера Устройств
set HARDWARE_ID="HDAUDIO\FUNC_01&VEN_10EC&DEV_0282"

echo Installing driver for %HARDWARE_ID%...

devcon.exe install %INF_FILE% %HARDWARE_ID%

if %ERRORLEVEL% NEQ 0 (
    echo !!! DRIVER INSTALLATION FAILED.
) else (
    echo Driver installation completed successfully.
)

:eof
pause
```
**Разбор полетов:** Этот скрипт полностью зависит от внешнего файла `devcon.exe`. И самое главное, он требует заранее известного `HARDWARE_ID` — уникального и длинного идентификатора, который нужно было вручную копировать из Диспетчера устройств для каждой модели оборудования.

#### **Тупик автоматизации и рождение "Монады"**

К началу 2000-х годов администратор Windows находился в тупике. Он стоял перед выбором:
*   Использовать простые, но примитивные и хрупкие **`.bat`-файлы**.
*   Погружаться в сложный, фрагментированный и небезопасный мир **VBScript/WSH**.
*   Полагаться на **внешние утилиты** вроде `DevCon.exe` для базовых задач.

Именно в этот момент, в 2002 году, архитектор Microsoft **Джеффри Сноувер** представил свой знаменитый **"Monad Manifesto"**. Он предложил решение, которое должно было исправить все вышеописанные проблемы. Идея была в том, чтобы создать новую оболочку, которая оперирует не текстом, а **объектами**, построена на современной платформе **.NET Framework** и имеет единую, последовательную модель управления системой.

Этот проект, "Monad", увидел свет в 2006 году под именем, которое мы все знаем сегодня — **PowerShell**.

Так закончилась эпоха разрозненных инструментов и началась новая эра в автоматизации Windows. Теперь, зная этот контекст, мы готовы перейти к изучению самого PowerShell.

