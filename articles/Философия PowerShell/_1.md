### **Глава 0. Что было до PowerShell**

Чтобы по-настоящему оценить революцию, которую совершил PowerShell, мы должны совершить путешествие в прошлое. Мы должны понять, в каком мире жили системные администраторы Windows, какими инструментами они пользовались, и с какими неразрешимыми проблемами сталкивались каждый день. Это история о фрагментации, текстовых мучениях и постоянном поиске обходных путей.

#### **Эпоха зарождения: MS-DOS и `COMMAND.COM` (1981)**

Все началось в 1981 году с выходом MS-DOS 1.0. Ее командным интерпретатором была оболочка `COMMAND.COM`. Для автоматизации рутинных задач использовались **пакетные файлы (`.bat`)** — простые текстовые файлы с последовательностью консольных команд. И все заверте...

> **Пример консольной команды:**
> `dir C:\DOS /s > C:\dos_files.txt`
> Эта команда рекурсивно (`/s`) просматривала содержимое папки `C:\DOS` и перенаправляла (`>`) текстовый вывод в файл `dos_files.txt`.

Что в это время было в других ОС? В мире Unix уже с 1979 года существовала **оболочка Борна (`sh`)**, которая была на световые годы впереди. Она имела переменные, циклы и, что самое главное, **конвейер (`|`)**, позволявший связывать вывод одной утилиты со входом другой. Администраторы Unix уже тогда строили элегантные однострочники, в то время как пользователи MS-DOS были ограничены простейшими скриптами, где все данные были просто текстом.

#### **Графическая эра: Windows 95, WSH и вирус "ILOVEYOU"**

С выходом Windows 95 мир стал графическим. Именно тогда, в 1995 году, появился **Диспетчер устройств (Device Manager)** — графическая утилита для управления оборудованием. Он был удобен для пользователей, но для автоматизации администраторам все еще приходилось полагаться на `.bat`-файлы.

В попытке дать более мощный инструмент, Microsoft в 1996 году представила **VBScript**, а затем, в Windows 98, среду **Windows Script Host (WSH)**. Это был прорыв, который позволил писать сложные сценарии. Но эта мощь принесла с собой и огромные проблемы:
1.  **Фрагментация:** Не было единого подхода. Для управления файлами нужно было знать `Scripting.FileSystemObject`. Для управления пользователями — погружаться в дебри **ADSI**. Для получения системной информации — изучать **WMI**. Каждая технология была отдельным миром.
2.  **Отсутствие обнаруживаемости:** Не было способа просто спросить у системы: "А что я могу сделать с этой службой?". Автодополнение или справка по объектам отсутствовали.
3.  **Уязвимости:** Скрипты `.vbs` исполнялись по умолчанию простым двойным щелчком. Это привело к катастрофе в мае 2000 года, когда почтовый червь **"ILOVEYOU"**, написанный на VBScript, нанес мировой экономике ущерб в миллиарды долларов, наглядно показав опасность мощного, но небезопасного инструмента.

#### **Инженерная мысль в действии: примеры `.bat`-файлов**

Несмотря на все ограничения, администраторы проявляли чудеса изобретательности, создавая сложные скрипты. Рассмотрим два классических примера.

**Пример 1: Резервное копирование (`backup.bat`)**
Задача: создать ежедневную резервную копию папки в директорию с текущей датой.

```bat
@echo off
REM Классический BAT-скрипт для резервного копирования

set SOURCE_DIR="C:\MyImportantData"
set BACKUP_ROOT="D:\Backups"

REM --- "Магия" для получения даты в формате ГГГГ-ММ-ДД ---
set YEAR=%date:~6,4%
set MONTH=%date:~3,2%
set DAY=%date:~0,2%
set TODAY_FOLDER=%YEAR%-%MONTH%-%DAY%
set BACKUP_DEST=%BACKUP_ROOT%\%TODAY_FOLDER%

echo Starting backup of %SOURCE_DIR% to %BACKUP_DEST%

if not exist %BACKUP_DEST% mkdir %BACKUP_DEST%

REM Используем robocopy, так как он надежнее xcopy
robocopy %SOURCE_DIR% %BACKUP_DEST% /E /LOG:%BACKUP_DEST%\_backup_log.txt

if %ERRORLEVEL% GEQ 8 (
    echo WARNING: Robocopy encountered serious errors!
) else (
    echo Robocopy finished successfully.
)

echo Backup completed.
pause
```**Разбор полетов:** Этот скрипт хрупок. "Магия" с датой сломается в любом регионе с другим форматом даты. Чтобы узнать, что произошло, нужно вручную открыть и прочитать текстовый лог-файл.

**Пример 2: Установка драйвера звуковой карты (`install_sound_driver.bat`)**
До PowerShell не было встроенной команды для установки драйверов. Администраторы использовали утилиту **`DevCon.exe`**, которая появилась вместе с Windows 2000 Driver Development Kit, но **не входила в состав ОС**. Ее нужно было скачивать отдельно.

```bat
@echo off
REM Скрипт для установки драйвера звуковой карты Realtek

REM Убедимся, что devcon.exe лежит рядом
if not exist devcon.exe (
    echo ERROR: DevCon.exe not found!
    goto :eof
)

REM Путь к INF-файлу драйвера
set INF_FILE="C:\Drivers\RealtekHD\HDX.inf"

REM Аппаратный ID. Его нужно было заранее узнать из Диспетчера Устройств
set HARDWARE_ID="HDAUDIO\FUNC_01&VEN_10EC&DEV_0282"

echo Installing driver for %HARDWARE_ID%...

devcon.exe install %INF_FILE% %HARDWARE_ID%

if %ERRORLEVEL% NEQ 0 (
    echo !!! DRIVER INSTALLATION FAILED.
) else (
    echo Driver installation completed successfully.
)

:eof
pause
```
**Разбор полетов:** Этот скрипт полностью зависит от внешнего файла `devcon.exe`. И самое главное, он требует заранее известного `HARDWARE_ID` — уникального и длинного идентификатора, который нужно было вручную копировать из Диспетчера устройств для каждой модели оборудования.

#### **Тупик автоматизации и рождение "Монады"**

К началу 2000-х годов администратор Windows находился в тупике. Он стоял перед выбором:
*   Использовать простые, но примитивные и хрупкие **`.bat`-файлы**.
*   Погружаться в сложный, фрагментированный и небезопасный мир **VBScript/WSH**.
*   Полагаться на **внешние утилиты** вроде `DevCon.exe` для базовых задач.

Именно в этот момент, в 2002 году, архитектор Microsoft **Джеффри Сноувер** представил свой знаменитый **"Monad Manifesto"**. Он предложил решение, которое должно было исправить все вышеописанные проблемы. Идея была в том, чтобы создать новую оболочку, которая оперирует не текстом, а **объектами**, построена на современной платформе **.NET Framework** и имеет единую, последовательную модель управления системой.

Этот проект, "Monad", увидел свет в 2006 году под именем, которое мы все знаем сегодня — **PowerShell**.

Так закончилась эпоха разрозненных инструментов и началась новая эра в автоматизации Windows. Теперь, зная этот контекст, мы готовы перейти к изучению самого PowerShell.



---



Отличное замечание! Добавление исторического контекста и демонстрация "боли", которую решал PowerShell, сделает введение гораздо более убедительным. Давайте перепишем первую главу, включив в нее этот важный аспект.

---

### **Часть 1: Введение в PowerShell. Философия и первая команда.**

Добро пожаловать в мир PowerShell! В этой первой главе мы заложим фундамент вашего понимания этого мощного инструмента. Вы узнаете, почему PowerShell — это гораздо больше, чем просто черное окно командной строки, и напишете свою первую, и самую важную, команду.

#### **Что такое PowerShell и зачем он нужен?**

Представьте, что вам нужно выполнить одну и ту же задачу на ста компьютерах. Например, узнать, установлена ли на них определенная программа. Делать это вручную — долго и утомительно. PowerShell был создан именно для таких ситуаций.

**PowerShell** — это современная среда автоматизации от Microsoft, которая состоит из двух ключевых компонентов:

1.  **Оболочка командной строки:** Интерактивная среда, где вы можете вводить команды и мгновенно получать результат.
2.  **Язык сценариев (скриптов):** Позволяет записывать последовательности команд в файлы (с расширением `.ps1`) для их многократного выполнения.

История PowerShell началась с внутреннего проекта Microsoft под кодовым названием **"Monad"** в начале 2000-х. Но чтобы по-настоящему оценить его революционность, давайте на мгновение вернемся в прошлое.

#### **Мир до PowerShell: Ограничения CMD и VBScript**

До появления PowerShell арсенал системного администратора Windows был довольно скудным и фрагментированным.

**1. Наследие MS-DOS: `command.com` и `cmd.exe`**

В основе всего лежала командная строка, унаследованная от MS-DOS. Изначально это был файл `command.com`, который содержал в себе небольшой набор **внутренних команд** (`dir`, `copy`, `del` и т.д.). Все остальное были **внешние команды** — отдельные исполняемые файлы (`.exe` или `.com`).

С появлением Windows NT на смену пришел `cmd.exe`, который был более современным, но унаследовал главную проблему своего предка: **он работал исключительно с текстом.**

Когда вы выполняли команду `dir`, вы получали на экране текстовое представление списка файлов. Это удобно для человека, но ужасно для автоматизации. Как из строки `24.07.2025 21:15 1 428 my_script.js` программно получить только размер файла? Приходилось писать сложные скрипты для "парсинга" — разбора этого текста, что было ненадежно и громоздко.

**2. Разрозненные инструменты и "клей" из VBScript**

Для более сложных задач приходилось использовать целый зоопарк утилит:

*   **WMI (Windows Management Instrumentation):** Мощный интерфейс для получения информации о системе, но работать с ним из `cmd.exe` было почти невозможно.
*   **Пакетные файлы (.bat):** Язык `.bat`-скриптов был примитивен. Сложная логика с циклами и условиями превращалась в запутанный код с использованием `GOTO`.
*   **VBScript:** На долгие годы он стал основным "клеем" для автоматизации. С его помощью можно было работать и с WMI, и с файловой системой. Но и у него были недостатки: громоздкий синтаксис, необходимость работать со сложными COM-объектами и отсутствие удобной интерактивной оболочки.

В итоге, для решения одной задачи администратору часто приходилось комбинировать несколько технологий, что делало процесс сложным и неэффективным.

#### **Революция PowerShell: Объекты вместо текста**

PowerShell решает эту проблему кардинально. Это **самая главная идея**, которую нужно понять.

PowerShell работает с **объектами**. Когда вы выполняете команду, она возвращает вам не просто текст, а структурированный объект (или коллекцию объектов), у которого есть четко определенные **свойства** (Properties) и **методы** (Methods).

Давайте вернемся к нашему примеру. Откройте PowerShell и введите команду `Get-ChildItem` (это современный аналог `dir`). Внешне результат может быть похож, но на самом деле PowerShell вернул вам массив объектов. И вы можете легко обратиться к их свойствам. Например, чтобы получить только имена файлов и папок и их размеры:

```powershell
Get-ChildItem | Select-Object Name, Length
```

Никакого парсинга текста! Вы просто говорите: "Возьми объекты, которые вернула команда, и для каждого из них покажи мне свойства 'Name' и 'Length'". Эта простота и мощь работы с объектами делает PowerShell невероятно эффективным инструментом.

#### **Синтаксис Глагол-Существительное: Предсказуемость и простота**

Чтобы сделать команды понятными и легко запоминающимися, в PowerShell используется строгий формат именования: `Глагол-Существительное`.

*   **Глагол** описывает действие (Что делаем?): `Get` (получить), `Set` (установить), `New` (создать), `Remove` (удалить), `Start` (запустить).
*   **Существительное** описывает объект, над которым выполняется действие (Над чем делаем?): `Process` (процесс), `Service` (служба), `Item` (файл/папка).

Благодаря этому, даже не зная точной команды, вы можете легко ее угадать. Хотите получить список служб? Скорее всего, это `Get-Service`. Хотите остановить процесс? Вероятно, `Stop-Process`.

#### **Ваш первый командлет: Get-Help. Учимся учиться.**

Самый полезный инструмент в арсенале любого специалиста по PowerShell — это встроенная система помощи. Не нужно запоминать все команды и их параметры, достаточно знать, как быстро найти нужную информацию.

Командлет `Get-Help` — ваш главный помощник.

**Практика:**

1.  **Получим справку о самой справке:**
    ```powershell
    Get-Help Get-Help
    ```
2.  **Получим базовую справку о команде для работы с процессами:**
    ```powershell
    Get-Help Get-Process
    ```
3.  **Посмотрим примеры использования этой команды:**
    ```powershell
    Get-Help Get-Process -Examples
    ```
    Это невероятно полезный параметр, который часто дает готовые решения для ваших задач.
4.  **Получим максимально подробную информацию о команде:**
    ```powershell
    Get-Help Get-Process -Full
    ```

**Итог главы:**
В этой главе мы совершили путешествие от ограниченного текстового мира `cmd.exe` к мощной объектной модели PowerShell. Мы поняли, какую фундаментальную проблему он решает, познакомились с его предсказуемым синтаксисом и, самое главное, освоили командлет `Get-Help`, который станет нашим верным спутником в дальнейшем изучении.

**В следующей части мы подробно разберем концепцию конвейера (`|`) и научимся "заглядывать" внутрь объектов с помощью `Get-Member`.**