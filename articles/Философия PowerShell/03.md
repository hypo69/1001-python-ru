
### **Часть 3: Навигация и управление файловой системой.**

В предыдущей главе мы исследовали абстрактные объекты процессов. 
Теперь давайте применим наши знания о конвейере и объектах к одной из частых задач
пользователя или администратора — работе с файловой системой. 
В PowerShell эта работа построена на тех же принципах: команды возвращают объекты, которые можно передавать
по конвейеру для дальнейшей обработки. Мы увидим, как концепция "все есть объект" превращает рутинные файловые 
операции в мощный инструмент анализа и автоматизации.

#### **PowerShell Drives: Работа с файловой системой**

Прежде чем мы начнем, важно понять концепцию **PowerShell-дисков (PSDrives)**. В отличие от `cmd.exe`, где диски — это только буквы `C:`, `D:` и так далее, в PowerShell "диск" — это абстракция для доступа к любому иерархическому хранилищу данных. Эта абстракция реализуется через **провайдеров (Providers)**. Провайдер — это, по сути, адаптер, который "учит" PowerShell, как работать с определенным типом данных, используя стандартный набор команд.


Введите команду `Get-PSDrive`. Она покажет все диски, зарегистрированные в текущей сессии:

```powershell
Get-PSDrive
```

Вы увидите не только ваши физические диски (которые предоставляет провайдер `FileSystem`), но и другие "псевдо-диски":

| Name | Provider | Root | Описание |
| :--- | :--- | :--- | :--- |
| Alias | Alias | Alias:\ | Псевдонимы команд |
| C | FileSystem | C:\ | Локальный диск C |
| Cert | Certificate | Cert:\ | Хранилище сертификатов |
| Env | Environment | Env:\ | Переменные окружения |
| Function| Function | Function:\ | Загруженные функции |
| HKCU | Registry | HKEY_CURRENT_USER | Ветка реестра |
| HKLM | Registry | HKEY_LOCAL_MACHINE | Ветка реестра |
| Variable| Variable | Variable:\ | Переменные сессии |
| WSMan | WSMan | WSMan:\ | Конфигурация WinRM |

Эта унификация означает, что вы можете "зайти" в реестр и получить список его "ключей" (папок) и "свойств" (файлов) той же самой командой `Get-ChildItem`, которой вы получаете список файлов на диске C:. Это невероятно мощная концепция.

#### **Навигация по файловой системе: Командлеты-существительные "Item" и "Location"**

Для перемещения по файловой системе и другим PSDrives используются командлеты, которые оперируют над "элементами" (`Item`) и "местоположениями" (`Location`).

*   **`Set-Location` (псевдонимы: `sl`, `cd`)**
    Этот командлет изменяет ваше текущее местоположение. Он работает как с абсолютными, так и с относительными путями.

    ```powershell
    # Переходим в корень диска C:
    Set-Location C:\

    # Переходим в папку Windows (относительно C:\)
    Set-Location Windows

    # Переходим на два уровня вверх
    Set-Location ..\..

    # Переходим в ветку реестра!
    Set-Location HKLM:\SOFTWARE\Microsoft
    ```
*   **`Get-Location` (псевдонимы: `gl`, `pwd`)**
    Этот командлет возвращает **объект**, представляющий текущую директорию. Это не просто строка, как в `cmd.exe`.

    ```powershell
    $currentLocation = Get-Location
    $currentLocation | Get-Member
    # TypeName: System.Management.Automation.PathInfo
    ```
    Мы видим, что это объект `PathInfo`, у которого есть свойства `Path`, `Drive` и `Provider`. Это позволяет программно анализировать, где мы находимся.

*   **`Get-ChildItem` (псевдонимы: `gci`, `ls`, `dir`)**
    Это один из самых используемых командлетов. Он возвращает дочерние элементы для указанного местоположения. В случае файловой системы это будут файлы и папки.

    **Исследование объектов файлов и папок**
    `Get-ChildItem` возвращает **два разных типа объектов .NET**:
    1.  `System.IO.DirectoryInfo` (для папок)
    2.  `System.IO.FileInfo` (для файлов)

    Давайте исследуем их:
    ```powershell
    # Получим содержимое папки C:\Windows
    $items = Get-ChildItem -Path C:\Windows

    # Посмотрим, сколько объектов каждого типа мы получили
    $items | Group-Object -Property {$_.GetType().Name}
    ```
    Результат покажет, сколько файлов (`FileInfo`) и сколько папок (`DirectoryInfo`) находится в директории.

    Теперь заглянем внутрь объекта файла:
    ```powershell
    Get-ChildItem -Path C:\Windows\explorer.exe | Get-Member
    # TypeName: System.IO.FileInfo
    ```
    Вы увидите свойства, специфичные для файлов, такие как `Extension` (расширение), `IsReadOnly` (только для чтения), `Length` (размер в байтах), а также методы `CopyTo()`, `MoveTo()`, `Delete()` и даже `Encrypt()`/`Decrypt()` для работы с шифрованной файловой системой EFS.

#### **Манипулирование файлами и папками**

Теперь, когда мы знаем, что работаем с объектами, управление ими становится тривиальной задачей. Все эти командлеты по умолчанию возвращают объект созданного/скопированного/перемещенного элемента, что позволяет строить из них цепочки.

*   **`New-Item`**: Создает новый элемент. Требует указания типа (`-ItemType`).

    ```powershell
    # Создать новую папку и сразу же перейти в нее
    $newFolder = New-Item -Path C:\Temp\MyNewFolder -ItemType Directory
    Set-Location -Path $newFolder.FullName

    # Создать новый пустой файл
    New-Item -Path "MyNewFile.txt" -ItemType File
    ```
*   **`Copy-Item`**: Копирует элемент. Может принимать путь (`-Path`) или сам объект (`-LiteralPath`) для копирования.

    ```powershell
    # Получаем объект файла и передаем его по конвейеру на копирование
    Get-ChildItem -Path "MyNewFile.txt" | Copy-Item -Destination "..\AnotherFolder\"
    ```
*   **`Move-Item`**: Перемещает элемент. Может также использоваться для переименования.

    ```powershell
    Move-Item -Path "MyNewFile.txt" -Destination "MyRenamedFile.txt"
    ```
*   **`Remove-Item` (псевдонимы: `rm`, `del`)**: Удаляет элемент. Это один из самых "опасных" командлетов, поэтому используйте его с осторожностью.

    ```powershell
    # Удалить конкретный файл
    Remove-Item -Path "MyRenamedFile.txt"
    ```
    **Важные параметры `-Recurse` и `-Force`**:
    *   `-Recurse`: необходим для удаления непустой папки. Он рекурсивно удаляет все вложенное содержимое.
    *   `-Force`: позволяет удалять скрытые, системные или файлы "только для чтения" без дополнительного подтверждения.

    **Пример опасной, но мощной команды:**
    ```powershell
    # Удалить папку C:\Temp\MyNewFolder со всем ее содержимым, включая скрытые файлы
    Remove-Item -Path C:\Temp\MyNewFolder -Recurse -Force
    ```
    Для подстраховки всегда можно сначала запустить команду с параметром `-WhatIf`. Он не выполнит действие, а лишь покажет, *что* он *собирается* сделать.

    ```powershell
    Remove-Item -Path C:\Temp\MyNewFolder -Recurse -Force -WhatIf
    ```

**Пример 2: Создание текстового файла с содержимым**

```powershell
# Создать файл test.txt на диске C: и записать в него текст
Set-Content -Path "C:\test.txt" -Value "Это тестовая строка."
```
*   `-Path` — ключ, принимающий значение (путь к файлу).
*   `-Value` — ключ, принимающий значение (содержимое файла).

**Пример 3: Поиск файлов по маске в определенной папке**

```powershell
# Найти все .log файлы в папке Windows
Get-ChildItem -Path "C:\Windows" -Filter "*.log"
```
*   `-Path` — ключ, принимающий значение (путь к папке).
*   `-Filter` — ключ, принимающий значение (маска для поиска).



Эти ключи не требуют значения. Их наличие просто включает или выключает определенную опцию.

**Пример 1: Рекурсивный поиск файлов (по всем вложенным папкам)**

```powershell
# Найти все файлы с именем "hosts" на всём диске C:, включая подпапки
Get-ChildItem -Path "C:\" -Filter "hosts" -Recurse
```
*   `-Recurse` — это ключ-переключатель. Он говорит команде `Get-ChildItem` искать не только в `C:\`, но и во всех папках внутри.

**Пример 2: Принудительное завершение процесса**

**ОСТОРОЖНО:** Эта команда принудительно закроет программу без сохранения данных.

```powershell
# Принудительно остановить все процессы "Блокнота" (notepad)
Stop-Process -Name "notepad" -Force
```
*   `-Force` — ключ-переключатель. Он говорит команде `Stop-Process` завершить процесс, даже если он "сопротивляется".

**Пример 3: Получение полной справки по команде**

```powershell
# Показать самую подробную справку для команды Get-Process
Get-Help Get-Process -Full
```
*   `-Full` — ключ-переключатель, который просит `Get-Help` показать всю доступную информацию, а не только краткое описание.



На практике чаще всего используются оба типа ключей в одной команде.

**Пример 1: Копирование папки с принудительной перезаписью файлов**

**ОСТОРОЖНО:** Существующие файлы в папке назначения будут перезаписаны.

```powershell
# Скопировать папку "Source" в "Backup", включая все подпапки, и перезаписать файлы, если они уже есть
Copy-Item -Path "C:\Source" -Destination "C:\Backup" -Recurse -Force
```
*   `-Path` и `-Destination` — принимают значения (пути).
*   `-Recurse` и `-Force` — ключи-переключатели (копировать вложенные папки и перезаписывать существующие файлы).

**Пример 2: Удаление элемента без запроса подтверждения**

**ОЧЕНЬ ОСТОРОЖНО:** Эта команда удалит файл безвозвратно и не задавая вопросов.

```powershell
# Удалить файл "old_log.txt" из папки Temp, не спрашивая подтверждения
Remove-Item -Path "C:\Temp\old_log.txt" -Force
```
*   `-Path` — принимает значение (путь к файлу).
*   `-Force` — ключ-переключатель (подавляет запрос "Вы уверены?").

Надеюсь, эти примеры наглядно показывают разницу и помогут вам увереннее работать в PowerShell

**В следующей части мы объединим наши знания и научимся фильтровать, сортировать и выбирать нужные нам файлы и папки из тысяч других, используя всю мощь объектного конвейера.**