Хорошо, давайте расширим третью главу, добавив больше технических деталей, практических примеров и объяснений "под капотом".

---

### **Часть 3: Навигация и управление файловой системой.**

В предыдущей главе мы исследовали абстрактные объекты процессов. Теперь давайте применим наши знания о конвейере и объектах к одной из самых частых задач любого пользователя или администратора — работе с файловой системой. В PowerShell эта работа построена на тех же принципах: команды возвращают объекты, которые можно передавать по конвейеру для дальнейшей обработки. Мы увидим, как концепция "все есть объект" превращает рутинные файловые операции в мощный инструмент анализа и автоматизации.

#### **PowerShell Drives: Файловая система — лишь одна из многих**

Прежде чем мы начнем, важно понять концепцию **PowerShell-дисков (PSDrives)**. В отличие от `cmd.exe`, где диски — это только буквы `C:`, `D:` и так далее, в PowerShell "диск" — это абстракция для доступа к любому иерархическому хранилищу данных. Эта абстракция реализуется через **провайдеров (Providers)**. Провайдер — это, по сути, адаптер, который "учит" PowerShell, как работать с определенным типом данных, используя стандартный набор команд.

**Практика:**
Введите команду `Get-PSDrive`. Она покажет все диски, зарегистрированные в текущей сессии:

```powershell
Get-PSDrive
```

Вы увидите не только ваши физические диски (которые предоставляет провайдер `FileSystem`), но и другие "псевдо-диски":

| Name | Provider | Root | Описание |
| :--- | :--- | :--- | :--- |
| Alias | Alias | Alias:\ | Псевдонимы команд |
| C | FileSystem | C:\ | Локальный диск C |
| Cert | Certificate | Cert:\ | Хранилище сертификатов |
| Env | Environment | Env:\ | Переменные окружения |
| Function| Function | Function:\ | Загруженные функции |
| HKCU | Registry | HKEY_CURRENT_USER | Ветка реестра |
| HKLM | Registry | HKEY_LOCAL_MACHINE | Ветка реестра |
| Variable| Variable | Variable:\ | Переменные сессии |
| WSMan | WSMan | WSMan:\ | Конфигурация WinRM |

Эта унификация означает, что вы можете "зайти" в реестр и получить список его "ключей" (папок) и "свойств" (файлов) той же самой командой `Get-ChildItem`, которой вы получаете список файлов на диске C:. Это невероятно мощная концепция.

#### **Навигация по файловой системе: Командлеты-существительные "Item" и "Location"**

Для перемещения по файловой системе и другим PSDrives используются командлеты, которые оперируют над "элементами" (`Item`) и "местоположениями" (`Location`).

*   **`Set-Location` (псевдонимы: `sl`, `cd`)**
    Этот командлет изменяет ваше текущее местоположение. Он работает как с абсолютными, так и с относительными путями.

    ```powershell
    # Переходим в корень диска C:
    Set-Location C:\

    # Переходим в папку Windows (относительно C:\)
    Set-Location Windows

    # Переходим на два уровня вверх
    Set-Location ..\..

    # Переходим в ветку реестра!
    Set-Location HKLM:\SOFTWARE\Microsoft
    ```
*   **`Get-Location` (псевдонимы: `gl`, `pwd`)**
    Этот командлет возвращает **объект**, представляющий текущую директорию. Это не просто строка, как в `cmd.exe`.

    ```powershell
    $currentLocation = Get-Location
    $currentLocation | Get-Member
    # TypeName: System.Management.Automation.PathInfo
    ```
    Мы видим, что это объект `PathInfo`, у которого есть свойства `Path`, `Drive` и `Provider`. Это позволяет программно анализировать, где мы находимся.

*   **`Get-ChildItem` (псевдонимы: `gci`, `ls`, `dir`)**
    Это один из самых используемых командлетов. Он возвращает дочерние элементы для указанного местоположения. В случае файловой системы это будут файлы и папки.

    **Практика: Исследование объектов файлов и папок**
    `Get-ChildItem` возвращает **два разных типа объектов .NET**:
    1.  `System.IO.DirectoryInfo` (для папок)
    2.  `System.IO.FileInfo` (для файлов)

    Давайте исследуем их:
    ```powershell
    # Получим содержимое папки C:\Windows
    $items = Get-ChildItem -Path C:\Windows

    # Посмотрим, сколько объектов каждого типа мы получили
    $items | Group-Object -Property {$_.GetType().Name}
    ```
    Результат покажет, сколько файлов (`FileInfo`) и сколько папок (`DirectoryInfo`) находится в директории.

    Теперь заглянем внутрь объекта файла:
    ```powershell
    Get-ChildItem -Path C:\Windows\explorer.exe | Get-Member
    # TypeName: System.IO.FileInfo
    ```
    Вы увидите свойства, специфичные для файлов, такие как `Extension` (расширение), `IsReadOnly` (только для чтения), `Length` (размер в байтах), а также методы `CopyTo()`, `MoveTo()`, `Delete()` и даже `Encrypt()`/`Decrypt()` для работы с шифрованной файловой системой EFS.

#### **Манипулирование файлами и папками**

Теперь, когда мы знаем, что работаем с объектами, управление ими становится тривиальной задачей. Все эти командлеты по умолчанию возвращают объект созданного/скопированного/перемещенного элемента, что позволяет строить из них цепочки.

*   **`New-Item`**: Создает новый элемент. Требует указания типа (`-ItemType`).

    ```powershell
    # Создать новую папку и сразу же перейти в нее
    $newFolder = New-Item -Path C:\Temp\MyNewFolder -ItemType Directory
    Set-Location -Path $newFolder.FullName

    # Создать новый пустой файл
    New-Item -Path "MyNewFile.txt" -ItemType File
    ```
*   **`Copy-Item`**: Копирует элемент. Может принимать путь (`-Path`) или сам объект (`-LiteralPath`) для копирования.

    ```powershell
    # Получаем объект файла и передаем его по конвейеру на копирование
    Get-ChildItem -Path "MyNewFile.txt" | Copy-Item -Destination "..\AnotherFolder\"
    ```
*   **`Move-Item`**: Перемещает элемент. Может также использоваться для переименования.

    ```powershell
    Move-Item -Path "MyNewFile.txt" -Destination "MyRenamedFile.txt"
    ```
*   **`Remove-Item` (псевдонимы: `rm`, `del`)**: Удаляет элемент. Это один из самых "опасных" командлетов, поэтому используйте его с осторожностью.

    ```powershell
    # Удалить конкретный файл
    Remove-Item -Path "MyRenamedFile.txt"
    ```
    **Важные параметры `-Recurse` и `-Force`**:
    *   `-Recurse`: необходим для удаления непустой папки. Он рекурсивно удаляет все вложенное содержимое.
    *   `-Force`: позволяет удалять скрытые, системные или файлы "только для чтения" без дополнительного подтверждения.

    **Пример опасной, но мощной команды:**
    ```powershell
    # Удалить папку C:\Temp\MyNewFolder со всем ее содержимым, включая скрытые файлы
    Remove-Item -Path C:\Temp\MyNewFolder -Recurse -Force
    ```
    Для подстраховки всегда можно сначала запустить команду с параметром `-WhatIf`. Он не выполнит действие, а лишь покажет, *что* он *собирается* сделать.

    ```powershell
    Remove-Item -Path C:\Temp\MyNewFolder -Recurse -Force -WhatIf
    ```


**В следующей части мы объединим наши знания и научимся фильтровать, сортировать и выбирать нужные нам файлы и папки из тысяч других, используя всю мощь объектного конвейера.**