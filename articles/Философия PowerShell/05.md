### **Часть 5: Переменные и базовые типы данных.**

До сих пор мы работали с данными в "потоке" — получали их из командлетов и сразу же обрабатывали в конвейере. Но для создания сложных сценариев автоматизации нам необходим "императивный" подход: способность сохранять состояние, многократно использовать вычисленные значения и работать со сложными структурами данных. Для всего этого в PowerShell, как и в любом языке программирования, существуют **переменные**. В этой главе мы рассмотрим их не просто как "контейнеры для данных", а как полноценные объекты .NET со своими типами, методами и областями видимости.

#### **Переменные как объекты `PSVariable`**

В PowerShell все является объектами, и переменные — не исключение. Когда вы создаете переменную, на самом деле вы работаете с объектом типа `System.Management.Automation.PSVariable`. Этот объект хранится в специальном провайдере `Variable`, который мы видели в главе 3.

**Практика: Заглянем внутрь переменной**
Давайте создадим переменную и посмотрим на нее через `Get-ChildItem` в диске `Variable:`:

```powershell
$myTestVar = "Hello, World!"
Get-ChildItem -Path Variable:\myTestVar | Format-List *
```
Результат:
```
Name        : myTestVar
Description :
Value       : Hello, World!
Visibility  : Public
Module      :
ModuleName  :
Options     : None
Attributes  : {}
```
Как видите, у переменной есть не только имя (`Name`) и значение (`Value`), но и другие атрибуты, такие как `Options` (например, `ReadOnly` или `Constant`) и `Description`, которые можно задавать с помощью командлета `New-Variable`.

#### **Область видимости (Scope): Где "живут" переменные?**

Область видимости — это концепция, определяющая, где в вашем коде переменная доступна. В PowerShell существует несколько уровней (областей) видимости:

1.  **Global:** Переменная доступна везде в текущей сессии PowerShell, включая все скрипты и функции, запущенные в ней.
2.  **Local:** Это область видимости по умолчанию. Переменная доступна только внутри того контекста, где она была создана (в скрипте, в функции или просто в консоли).
3.  **Script:** Переменная доступна в пределах всего скрипта, в котором она была создана.
4.  **Private:** Переменная доступна только внутри своего контекста и не видна "внутренним" контекстам (например, функция, вызванная из другой функции, не увидит `Private` переменные родительской функции).

**Пример:**
```powershell
# Глобальная переменная
$global:appName = "My Awesome App"

function Show-AppName {
    # Локальная переменная, перекрывает глобальную внутри функции
    $appName = "My Function App"
    Write-Host "Local Scope: $appName" # Выведет "My Function App"
    Write-Host "Global Scope: $global:appName" # Выведет "My Awesome App"
}

Show-AppName
Write-Host "Outside function: $appName" # Выведет "My Awesome App"
```
Понимание областей видимости критически важно для написания модулей и сложных скриптов, чтобы избежать случайного изменения "чужих" переменных.

#### **Типы данных: Строгая типизация и мощь .NET**

Как мы уже говорили, PowerShell по умолчанию использует динамическую типизацию. Но под капотом каждый объект имеет строгий тип .NET. Давайте разберем их подробнее.

*   **Строки (`[string]` или `System.String`)**
    Помимо интерполяции в двойных кавычках (`""`) и литеральности в одинарных (`''`), строки в PowerShell являются полноценными объектами .NET `System.String` и имеют множество полезных методов:

    ```powershell
    $myString = "  PowerShell Is Awesome!  "

    $myString.ToUpper()         # "  POWERSHELL IS AWESOME!  "
    $myString.ToLower()         # "  powershell is awesome!  "
    $myString.Trim()            # "PowerShell Is Awesome!" (убирает пробелы в начале и конце)
    $myString.Contains("Shell") # $true
    $myString.Replace("Awesome", "Powerful")
    $myString.Split(' ')        # Разделит строку на массив по пробелам
    ```    **Here-String (`@""@` и `@''@`)**: для многострочного текста.
    ```powershell
    $multiLineText = @"
    Это первая строка.
    Это вторая строка.
    Переменная $user будет заменена.
    "@
    ```

*   **Массивы (`[array]` или `System.Object[]`)**
    Массив в PowerShell — это объект, у которого есть свойства и методы.

    ```powershell
    $serverList = "SERVER01", "SERVER02", "SERVER03"

    $serverList.Count  # Свойство, хранит количество элементов (3)
    $serverList.Length # Псевдоним для Count

    # Проверить, содержит ли массив элемент
    $serverList -contains "SERVER02" # $true

    # Перебор элементов (помимо цикла foreach)
    $serverList | ForEach-Object { Write-Host "Checking $_..." }
    ```
    **Важный нюанс производительности**: Как упоминалось, оператор `+=` создает новый массив каждый раз. Для эффективной работы с большими коллекциями, которые нужно часто изменять, лучше использовать более подходящие типы .NET, создавая их явно:
    ```powershell
    $fastList = [System.Collections.ArrayList]::new()
    $fastList.Add("Item1") | Out-Null # Out-Null чтобы метод Add() не выводил индекс
    $fastList.Add("Item2") | Out-Null
    $fastList.Remove("Item1")
    ```

*   **Хеш-таблицы (`[hashtable]` или `System.Collections.Hashtable`)**
    Хеш-таблица — это один из самых гибких и мощных типов данных.

    ```powershell
    $userObject = @{
        Name = "John Doe"
        Id = 123
        Department = "IT"
    }

    # Доступ к ключам и значениям как к коллекциям
    $userObject.Keys
    $userObject.Values

    # Проверка наличия ключа
    $userObject.ContainsKey("Department") # $true

    # Добавление элемента
    $userObject.Add("Location", "New York")

    # Удаление элемента
    $userObject.Remove("Id")
    ```
    **Упорядоченные хеш-таблицы `[ordered]`**: С PowerShell 3.0 появилась возможность создавать хеш-таблицы, которые сохраняют порядок добавления элементов. Это бывает важно, например, при формировании JSON.
    ```powershell
    $orderedObject = [ordered]@{
        First = 1
        Second = 2
        Third = 3
    }
    ```

*   **Приведение и преобразование типов (Casting)**
    PowerShell очень гибок в преобразовании типов.

    ```powershell
    $numberString = "123.45"
    [int]$numberString     # PowerShell отбросит дробную часть, результат: 123
    [double]$numberString # Результат: 123.45

    $dateString = "2025-07-25"
    [datetime]$dateString # PowerShell преобразует строку в объект DateTime

    # Можно даже "кастовать" хеш-таблицу в кастомный объект
    $myCustomObject = [PSCustomObject]@{
        Name = "Test"
        Value = 10
    }
    ```

*   **Специальные переменные и константы**
    Давайте рассмотрим их подробнее:
    *   `$null`: Уникальное значение, означающее "ничего". Важно понимать, что `$null` на левой стороне оператора сравнения ведет себя по-особенному. Всегда ставьте `$null` справа для предсказуемого результата: `if ($myVar -eq $null)`.
    *   `$true` / `$false`: Булевы значения.
    *   `$_` (или `$PSItem`): Текущий объект в блоке конвейера (`ForEach-Object`, `Where-Object`) или в блоке `catch`.
    *   `$Error`: Коллекция объектов ошибок. `$Error[0]` всегда содержит самую последнюю ошибку.
    *   `$PSVersionTable`: Хеш-таблица, содержащая подробную информацию о версии PowerShell.
    *   `$PSScriptRoot`: Путь к папке, из которой запущен текущий скрипт. Очень полезна для доступа к файлам, лежащим рядом со скриптом.


**В следующей части мы сделаем этот переход, создадим наш первый `.ps1` файл и разберемся с политиками выполнения, которые контролируют запуск скриптов в системе.**