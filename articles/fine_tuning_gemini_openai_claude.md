## Глубокая персонализация LLM: От промптов до тонкой настройки моделей (GPT, Claude, Gemini)


В этой статье:

1.  Как создается "эффект памяти" в LLM (краткий обзор).
2.  Зачем и когда нужна тонкая настройка (Fine-tuning) модели.
3.  Когда тонкая настройка – не лучшее решение.
4.  Подготовка данных.
5.  Примеры тонкой настройки для **OpenAI (GPT)**, **Google (Gemini)** и **Anthropic (Claude)** (отличается).

### 1. Как LLM "помнит" и "подстраивается": Иллюзия контекста

Прежде чем говорить о тонкой настройке, важно понять, как LLM вообще удается создавать ощущение персонализации. 
Это важно, чтобы не бросаться в дорогостоящую тонкую настройку, если задача решается более простыми способами:

*   **Контекстное окно (Short-Term Memory):** В рамках одного диалога вы отправляете модели не только новый вопрос, но и **всю или часть предыдущей переписки**. Модель обрабатывает весь этот текст как единый "контекст". Именно благодаря этому она "помнит" предыдущие реплики и продолжает мысль. Ограничение здесь — длина контекстного окна (количество токенов).
*   **Системные инструкции (System Prompt):** Вы можете задать модели роль, тон, правила поведения в начале каждого диалога. Например: "Ты – эксперт по Python, отвечай кратко".
*   **Few-Shot Learning:** Включение в запрос нескольких примеров желаемого поведения (input/output pairs) позволяет модели "научиться" этому паттерну прямо в рамках текущего запроса.
*   **Управление состоянием на стороне приложения:** Самый мощный способ. Ваше приложение (которое обращается к API) может хранить информацию о пользователе (предпочтения, историю, данные профиля) и динамически добавлять её в промпт перед отправкой модели.


### 2. Зачем нужна тонкая настройка (Fine-tuning)?

Тонкая настройка – это процесс дообучения уже готовой базовой LLM на вашем собственном, специфическом наборе данных. Это позволяет модели:

*   **Адаптировать стиль и тон:** Модель будет говорить "на вашем языке" – будь то строгий научный, дружелюбный маркетинговый или сленг определенного сообщества.
*   **Следовать специфическим инструкциям и форматам:** Если вам нужны ответы в строго определенной JSON-структуре, или всегда с определенным набором полей.
*   **Понимать домен-специфический язык:** Обучение на вашей внутренней документации или отраслевых текстах поможет модели лучше справляться с терминологией вашей ниши.
*   **Улучшить производительность на узких задачах:** Для определенных типов запросов (например, классификация отзывов, генерация кода в специфическом фреймворке) тонкая настройка может дать более точные и релевантные ответы, чем базовая модель.
*   **Сократить длину промптов:** Если модель уже "знает" желаемое поведение благодаря настройке, вам не нужно каждый раз напоминать ей об этом в промпте, что экономит токены и снижает задержку.

### 3. Когда тонкая настройка – не лучшее решение?

Тонкая настройка – мощный, но не универсальный инструмент. Не стоит использовать её, если:

*   **Модель должна получать доступ к новым знаниям:** Тонкая настройка изменяет веса модели, но не "загружает" в неё новые факты в реальном времени. Если ваша задача – отвечать на вопросы по постоянно меняющейся базе знаний (документы компании, последние новости), лучше использовать **Retrieval Augmented Generation (RAG)**. Здесь базовая модель получает контекст из вашей базы данных *во время выполнения запроса*.
*   **Простая задача решается промпт-инжинирингом:** Всегда начинайте с максимально эффективного промпт-инжиниринга. Если задача решается простыми инструкциями и few-shot примерами, тонкая настройка избыточна и более затратна.
*   **У вас нет достаточного количества высококачественных данных:** Плохие данные = плохая настроенная модель.

### 4. Подготовка данных – сердце тонкой настройки

Качество и количество ваших данных критически важны. Модель учится на ваших примерах, поэтому они должны быть точными, разнообразными и последовательными.

*   **Формат:** Чаще всего JSON Lines (`.jsonl`) или CSV (`.csv`).
*   **Структура данных:** Зависит от задачи.
    *   **Instruction Tuning (Инструкция-Ответ):** Подходит для обобщенных задач типа "вопрос-ответ", перефразирования, суммаризации.
        ```json
        {"input_text": "Перефразируй предложение: 'Технология ИИ стремительно развивается.'", "output_text": "Искусственный интеллект демонстрирует стремительный прогресс."}
        {"input_text": "Назови столицу Франции.", "output_text": "Столица Франции — Париж."}
        ```
    *   **Chat Tuning (Чат):** Идеально для обучения модели ведению диалога в определенной роли или стиле.
        ```json
        {"messages": [{"author": "user", "content": "Привет! Что порекомендуешь на ужин?"}, {"author": "model", "content": "Добрый вечер! Сегодня отличный день для пасты Карбонара, или, если вы предпочитаете что-то легкое, салат Цезарь."}]}
        {"messages": [{"author": "user", "content": "Расскажи про новые фичи в Python 3.12."}, {"author": "model", "content": "В Python 3.12 появились f-строки с отступами, новый синтаксис для универсальных генериков и улучшенная обработка ошибок Unicode."}]}
        ```
*   **Количество:** Минимум 100-200 качественных примеров, но чем больше, тем лучше (тысячи для серьезных задач).
*   **Качество:** Точность, последовательность стиля, тона, формата во всем наборе данных.

### 5. Тонкая настройка на практике: Модели и платформы

Рассмотрим процесс для трех популярных семейств моделей.

#### 5.1. OpenAI (GPT-3.5 Turbo)

OpenAI предоставляет довольно простой и интуитивно понятный API для тонкой настройки. 

**Процесс:**

1.  Подготовка данных в формате JSONL, где каждая строка — это объект с массивом `messages` (как в Chat Completions API).
2.  Загрузка файла данных через API.
3.  Создание задания на тонкую настройку, указав загруженный файл и базовую модель.
4.  Отслеживание прогресса.
5.  Использование новой, настроенной модели по её ID.

**Пример данных (файл `training_data.jsonl`):**

```json
{"messages": [{"role": "system", "content": "Ты - дружелюбный ассистент по поддержке клиентов IT-компании."}, {"role": "user", "content": "Мой интернет не работает."}, {"role": "assistant", "content": "Ох, извините за неудобства! Давайте попробуем разобраться. Каким образом вы подключены к интернету – по Wi-Fi или через кабель?"}]}
{"messages": [{"role": "system", "content": "Ты - дружелюбный ассистент по поддержке клиентов IT-компании."}, {"role": "user", "content": "Как я могу сбросить пароль?"}, {"role": "assistant", "content": "Конечно! Чтобы сбросить пароль, перейдите, пожалуйста, на страницу входа и нажмите 'Забыли пароль?' под полем для ввода. Далее следуйте инструкциям на экране."}]}
```

**Пример Python кода:**

Предварительно установите: `pip install openai`

```python
import openai
from openai import OpenAI
import os

# Установите ваш API-ключ OpenAI. Рекомендуется использовать переменную окружения.
# os.environ["OPENAI_API_KEY"] = "sk-..."
client = OpenAI()

# 1. Загрузка файла данных
try:
    file_response = client.files.create(
        file=open("training_data.jsonl", "rb"),
        purpose="fine-tune"
    )
    file_id = file_response.id
    print(f"Файл успешно загружен. ID файла: {file_id}")
except openai.APIStatusError as e:
    print(f"Ошибка загрузки файла: {e.status_code} - {e.response}")
    exit()

# 2. Создание задания на тонкую настройку
try:
    ft_job_response = client.fine_tuning.jobs.create(
        training_file=file_id,
        model="gpt-3.5-turbo" # Можно указать конкретную версию, например, "gpt-3.5-turbo-0125"
    )
    job_id = ft_job_response.id
    print(f"Задание на тонкую настройку создано. ID задания: {job_id}")
    print("Отслеживайте статус задания через API или в OpenAI Playground.")
except openai.APIStatusError as e:
    print(f"Ошибка создания задания: {e.status_code} - {e.response}")
    exit()

# Пример отслеживания статуса и получения имени модели (выполнять после создания задания):
# # job_id = "ftjob-..." # Замените на ID вашего задания
# # job_status = client.fine_tuning.jobs.retrieve(job_id)
# # print(f"Текущий статус задания: {job_status.status}")
# # if job_status.status == "succeeded":
# #     fine_tuned_model_name = job_status.fine_tuned_model
# #     print(f"Имя настроенной модели: {fine_tuned_model_name}")

# 3. Использование настроенной модели (после её готовности)
# # Замените на реальное имя вашей модели, полученное после успешной тонкой настройки
# # fine_tuned_model_name = "ft:gpt-3.5-turbo-0125:my-org::abcd123"

# # if 'fine_tuned_model_name' in locals() and fine_tuned_model_name:
# #     try:
# #         response = client.chat.completions.create(
# #             model=fine_tuned_model_name,
# #             messages=[
# #                 {"role": "user", "content": "У меня проблема с логином."}
# #             ]
# #         )
# #         print("\nОтвет настроенной модели:")
# #         print(response.choices[0].message.content)
# #     except openai.APIStatusError as e:
# #         print(f"Ошибка при использовании модели: {e.status_code} - {e.response}")
```

#### 5.2. Anthropic (Claude 3)

Anthropic **не предоставляет публичного API для тонкой настройки своих моделей Claude 3 (Opus, Sonnet, Haiku) в том же смысле, как это делает OpenAI или Google.**

Anthropic сфокусирован на создании очень мощных базовых моделей, которые, по их утверждениям, отлично работают с продвинутым промпт-инжинирингом и RAG-паттернами, минимизируя необходимость в тонкой настройке для большинства случаев. 
Для крупных корпоративных клиентов или партнеров могут существовать программы по созданию "кастомных" моделей или специализированных интеграций, но это не является общедоступной функцией тонкой настройки через API.

Если вы работаете с Claude 3, ваш основной упор должен быть на:

*   **Качественный промпт-инжиниринг:** Экспериментируйте с системными инструкциями, few-shot примерами, четким форматированием запросов. Claude известен своей способностью строго следовать инструкциям, особенно в XML-тегах.
*   **RAG-системы:** Используйте внешние базы данных знаний, чтобы предоставлять модели актуальный контекст.

#### 5.3. Google (Gemini)

Google активно развивает возможности тонкой настройки через свою платформу **Google Cloud Vertex AI**. 
Это полноценная ML-платформа, которая предоставляет инструменты для подготовки данных, запуска обучающих заданий и развертывания моделей. 
Тонкая настройка доступна для моделей семейства Gemini.

**Процесс:**

1.  Подготовка данных (JSONL или CSV) в формате `input_text`/`output_text` (для instruction tuning) или `messages` (для chat tuning).
2.  Загрузка данных в Google Cloud Storage (GCS).
3.  Создание и запуск задания по тонкой настройке через Vertex AI Console или SDK.
4.  Развертывание настроенной модели на конечной точке (Endpoint).
5.  Использование настроенной модели через эту конечную точку.

**Пример данных (файл `gemini_tuning_data.jsonl`):**

```json
{"input_text": "Суммируй основные идеи этой книги: 'Книга рассказывает о путешествии героя, который преодолевает препятствия и находит себя.'", "output_text": "Главный герой книги отправляется в трансформирующее путешествие, сталкиваясь с трудностями и обретая самопознание."}
{"input_text": "Объясни принцип работы термоядерного реактора простыми словами.", "output_text": "Термоядерный реактор пытается воспроизвести процесс, который происходит на Солнце: слияние легких атомных ядер при очень высоких температурах, высвобождая огромное количество энергии."}
```

**Пример Python кода (требует `google-cloud-aiplatform`):**

Предварительно установите: `pip install google-cloud-aiplatform` и `pip install google-cloud-storage`

```python
import os
from google.cloud import aiplatform
from google.cloud import storage

# --- Настройки ---
# ЗАМЕНИТЕ на свои значения:
PROJECT_ID = "your-gcp-project-id"
REGION = "us-central1"               # Выберите регион, поддерживающий Gemini и Vertex AI
BUCKET_NAME = "your-gcs-bucket-for-tuning" # Имя вашего бакета GCS (должен быть создан заранее)
DATA_FILE_LOCAL_PATH = "gemini_tuning_data.jsonl"
GCS_DATA_URI = f"gs://{BUCKET_NAME}/{DATA_FILE_LOCAL_PATH}"
TUNED_MODEL_DISPLAY_NAME = "my-tuned-gemini-model"
# --- Конец настроек ---

# Инициализация Vertex AI
aiplatform.init(project=PROJECT_ID, location=REGION)

# 1. Создание файла с данными (если его нет)
with open(DATA_FILE_LOCAL_PATH, "w", encoding="utf-8") as f:
    f.write('{"input_text": "Суммируй основные идеи этой книги: \'Книга рассказывает о путешествии героя, который преодолевает препятствия и находит себя.\'", "output_text": "Главный герой книги отправляется в трансформирующее путешествие, сталкиваясь с трудностями и обретая самопознание."}\n')
    f.write('{"input_text": "Объясни принцип работы термоядерного реактора простыми словами.", "output_text": "Термоядерный реактор пытается воспроизвести процесс, который происходит на Солнце: слияние легких атомных ядер при очень высоких температурах, высвобождая огромное количество энергии."}\n')
print(f"Файл данных '{DATA_FILE_LOCAL_PATH}' создан.")


# 2. Загрузка данных в Google Cloud Storage
def upload_blob(bucket_name, source_file_name, destination_blob_name):
    """Загружает файл в бакет GCS."""
    storage_client = storage.Client(project=PROJECT_ID)
    bucket = storage_client.bucket(bucket_name)
    blob = bucket.blob(destination_blob_name)
    blob.upload_from_filename(source_file_name)
    print(f"Файл '{source_file_name}' загружен в 'gs://{bucket_name}/{destination_blob_name}'.")

try:
    upload_blob(BUCKET_NAME, DATA_FILE_LOCAL_PATH, DATA_FILE_LOCAL_PATH)
except Exception as e:
    print(f"Ошибка загрузки файла в GCS. Убедитесь, что бакет существует и у вас есть права: {e}")
    exit()

# 3. Создание и запуск задания на тонкую настройку
print(f"\nЗапуск тонкой настройки модели '{TUNED_MODEL_DISPLAY_NAME}'...")
try:
    # `tune_model` запускает задание и возвращает настроенную модель после завершения
    tuned_model = aiplatform.Model.tune_model(
        model_display_name=TUNED_MODEL_DISPLAY_NAME,
        source_model_name="gemini-1.0-pro-001", # Базовая модель Gemini Pro
        training_data_path=GCS_DATA_URI,
        tuning_method="SUPERVISED_TUNING",
        train_steps=100, # Количество шагов обучения. Оптимальное значение зависит от размера данных.
        # batch_size=16, # Можно указать
        # learning_rate_multiplier=1.0 # Можно указать
    )
    print(f"Модель '{TUNED_MODEL_DISPLAY_NAME}' успешно настроена. ID модели: {tuned_model.name}")
    print("Процесс тонкой настройки может занять значительное время.")
except Exception as e:
    print(f"Ошибка тонкой настройки. Проверьте логи в Vertex AI Console: {e}")
    exit()

# 4. Развертывание настроенной модели (для использования)
print(f"\nРазвертывание настроенной модели '{TUNED_MODEL_DISPLAY_NAME}' на конечную точку...")
try:
    endpoint = tuned_model.deploy(
        machine_type="n1-standard-4", # Тип машины для конечной точки. Выберите подходящий.
        min_replica_count=1,
        max_replica_count=1
    )
    print(f"Модель развернута на конечную точку: {endpoint.name}")
    print("Развертывание также может занять несколько минут.")
except Exception as e:
    print(f"Ошибка развертывания модели: {e}")
    exit()

# 5. Использование настроенной модели
print("\nТестирование настроенной модели...")
prompt = "Расскажи мне о своих возможностях после обучения."
instances = [{"prompt": prompt}] # Для Instruction Tuning. Если Chat Tuning, то {"messages": [...]}

try:
    response = endpoint.predict(instances=instances)
    print("\nОтвет настроенной модели:")
    print(response.predictions[0])
except Exception as e:
    print(f"Ошибка при использовании настроенной модели: {e}")

# После завершения работы, не забудьте удалить конечную точку и модель, чтобы избежать лишних расходов:
# endpoint.delete()
# tuned_model.delete()
```

### 6. Общие рекомендации

*   **Начните с малого:** Не пытайтесь сразу обучить модель на тысячах примеров. Начните с небольшого, но качественного набора данных.
*   **Итерируйте:** Тонкая настройка — это итеративный процесс. Обучайте, оценивайте, корректируйте данные или гиперпараметры, повторяйте.
*   **Мониторинг:** Внимательно отслеживайте метрики обучения (потери) и используйте набор валидационных данных, чтобы избежать переобучения.
*   **Оценка:** Всегда тестируйте настроенную модель на данных, которые она *никогда не видела* во время обучения, чтобы оценить её обобщающую способность.
*   **Стоимость:** Помните, что тонкая настройка и развертывание конечных точек платные. Учитывайте это в бюджете.
*   **Документация:** Всегда сверяйтесь с официальной документацией поставщика LLM. API и возможности постоянно развиваются.

