## Сложность алгоритмов простыми словами и примерами на Python

В программировании существует множество способов решения одной и той же задачи. Однако, не все решения одинаково эффективны. Один из ключевых аспектов, который следует учитывать при разработке алгоритмов, – это их сложность. Понимание сложности алгоритма позволяет оценить, как быстро он будет работать и сколько ресурсов (например, памяти) потребуется для его выполнения, особенно при увеличении объема входных данных. Понимание сложности алгоритмов – фундаментальный навык, который позволяет писать более эффективный код.

### Что такое сложность алгоритма?

Представьте, что у вас есть задача: найти конкретное имя в телефонной книге.

*   **Простой способ (линейный поиск):** Вы берете книгу и начинаете листать страницу за страницей, пока не найдете нужное имя. Если имя в самом конце книги, вам придется перелистать всю книгу!
*   **Умный способ (бинарный поиск):** Вы открываете книгу посередине. Если имя, которое вы ищете, идет раньше имени на этой странице, вы закрываете вторую половину книги и ищете в первой половине. Если имя идет позже, вы ищете во второй половине. И так повторяете, пока не найдете нужное имя. При каждом шаге вы отбрасываете половину книги!

**Сложность алгоритма** – это способ описать, сколько "времени" (или ресурсов, например памяти) потребуется алгоритму, чтобы выполнить свою задачу, в зависимости от того, насколько "большая" эта задача.

*   **Линейный поиск:** Если в книге 10 страниц, вам может потребоваться пролистать 10 страниц. Если в книге 100 страниц, вам может потребоваться пролистать 100 страниц. Количество работы растет *линейно* с размером задачи. Это называется **O(n)**, где 'n' – это размер задачи (количество страниц в книге).

*   **Бинарный поиск:** Если в книге 16 страниц, вам потребуется максимум 4 шага, чтобы найти имя. Если в книге 32 страницы, вам потребуется максимум 5 шагов. Количество работы растет гораздо медленнее, чем размер задачи. Это называется **O(log n)** (читается "о от логарифма эн").



*   Алгоритм **O(n)** становится медленнее *прямо пропорционально* увеличению размера задачи.
*   Алгоритм **O(log n)** становится медленнее *гораздо медленнее*, чем растет размер задачи.



Представьте, что вы разрабатываете поисковую систему. Если вы используете алгоритм O(n) для поиска в интернете (который содержит миллиарды веб-страниц), это займет невероятно много времени! А алгоритм O(log n) справится с этой задачей гораздо быстрее.

### Основные типы сложности алгоритмов

Вот некоторые наиболее распространенные типы сложности:

*   **O(1) – Константная сложность:** Время выполнения всегда одинаковое, независимо от размера задачи. Например, взять первый элемент из списка.

    ```python
    def get_first_element(my_list):
        """O(1) - Получение первого элемента списка."""
        return my_list[0]
    ```

*   **O(log n) – Логарифмическая сложность:** Время выполнения растет очень медленно с ростом размера задачи. Отличный пример – бинарный поиск.

    ```python
    def binary_search(my_list, target):
        """O(log n) - Бинарный поиск в отсортированном списке."""
        low = 0
        high = len(my_list) - 1

        while low <= high:
            mid = (low + high) // 2
            if my_list[mid] == target:
                return mid
            elif my_list[mid] < target:
                low = mid + 1
            else:
                high = mid - 1
        return -1  # Элемент не найден
    ```

*   **O(n) – Линейная сложность:** Время выполнения растет прямо пропорционально размеру задачи. Например, пройти по каждому элементу в списке.

    ```python
    def linear_search(my_list, target):
        """O(n) - Линейный поиск в списке."""
        for i in range(len(my_list)):
            if my_list[i] == target:
                return i
        return -1  # Элемент не найден
    ```

*   **O(n log n) – Линейно-логарифмическая сложность:**  Часто встречается в эффективных алгоритмах сортировки, таких как Merge Sort и Quick Sort.

    ```python
    def merge_sort(my_list):
        """O(n log n) - Сортировка слиянием."""
        if len(my_list) <= 1:
            return my_list

        mid = len(my_list) // 2
        left = merge_sort(my_list[:mid])
        right = merge_sort(my_list[mid:])

        return merge(left, right)

    def merge(left, right):
        """Вспомогательная функция для merge_sort."""
        merged = []
        i = j = 0

        while i < len(left) and j < len(right):
            if left[i] <= right[j]:
                merged.append(left[i])
                i += 1
            else:
                merged.append(right[j])
                j += 1

        merged.extend(left[i:])
        merged.extend(right[j:])
        return merged
    ```

*   **O(n^2) – Квадратичная сложность:** Время выполнения растет *в квадрате* от размера задачи. Например, сравнить каждый элемент в списке с каждым другим элементом в этом же списке.

    ```python
    def bubble_sort(my_list):
        """O(n^2) - Сортировка пузырьком."""
        n = len(my_list)
        for i in range(n):
            for j in range(0, n-i-1):
                if my_list[j] > my_list[j+1] :
                    my_list[j], my_list[j+1] = my_list[j+1], my_list[j]
    ```

*   **O(2^n) – Экспоненциальная сложность:** Время выполнения растет очень быстро с ростом размера задачи.  Обычно встречается в алгоритмах, использующих полный перебор.

    ```python
    def fibonacci_recursive(n):
      """O(2^n) - Рекурсивное вычисление числа Фибоначчи."""
      if n <= 1:
          return n
      return fibonacci_recursive(n-1) + fibonacci_recursive(n-2)
    ```

*   **O(n!) – Факториальная сложность:** Самый медленный тип сложности. Встречается при переборе всех возможных перестановок элементов.

### Примеры задач и алгоритмов с разной сложностью

Рассмотрим несколько примеров задач и различных алгоритмов для их решения, чтобы увидеть, 
как сложность влияет на производительность.

**1. Сортировка списка:**

*   **Задача:** Отсортировать список элементов в определенном порядке (например, по возрастанию).
*   **Алгоритмы :**
    *   **Bubble Sort:**

        ```python
        def bubble_sort(my_list):
            n = len(my_list)
            for i in range(n):
                for j in range(0, n-i-1):
                    if my_list[j] > my_list[j+1] :
                        my_list[j], my_list[j+1] = my_list[j+1], my_list[j]
        # Пример использования
        my_list = [64, 34, 25, 12, 22, 11, 90]
        bubble_sort(my_list)
        print("Отсортированный массив:", my_list) # Вывод: [11, 12, 22, 25, 34, 64, 90]
        ```

    *   **Merge Sort:**

        ```python
        def merge_sort(my_list):
            if len(my_list) <= 1:
                return my_list

            mid = len(my_list) // 2
            left = merge_sort(my_list[:mid])
            right = merge_sort(my_list[mid:])

            return merge(left, right)

        def merge(left, right):
            merged = []
            i = j = 0

            while i < len(left) and j < len(right):
                if left[i] <= right[j]:
                    merged.append(left[i])
                    i += 1
                else:
                    merged.append(right[j])
                    j += 1

            merged.extend(left[i:])
            merged.extend(right[j:])
            return merged

        # Пример использования
        my_list = [64, 34, 25, 12, 22, 11, 90]
        sorted_list = merge_sort(my_list)
        print("Отсортированный массив:", sorted_list) # Вывод: [11, 12, 22, 25, 34, 64, 90]
        ```
*   **Вывод:** Для больших списков элементов алгоритмы с O(n log n) (Merge Sort) предпочтительнее алгоритмов с O(n^2) (Bubble Sort).

**2. Поиск кратчайшего пути в графе:**

*   **Задача:** Найти кратчайший путь между двумя вершинами в графе (например, между двумя городами на карте).
*   **Алгоритмы:**
    *   **Алгоритм Дейкстры (Dijkstra's Algorithm):**

        ```python
        import heapq

        def dijkstra(graph, start):
            """Алгоритм Дейкстры для поиска кратчайших путей."""
            distances = {node: float('inf') for node in graph}
            distances[start] = 0
            priority_queue = [(0, start)]  # (distance, node)

            while priority_queue:
                distance, node = heapq.heappop(priority_queue)

                if distance > distances[node]:
                    continue

                for neighbor, weight in graph[node].items():
                    new_distance = distance + weight
                    if new_distance < distances[neighbor]:
                        distances[neighbor] = new_distance
                        heapq.heappush(priority_queue, (new_distance, neighbor))

            return distances

        # Пример использования
        graph = {
            'A': {'B': 5, 'C': 1},
            'B': {'A': 5, 'C': 2, 'D': 1},
            'C': {'A': 1, 'B': 2, 'D': 4, 'E': 8},
            'D': {'B': 1, 'C': 4, 'E': 3, 'F': 6},
            'E': {'C': 8, 'D': 3},
            'F': {'D': 6}
        }
        start_node = 'A'
        shortest_paths = dijkstra(graph, start_node)
        print(f"Кратчайшие пути от {start_node}: {shortest_paths}")
        ```

*   **Вывод:** Выбор алгоритма зависит от типа графа (взвешенный/невзвешенный, наличие отрицательных весов) и размера графа. Алгоритм Дейкстры эффективен для графов с неотрицательными весами.

**3. Поиск подстроки в строке:**

*   **Задача:** Найти все вхождения определенной подстроки в большей строке.
*   **Алгоритмы:**
    *   **Наивный поиск (Naive String Search):**

        ```python
        def naive_string_search(text, pattern):
            """Наивный алгоритм поиска подстроки."""
            occurrences = []
            for i in range(len(text) - len(pattern) + 1):
                if text[i:i+len(pattern)] == pattern:
                    occurrences.append(i)
            return occurrences

        # Пример использования
        text = "This is a simple example text."
        pattern = "example"
        occurrences = naive_string_search(text, pattern)
        print(f"Вхождения '{pattern}' в текст: {occurrences}")  # Вывод: [17]
        ```

*   **Вывод:** Для частого поиска подстрок в больших строках, существуют более эффективные алгоритмы, такие как КМП.

**4. Задача о рюкзаке (Knapsack Problem):**

*   **Задача:** У вас есть рюкзак определенной вместимости и набор предметов с разным весом и ценностью. Нужно выбрать предметы, которые максимизируют общую ценность, не превышая вместимость рюкзака.
*   **Алгоритмы:**
    *   **Динамическое программирование (Dynamic Programming):**

        ```python
        def knapsack_dynamic_programming(capacity, weights, values, n):
            """Решение задачи о рюкзаке методом динамического программирования."""
            dp = [[0 for x in range(capacity + 1)] for x in range(n + 1)]

            for i in range(n + 1):
                for w in range(capacity + 1):
                    if i == 0 or w == 0:
                        dp[i][w] = 0
                    elif weights[i-1] <= w:
                        dp[i][w] = max(values[i-1] + dp[i-1][w-weights[i-1]],  dp[i-1][w])
                    else:
                        dp[i][w] = dp[i-1][w]

            return dp[n][capacity]

        # Пример использования
        capacity = 50
        weights = [10, 20, 30]
        values = [60, 100, 120]
        n = len(values)
        max_value = knapsack_dynamic_programming(capacity, weights, values, n)
        print(f"Максимальная ценность: {max_value}")  # Вывод: 220
        ```

*   **Выбор алгоритма зависит от размера задачи и требований к точности решения.** 

###  O-нотация: упрощение сложности

Обычно сложность описывается с использованием "большой буквы O" (O-нотация). Она показывает, как быстро растет время выполнения алгоритма с ростом размера задачи, *асимптотически*, то есть для очень больших значений `n`. Мелкие константы и детали реализации обычно игнорируются. Например, алгоритм, который делает `2n + 5` операций, все равно считается *O(n)*.

###  В худшем случае, среднем случае, лучшем случае

Сложность алгоритма может зависеть от входных данных. Обычно говорят о сложности *в худшем случае* – это максимальное количество времени или ресурсов, которое может потребоваться алгоритму. Иногда также анализируют сложность в среднем случае и лучшем случае.
