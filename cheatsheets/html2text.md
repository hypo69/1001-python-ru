# **Превращаем HTML в Markdown с помощью `html2text` в Python**

Преобразование HTML-документов в формат Markdown. 

**`html2text`** — это компактный и простой в использовании инструмент, предназначенный для конвертации HTML в чистый, хорошо структурированный Markdown. Он отлично справляется с базовыми элементами форматирования, такими как заголовки, абзацы, списки и ссылки. Однако стоит помнить, что сложные HTML-структуры, вроде таблиц или элементов, сильно зависящих от CSS и JavaScript, могут быть упрощены или проигнорированы.

**Для чего может пригодиться `html2text`?**

*   **Извлечение контента:** Быстрое получение основного текста со страницы, очищенного от HTML-тегов.
*   **Создание документации:** Если у вас есть HTML-документация, вы можете легко конвертировать её в Markdown для использования на платформах вроде GitHub.
*   **Парсинг сайтов:** В сочетании с библиотеками для веб-скрапинга (например, `requests` и `BeautifulSoup`) `html2text` поможет получить текстовое содержимое страниц в удобном формате.
*   **Упрощение разметки:** Для систем, которые лучше работают с Markdown, чем с полным HTML.

Давайте погрузимся в детали установки и использования этой полезной библиотеки.

---

## **1. Установка: Готовим почву**

Как и большинство Python-пакетов, `html2text` легко устанавливается с помощью `pip`:

```bash
pip install html2text
```

Если вы используете несколько версий Python или работаете в виртуальном окружении, возможно, вам понадобится `pip3`:

```bash
pip3 install html2text
```

Убедитесь, что установка прошла успешно, попробовав импортировать библиотеку в интерпретаторе Python:

```python
import html2text
print(html2text.__version__) # Должно вывести версию библиотеки
```

---

## **2. Базовое использование: Первые шаги**

Самый простой способ использовать `html2text` — это вызвать функцию `html2text.html2text()`, передав ей HTML-строку.

### **Простой пример**

Давайте возьмем небольшой фрагмент HTML и посмотрим, как он преобразится:

```python
import html2text

html_content = """
<html>
<head>
    <title>Тестовая страница</title>
</head>
<body>
    <h1>Привет, Мир!</h1>
    <p>Это простой пример демонстрации работы <b>html2text</b>.</p>
    <p>Мы преобразуем <i>этот HTML</i> в Markdown.</p>
    <ul>
        <li>Первый пункт</li>
        <li>Второй пункт</li>
    </ul>
    <a href="https://example.com">Это ссылка</a>
</body>
</html>
"""

markdown_output = html2text.html2text(html_content)

print(markdown_output)
```

**Вывод:**

```markdown
Привет, Мир!
============

Это простой пример демонстрации работы **html2text**.

Мы преобразуем *этот HTML* в Markdown.

  * Первый пункт
  * Второй пункт

[Это ссылка](https://example.com)
```

Как видите, заголовки (`<h1>`), параграфы (`<p>`), выделение жирным (`<b>`), курсивом (`<i>`), списки (`<ul><li>`) и ссылки (`<a>`) были корректно преобразованы в соответствующий Markdown-синтаксис.

---

## **3. Настройка преобразования: Тонкая работа с `HTML2Text`**

Для более гибкого управления процессом конвертации `html2text` предоставляет класс `HTML2Text`. Создав его экземпляр, вы можете настроить различные параметры перед вызовом метода `handle()` для преобразования.

### **Основные параметры экземпляра `HTML2Text`**

| Параметр              | Тип     | По умолчанию | Описание                                                                                                                               |
|-----------------------|---------|--------------|----------------------------------------------------------------------------------------------------------------------------------------|
| `bodywidth`           | `int`   | `None`       | Максимальная ширина строки для вывода. Если `None` (или 0), строки не будут переноситься.                                                 |
| `baseurl`             | `str`   | `''`         | Базовый URL для преобразования относительных ссылок в абсолютные.                                                                        |
| `ignore_links`        | `bool`  | `False`      | Если `True`, теги `<a>` будут проигнорированы (текст внутри них останется).                                                              |
| `ignore_images`       | `bool`  | `False`      | Если `True`, теги `<img>` будут проигнорированы.                                                                                         |
| `ignore_emphasis`     | `bool`  | `False`      | Если `True`, теги выделения (`<b>`, `<strong>`, `<i>`, `<em>`) будут проигнорированы (текст внутри них останется без форматирования).    |
| `ignore_tables`       | `bool`  | `False`      | Если `True`, таблицы будут полностью проигнорированы. По умолчанию текст из ячеек извлекается, но без Markdown-форматирования таблицы.     |
| `images_to_alt`       | `bool`  | `False`      | Если `True` и `ignore_images` `False`, вместо `![alt](src)` будет выводиться только `alt` текст изображения.                              |
| `images_with_size`    | `bool`  | `False`      | Если `True`, пытается добавить размеры изображения в HTML-формате к Markdown-изображению (например, `![alt](src){width=... height=...}`). |
| `escape_all`          | `bool`  | `False`      | Если `True`, экранирует все специальные Markdown-символы (например, `*` превратится в `\*`).                                            |
| `ul_item_mark`        | `str`   | `*`          | Маркер для элементов неупорядоченного списка (`<ul>`). Может быть `*`, `-` или `+`.                                                       |
| `emphasis_mark`       | `str`   | `_`          | Символ для выделения курсивом (`*` или `_`). Обратите внимание, что по умолчанию используется `_`, но вывод часто показывает `*`.         |
| `strong_mark`         | `str`   | `**`         | Символ для выделения жирным (`**` или `__`).                                                                                             |
| `unicode_snob`        | `bool`  | `False`      | Использовать красивые Unicode-символы вместо ASCII-эквивалентов (например, для горизонтальной линии).                                    |
| `protect_links`       | `bool`  | `False`      | Если `True`, оборачивает ссылки в `< >`, чтобы предотвратить их случайное распознавание как Markdown (например, в email-адресах).      |
| `google_doc`          | `bool`  | `False`      | Включает специальные обходные пути для HTML, экспортированного из Google Docs.                                                         |
| `default_image_alt`   | `str`   | `''`         | Текст по умолчанию для изображений, у которых отсутствует атрибут `alt`.                                                                  |
| `bypass_tables`       | `bool`  | `True`       | (Устарел, используйте `ignore_tables=False` для старого поведения). Если `True`, обрабатывает таблицы, извлекая текст из ячеек.          |

### **Примеры с параметрами**

Давайте рассмотрим, как эти параметры влияют на результат.

```python
import html2text

# Создаем экземпляр конвертера
h = html2text.HTML2Text()

# 1. Ограничение ширины строки и игнорирование ссылок
h.bodywidth = 30
h.ignore_links = True
html_snippet1 = '<p>Это очень длинная строка текста, которая должна быть перенесена. <a href="https://example.com">Ссылка</a></p>'
markdown1 = h.handle(html_snippet1)
print("--- Пример 1 (bodywidth, ignore_links) ---")
print(markdown1)

# Сбросим ignore_links для следующих примеров
h.ignore_links = False

# 2. Игнорирование изображений и использование alt-текста
h.ignore_images = False # Убедимся, что изображения обрабатываются
h.images_to_alt = True
html_snippet2 = '<p>Картинка: <img src="image.png" alt="логотип"></p>'
markdown2 = h.handle(html_snippet2)
print("--- Пример 2 (images_to_alt) ---")
print(markdown2)

# Сбросим images_to_alt
h.images_to_alt = False

# 3. Экранирование специальных символов
h.escape_all = True
html_snippet3 = "<p>Текст с *звездочками* и _подчеркиваниями_.</p>"
markdown3 = h.handle(html_snippet3)
print("--- Пример 3 (escape_all) ---")
print(markdown3)

# Сбросим escape_all
h.escape_all = False

# 4. Изменение маркеров списка и форматирования
h.ul_item_mark = '-'
h.emphasis_mark = '*' # По умолчанию и так часто '*' для <i>
h.strong_mark = '__'
html_snippet4 = "<ul><li><em>Важно</em></li><li><strong>Очень важно</strong></li></ul>"
markdown4 = h.handle(html_snippet4)
print("--- Пример 4 (ul_item_mark, emphasis_mark, strong_mark) ---")
print(markdown4)

# 5. Использование unicode_snob для красивых разделителей
h_unicode = html2text.HTML2Text() # Новый экземпляр для чистоты
h_unicode.unicode_snob = True
html_snippet5 = "<hr>"
markdown5 = h_unicode.handle(html_snippet5)
print("--- Пример 5 (unicode_snob) ---")
print(markdown5)

# Для сравнения, без unicode_snob
h_no_unicode = html2text.HTML2Text()
markdown5_no_unicode = h_no_unicode.handle(html_snippet5)
print("--- Пример 5 (без unicode_snob) ---")
print(markdown5_no_unicode)
```

**Ожидаемый вывод:**

```
--- Пример 1 (bodywidth, ignore_links) ---
Это очень длинная строка
текста, которая должна быть
перенесена. Ссылка

--- Пример 2 (images_to_alt) ---
Картинка: логотип

--- Пример 3 (escape_all) ---
Текст с \*звездочками\* и \_подчеркиваниями\_.

--- Пример 4 (ul_item_mark, emphasis_mark, strong_mark) ---
  - *Важно*
  - __Очень важно__

--- Пример 5 (unicode_snob) ---
――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

--- Пример 5 (без unicode_snob) ---
* * *
```
*Примечание: фактический вывод символов для `emphasis_mark` и `strong_mark` может зависеть от того, какие HTML теги используются (`<i>` vs `<em>`, `<b>` vs `<strong>`). `html2text` может иметь внутреннюю логику предпочтений.*

Экспериментируя с этими параметрами, вы можете добиться вывода, наиболее точно соответствующего вашим требованиям.

---

## **4. Обработка HTML из различных источников**

`html2text` работает со строками, поэтому источник HTML может быть любым: файл на диске, ответ от веб-сервера и т.д.

### **Конвертация HTML-файла**

Предположим, у вас есть файл `input.html` следующего содержания:

```html
<!-- input.html -->
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Мой HTML Файл</title>
</head>
<body>
    <h1>Заголовок из файла</h1>
    <p>Это содержимое файла, которое будет преобразовано.</p>
    <ol>
        <li>Первый нумерованный пункт</li>
        <li>Второй нумерованный пункт</li>
    </ol>
</body>
</html>
```

Код для его конвертации:

```python
import html2text

# Создаем экземпляр с желаемыми настройками (если нужны)
converter = html2text.HTML2Text()
converter.bodywidth = 0 # Без переноса строк

try:
    with open("input.html", "r", encoding="utf-8") as f:
        html_from_file = f.read()

    markdown_from_file = converter.handle(html_from_file)
    # Или просто: markdown_from_file = html2text.html2text(html_from_file)

    print("--- Markdown из файла input.html ---")
    print(markdown_from_file)

    with open("output.md", "w", encoding="utf-8") as f:
        f.write(markdown_from_file)
    print("\nРезультат сохранен в output.md")

except FileNotFoundError:
    print("Ошибка: Файл input.html не найден.")
```

После выполнения этого кода в файле `output.md` появится:

```markdown
Заголовок из файла
==================

Это содержимое файла, которое будет преобразовано.

  1. Первый нумерованный пункт
  2. Второй нумерованный пункт
```

### **Загрузка HTML из интернета (с использованием `requests`)**

Для получения HTML-кода веб-страницы часто используется библиотека `requests`. Если она у вас не установлена, сделайте это: `pip install requests`.

```python
import requests
import html2text

url = "https://example.com" # Используйте любой доступный URL

try:
    response = requests.get(url)
    response.raise_for_status()  # Проверка на ошибки HTTP (4xx или 5xx)
    html_from_web = response.text

    # Используем html2text с настройками по умолчанию
    markdown_from_web = html2text.html2text(html_from_web)

    print(f"--- Markdown со страницы {url} ---")
    print(markdown_from_web[:500] + "...") # Печатаем только начало для краткости

except requests.exceptions.RequestException as e:
    print(f"Ошибка при загрузке страницы: {e}")
except Exception as e:
    print(f"Произошла другая ошибка: {e}")
```

Этот скрипт загрузит HTML-код с `example.com` и преобразует его в Markdown.

---

## **5. Функции и методы модуля: Краткий обзор**

Основной функционал сосредоточен вокруг функции `html2text()` и класса `HTML2Text`.

*   **`html2text.html2text(html_string, baseurl='')`**:
    *   Это основная "быстрая" функция для конвертации.
    *   Принимает HTML-строку (`html_string`) и опциональный `baseurl` для разрешения относительных ссылок.
    *   Внутри она создает экземпляр `HTML2Text` с настройками по умолчанию и вызывает его метод `handle()`.
    *   Идеально подходит, когда настройки по умолчанию вас устраивают.

*   **Класс `html2text.HTML2Text(baseurl=None, bodywidth=None)`**:
    *   Конструктор класса. Позволяет инициализировать конвертер с базовыми настройками `baseurl` и `bodywidth`.
    *   Другие многочисленные параметры (см. таблицу выше) устанавливаются как атрибуты экземпляра *после* его создания: `h = HTML2Text(); h.ignore_links = True`.
    *   **Метод `handle(html_string)`**:
        *   Основной метод экземпляра `HTML2Text` для выполнения конвертации.
        *   Принимает HTML-строку и возвращает Markdown-строку, учитывая все настройки, установленные для данного экземпляра.
    *   **Метод `unescape(text_string)`**:
        *   Вспомогательный метод для декодирования HTML-сущностей (например, `&amp;` в `&`). Обычно вызывается внутри `handle()`.
    *   **Метод `feed(data)`**:
        *   Для потоковой обработки HTML. Позволяет передавать HTML по частям. После всех вызовов `feed()` нужно вызвать `close()` для получения результата. Менее распространенный сценарий использования.
    *   **Метод `close()`**:
        *   Завершает потоковую обработку и возвращает сконвертированный Markdown. Используется в паре с `feed()`.

---

## **6. Ограничения и альтернативы**

Несмотря на свою простоту и эффективность для многих задач, `html2text` имеет ограничения:

*   **Таблицы (`<table>`):** Конвертируются в упрощенный текст. Содержимое ячеек извлекается и располагается последовательно, но без использования Markdown-синтаксиса для таблиц (разделители `|` и `-`). Если параметр `ignore_tables` установлен в `True`, таблицы игнорируются полностью.
*   **Сложные CSS/JS-элементы:** Библиотека фокусируется на семантической структуре HTML и игнорирует стили CSS и поведение JavaScript. Контент, генерируемый JavaScript на стороне клиента, не будет доступен, если вы не используете инструменты вроде Selenium или Playwright для предварительного рендеринга страницы.
*   **Вложенные списки:** В некоторых случаях сложные или глубоко вложенные списки могут обрабатываться не идеально, приводя к потере структуры или некорректным отступам.
*   **Специфичные HTML-конструкции:** Нестандартные или очень сложные HTML-макеты могут привести к неоптимальному результату.

Если вам требуется более точная или продвинутая конвертация, особенно для таблиц или сохранения более сложной структуры, рассмотрите следующие альтернативы:

*   **`markdownify`**: Еще одна популярная Python-библиотека, часто обеспечивающая лучшую поддержку таблиц и более тонкую настройку. (Ссылка: [GitHub - matthewwithanm/python-markdownify](https://github.com/matthewwithanm/python-markdownify))
*   **`pandoc`**: Мощнейший универсальный конвертер документов, который можно вызывать из Python через `subprocess` или с помощью оберток вроде `pypandoc`. Pandoc поддерживает огромное количество форматов и имеет очень продвинутые возможности. (Ссылка: [Pandoc.org](https://pandoc.org/))

---

## **Итог**

Библиотека `html2text` — это превосходный выбор для быстрого и простого преобразования HTML в Markdown в Python. Её сильные стороны — это минимальные зависимости, легкость в освоении и достаточная гибкость для большинства повседневных задач по извлечению и форматированию текстового контента из HTML.

Она идеально подходит, когда вам нужно:

*   Быстро извлечь основной текст со страницы.
*   Конвертировать простые HTML-документы (статьи, посты) в Markdown.
*   Интегрировать базовую конвертацию HTML в ваши Python-скрипты без лишних сложностей.

Для более сложных сценариев, требующих точного воспроизведения таблиц или сохранения нюансов сложной верстки, стоит обратить внимание на более мощные инструменты, такие как `markdownify` или `pandoc`. Но для широкого круга задач `html2text` остается надежным и эффективным помощником.

**Дополнительные ссылки:**

*   [Официальная документация/репозиторий html2text на GitHub](https://github.com/Alir3z4/html2text)
*   [PyPI страница html2text](https://pypi.org/project/html2text/)
