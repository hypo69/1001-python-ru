# מחלקות ב-`python`

מחלקות הן אחד המנגנונים העיקריים של תכנות מונחה עצמים (OOP) בפייתון. ניתן לדמיין מחלקה כ"תבנית" או "שרטוט" ליצירת אובייקטים בעלי תכונות (נתונים) ושיטות (פונקציות). אובייקטים שנוצרו על בסיס מחלקה נקראים מופעים (אינסטנסים) של המחלקה. מחלקות מאפשרות לבנות את הקוד, לשפר את יכולת השימוש החוזר בו ולהקל על תחזוקתו.

### מבנה מחלקה

```python
class ClassName:
    # תכונות המחלקה
    def __init__(self, param1, param2):
        # בנאי (אתחול) המחלקה
        self.param1 = param1
        self.param2 = param2

    # שיטות המחלקה
    def method(self):
        return f'{self.param1} ו- {self.param2}'
```

1.  **בנאי** (`__init__`):
    הבנאי `__init__` הוא שיטה מיוחדת הנקראת אוטומטית בעת יצירת אובייקט חדש. הוא משמש לאתחול תכונות האובייקט.

    -   `self`: פרמטר המהווה הפניה למופע הנוכחי של המחלקה. בפייתון, חובה להעביר אותו כפרמטר הראשון בכל שיטות המחלקה (הוא אינו מועבר בעת קריאה לשיטה).
    -   תכונות, כגון `param1` ו-`param2`, מוקצות לאובייקט באמצעות `self`. תכונות אלו יכולות לשמש לאחר מכן שיטות אחרות של המחלקה.

2.  **תכונות המחלקה**:
    תכונות הן משתנים השייכים לאובייקטים של מחלקה זו. הן מוגדרות בתוך הבנאי (`__init__`) וניתן לגשת אליהן באמצעות הפניה לאובייקט.

3.  **שיטות המחלקה**:
    שיטות הן פונקציות שיכולות לתפעל את תכונות האובייקט. שיטות יכולות להשתמש בנתוני האובייקט, לשנות אותם או לבצע פעולות אחרות.

### יצירת אובייקט מחלקה

כאשר מחלקה מוגדרת, ניתן ליצור אובייקטים של מחלקה זו. אובייקטים הם מופעים של המחלקה.

```python
class Car:
    def __init__(self, make, model, year):
        self.make = make
        self.model = model
        self.year = year

    def description(self):
        return f'{self.year} {self.make} {self.model}'

# יצירת אובייקט
my_car = Car('Toyota', 'Corolla', 2020)
print(my_car.description())  # פלט: 2020 Toyota Corolla
```

-   בדוגמה זו, יצרנו אובייקט `my_car` מהמחלקה `Car`. בעת יצירת האובייקט, מועברים ערכים לתכונות `make`, `model` ו-`year`, הנשמרים באובייקט.
-   השיטה `description()` מאפשרת לקבל ייצוג מחרוזתי של המכונית.

### סוגי שיטות

1.  **שיטות מופע**: אלו הן שיטות רגילות הפועלות על מופעי המחלקה. הן מקבלות הפניה לאובייקט כפרמטר הראשון (בדרך כלל `self`).

    דוגמה:
    ```python
    def method(self):
        pass
    ```

2.  **שיטות מחלקה**: שיטות המקבלות את המחלקה עצמה כפרמטר הראשון. כדי להגדיר שיטות כאלה, משתמשים במעצב `@classmethod`. הן יכולות לשנות את מצב המחלקה עצמה, ולא מופעים בודדים שלה.

    דוגמה:
    ```python
    class MyClass:
        @classmethod
        def class_method(cls):
            pass
    ```

3.  **שיטות סטטיות**: אלו הן שיטות שאינן משתמשות ב-`self` או ב-`cls` (כלומר, אין להן גישה לא למופע ולא למחלקה). שיטות סטטיות מוכרזות באמצעות המעצב `@staticmethod`. הן יכולות להיות שימושיות כאשר שיטה אינה תלויה במצב האובייקט או המחלקה, אך קשורה ללוגיקה השייכת למחלקה.

    דוגמה:
    ```python
    class MyClass:
        @staticmethod
        def static_method():
            pass
    ```

### ירושה

אחד העקרונות המרכזיים של OOP הוא **ירושה**. מחלקה יכולה לרשת התנהגות ממחלקה אחרת, ולהרחיב או לשנות את הפונקציונליות שלה. זה מאפשר שימוש חוזר בקוד, תוך הימנעות מכפילויות.

```python
class Animal:
    def speak(self):
        return 'קול של חיה'

class Dog(Animal):  # המחלקה Dog יורשת מהמחלקה Animal
    def speak(self):
        return 'האו'

# יצירת אובייקטים
dog = Dog()
print(dog.speak())  # פלט: האו
```

-   המחלקה `Dog` יורשת את השיטה `speak` מהמחלקה `Animal`, אך דורסת אותה כדי להחזיר את המחרוזת `'האו'`.

### פולימורפיזם

**פולימורפיזם** פירושו היכולת של אובייקטים ממחלקות שונות להשתמש באותן שיטות עם מימושים שונים. בפייתון, זה אפשרי בזכות ירושה ודריסת שיטות.

```python
class Cat(Animal):
    def speak(self):
        return 'מיאו'

# יצירת אובייקטים
cat = Cat()
print(cat.speak())  # פלט: מיאו
```

כאן `Cat` גם דורסת את השיטה `speak`, אך מחזירה ערך אחר. זה מאפשר לקרוא לשיטה `speak` ללא תלות בסוג האובייקט.

### אנקפסולציה

**אנקפסולציה** מאפשרת להסתיר פרטי מימוש פנימיים ולספק גישה לנתונים באמצעות שיטות ציבוריות. זה עוזר למנוע שימוש שגוי בנתונים.

```python
class Car:
    def __init__(self, make, model):
        self._make = make  # תכונה מוגנת
        self._model = model

    def get_make(self):
        return self._make

    def set_make(self, make):
        self._make = make

# יצירת אובייקט
my_car = Car('Toyota', 'Corolla')
print(my_car.get_make())  # פלט: Toyota
my_car.set_make('Honda')
print(my_car.get_make())  # פלט: Honda
```

כאן התכונות `_make` ו-`_model` מוגנות (בדרך כלל בפייתון קו תחתון מציין שתכונות אלו לא אמורות לשמש ישירות מחוץ למחלקה), אך ניתן לגשת אליהן ולשנות אותן באמצעות השיטות `get_make` ו-`set_make`.

### תכונות נוספות של מחלקות

1.  **דסטרוקטור** (`__del__`):
    שיטה מיוחדת הנקראת כאשר אובייקט מושמד (לדוגמה, בעת יציאה מתחום ההיקף). ניתן להשתמש בה לשחרור משאבים.

    דוגמה:
    ```python
    class MyClass:
        def __del__(self):
            print("האובייקט הושמד")

    obj = MyClass()
    del obj  # האובייקט יושמד והשיטה __del__ תיקרא
    ```

2.  **שיטות קסם (Magic methods)**:
    אלו הן שיטות מיוחדות עם שני קווים תחתונים (לדוגמה, `__init__`, `__str__`, `__repr__`, `__eq__`). הן מאפשרות לדרוס התנהגות סטנדרטית של פעולות, כגון יצירת אובייקטים, השוואה, הצגת אובייקטים כטקסט וכו'.

    דוגמה:
    ```python
    class Point:
        def __init__(self, x, y):
            self.x = x
            self.y = y

        def __repr__(self):
            return f'Point({self.x}, {self.y})'

    p = Point(3, 4)
    print(p)  # פלט: Point(3, 4)
    ```

---

[לתוכן העניינים](https://github.com/hypo69/101_python_computer_games_ru/blob/master/cheat_sheets#readme)
