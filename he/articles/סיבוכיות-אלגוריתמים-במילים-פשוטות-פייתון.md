## סיבוכיות אלגוריתמים במילים פשוטות ודוגמאות בפייתון

בתכנות, קיימות דרכים רבות לפתור את אותה בעיה. עם זאת, לא כל הפתרונות יעילים באותה מידה. אחד ההיבטים המרכזיים שיש לקחת בחשבון בעת פיתוח אלגוריתמים הוא הסיבוכיות שלהם. הבנת סיבוכיות האלגוריתם מאפשרת להעריך כמה מהר הוא יפעל וכמה משאבים (לדוגמה, זיכרון) יידרשו לביצועו, במיוחד כאשר נפח נתוני הקלט גדל. הבנת סיבוכיות אלגוריתמים היא מיומנות בסיסית המאפשרת לכתוב קוד יעיל יותר.

### מהי סיבוכיות אלגוריתם?

תאר לעצמך שיש לך משימה: למצוא שם ספציפי בספר טלפונים.

*   **דרך פשוטה (חיפוש לינארי):** אתה לוקח את הספר ומתחיל לדפדף דף אחר דף עד שתמצא את השם הרצוי. אם השם נמצא בסוף הספר, תצטרך לדפדף בכל הספר!
*   **דרך חכמה (חיפוש בינארי):** אתה פותח את הספר באמצע. אם השם שאתה מחפש מופיע לפני השם בדף זה, אתה סוגר את החצי השני של הספר ומחפש בחצי הראשון. אם השם מופיע אחרי, אתה מחפש בחצי השני. וכך אתה חוזר על הפעולה עד שתמצא את השם הרצוי. בכל שלב, אתה זורק חצי מהספר!

**סיבוכיות אלגוריתם** – היא דרך לתאר כמה "זמן" (או משאבים, כמו זיכרון) יידרש לאלגוריתם כדי לבצע את משימתו, בהתאם למידת "גודל" המשימה.

*   **חיפוש לינארי:** אם בספר יש 10 עמודים, ייתכן שתצטרך לדפדף ב-10 עמודים. אם בספר יש 100 עמודים, ייתכן שתצטרך לדפדף ב-100 עמודים. כמות העבודה גדלה *לינארית* עם גודל המשימה. זה נקרא **O(n)**, כאשר 'n' הוא גודל המשימה (מספר העמודים בספר).

*   **חיפוש בינארי:** אם בספר יש 16 עמודים, תצטרך לכל היותר 4 צעדים כדי למצוא את השם. אם בספר יש 32 עמודים, תצטרך לכל היותר 5 צעדים. כמות העבודה גדלה הרבה יותר לאט מגודל המשימה. זה נקרא **O(log n)** (נקרא "או של לוג n").

*   אלגוריתם **O(n)** הופך איטי יותר *בפרופורציה ישרה* לגידול בגודל המשימה.
*   אלגוריתם **O(log n)** הופך איטי יותר *הרבה יותר לאט* מגידול בגודל המשימה.

תאר לעצמך שאתה מפתח מנוע חיפוש. אם תשתמש באלגוריתם O(n) לחיפוש באינטרנט (המכיל מיליארדי דפי אינטרנט), זה ייקח זמן רב להפליא! ואלגוריתם O(log n) יטפל במשימה זו הרבה יותר מהר.

### סוגים עיקריים של סיבוכיות אלגוריתמים

להלן כמה מהסוגים הנפוצים ביותר של סיבוכיות:

*   **O(1) – סיבוכיות קבועה:** זמן הריצה תמיד זהה, ללא קשר לגודל המשימה. לדוגמה, קבלת האלמנט הראשון מרשימה.

    ```python
    def get_first_element(my_list):
        """O(1) - קבלת האלמנט הראשון ברשימה."""
        return my_list[0]
    ```

*   **O(log n) – סיבוכיות לוגריתמית:** זמן הריצה גדל לאט מאוד עם גידול בגודל המשימה. דוגמה מצוינת היא חיפוש בינארי.

    ```python
    def binary_search(my_list, target):
        """O(log n) - חיפוש בינארי ברשימה ממוינת."""
        low = 0
        high = len(my_list) - 1

        while low <= high:
            mid = (low + high) // 2
            if my_list[mid] == target:
                return mid
            elif my_list[mid] < target:
                low = mid + 1
            else:
                high = mid - 1
        return -1  # האלמנט לא נמצא
    ```

*   **O(n) – סיבוכיות לינארית:** זמן הריצה גדל בפרופורציה ישרה לגודל המשימה. לדוגמה, מעבר על כל אלמנט ברשימה.

    ```python
    def linear_search(my_list, target):
        """O(n) - חיפוש לינארי ברשימה."""
        for i in range(len(my_list)):
            if my_list[i] == target:
                return i
        return -1  # האלמנט לא נמצא
    ```

*   **O(n log n) – סיבוכיות לינארית-לוגריתמית:** נפוץ באלגוריתמי מיון יעילים, כגון מיון מיזוג ומיון מהיר.

    ```python
    def merge_sort(my_list):
        """O(n log n) - מיון מיזוג."""
        if len(my_list) <= 1:
            return my_list

        mid = len(my_list) // 2
        left = merge_sort(my_list[:mid])
        right = merge_sort(my_list[mid:])

        return merge(left, right)

    def merge(left, right):
        """פונקציית עזר עבור merge_sort."""
        merged = []
        i = j = 0

        while i < len(left) and j < len(right):
            if left[i] <= right[j]:
                merged.append(left[i])
                i += 1
            else:
                merged.append(right[j])
                j += 1

        merged.extend(left[i:])
        merged.extend(right[j:])
        return merged
    ```

*   **O(n^2) – סיבוכיות ריבועית:** זמן הריצה גדל *בריבוע* של גודל המשימה. לדוגמה, השוואת כל אלמנט ברשימה לכל אלמנט אחר באותה רשימה.

    ```python
    def bubble_sort(my_list):
        """O(n^2) - מיון בועות."""
        n = len(my_list)
        for i in range(n):
            for j in range(0, n-i-1):
                if my_list[j] > my_list[j+1] :
                    my_list[j], my_list[j+1] = my_list[j+1], my_list[j]
    ```

*   **O(2^n) – סיבוכיות אקספוננציאלית:** זמן הריצה גדל במהירות רבה עם גידול בגודל המשימה. נפוץ באלגוריתמים המשתמשים בכוח גס.

    ```python
    def fibonacci_recursive(n):
      """O(2^n) - חישוב רקורסיבי של מספר פיבונאצ'י."""
      if n <= 1:
          return n
      return fibonacci_recursive(n-1) + fibonacci_recursive(n-2)
    ```

*   **O(n!) – סיבוכיות עצרתית:** סוג הסיבוכיות האיטי ביותר. מתרחש בעת מעבר על כל התמורות האפשריות של אלמנטים.

### דוגמאות לבעיות ואלגוריתמים עם סיבוכיות שונה

בואו נסתכל על כמה דוגמאות לבעיות ואלגוריתמים שונים לפתרונן, כדי לראות
כיצד הסיבוכיות משפיעה על הביצועים.

**1. מיון רשימה:**

*   **משימה:** למיין רשימת אלמנטים בסדר מסוים (לדוגמה, בסדר עולה).
*   **אלגוריתמים:**
    *   **מיון בועות (Bubble Sort):**

        ```python
        def bubble_sort(my_list):
            n = len(my_list)
            for i in range(n):
                for j in range(0, n-i-1):
                    if my_list[j] > my_list[j+1] :
                        my_list[j], my_list[j+1] = my_list[j+1], my_list[j]
        # דוגמה לשימוש
        my_list = [64, 34, 25, 12, 22, 11, 90]
        bubble_sort(my_list)
        print("מערך ממוין:", my_list) # פלט: [11, 12, 22, 25, 34, 64, 90]
        ```

    *   **מיון מיזוג (Merge Sort):**

        ```python
        def merge_sort(my_list):
            if len(my_list) <= 1:
                return my_list

            mid = len(my_list) // 2
            left = merge_sort(my_list[:mid])
            right = merge_sort(my_list[mid:])

            return merge(left, right)

        def merge(left, right):
            merged = []
            i = j = 0

            while i < len(left) and j < len(right):
                if left[i] <= right[j]:
                    merged.append(left[i])
                    i += 1
                else:
                    merged.append(right[j])
                    j += 1

            merged.extend(left[i:])
            merged.extend(right[j:])
            return merged

        # דוגמה לשימוש
        my_list = [64, 34, 25, 12, 22, 11, 90]
        sorted_list = merge_sort(my_list)
        print("מערך ממוין:", sorted_list) # פלט: [11, 12, 22, 25, 34, 64, 90]
        ```
*   **מסקנה:** עבור רשימות גדולות של אלמנטים, אלגוריתמים עם O(n log n) (מיון מיזוג) עדיפים על אלגוריתמים עם O(n^2) (מיון בועות).

**2. מציאת המסלול הקצר ביותר בגרף:**

*   **משימה:** למצוא את המסלול הקצר ביותר בין שני צמתים בגרף (לדוגמה, בין שתי ערים על מפה).
*   **אלגוריתמים:**
    *   **אלגוריתם דייקסטרה (Dijkstra's Algorithm):**

        ```python
        import heapq

        def dijkstra(graph, start):
            """אלגוריתם דייקסטרה למציאת המסלולים הקצרים ביותר."""
            distances = {node: float('inf') for node in graph}
            distances[start] = 0
            priority_queue = [(0, start)]  # (מרחק, צומת)

            while priority_queue:
                distance, node = heapq.heappop(priority_queue)

                if distance > distances[node]:
                    continue

                for neighbor, weight in graph[node].items():
                    new_distance = distance + weight
                    if new_distance < distances[neighbor]:
                        distances[neighbor] = new_distance
                        heapq.heappush(priority_queue, (new_distance, neighbor))

            return distances

        # דוגמה לשימוש
        graph = {
            'A': {'B': 5, 'C': 1},
            'B': {'A': 5, 'C': 2, 'D': 1},
            'C': {'A': 1, 'B': 2, 'D': 4, 'E': 8},
            'D': {'B': 1, 'C': 4, 'E': 3, 'F': 6},
            'E': {'C': 8, 'D': 3},
            'F': {'D': 6}
        }
        start_node = 'A'
        shortest_paths = dijkstra(graph, start_node)
        print(f"המסלולים הקצרים ביותר מ-{start_node}: {shortest_paths}")
        ```

*   **מסקנה:** בחירת האלגוריתם תלויה בסוג הגרף (משוקלל/לא משוקלל, נוכחות משקלים שליליים) ובגודל הגרף. אלגוריתם דייקסטרה יעיל עבור גרפים עם משקלים לא שליליים.

**3. חיפוש תת-מחרוזת במחרוזת:**

*   **משימה:** למצוא את כל המופעים של תת-מחרוזת ספציפית במחרוזת גדולה יותר.
*   **אלגוריתמים:**
    *   **חיפוש מחרוזות נאיבי (Naive String Search):**

        ```python
        def naive_string_search(text, pattern):
            """אלגוריתם חיפוש תת-מחרוזת נאיבי."""
            occurrences = []
            for i in range(len(text) - len(pattern) + 1):
                if text[i:i+len(pattern)] == pattern:
                    occurrences.append(i)
            return occurrences

        # דוגמה לשימוש
        text = "This is a simple example text."
        pattern = "example"
        occurrences = naive_string_search(text, pattern)
        print(f"מופעים של '{pattern}' בטקסט: {occurrences}")  # פלט: [17]
        ```

*   **מסקנה:** עבור חיפושי תת-מחרוזות תכופים במחרוזות גדולות, קיימים אלגוריתמים יעילים יותר, כגון KMP.

**4. בעיית התרמיל (Knapsack Problem):**

*   **משימה:** יש לך תרמיל בקיבולת מסוימת וקבוצת פריטים עם משקלים וערכים שונים. עליך לבחור פריטים שימקסמו את הערך הכולל, מבלי לחרוג מקיבולת התרמיל.
*   **אלגוריתמים:**
    *   **תכנות דינמי (Dynamic Programming):**

        ```python
        def knapsack_dynamic_programming(capacity, weights, values, n):
            """פתרון בעיית התרמיל בשיטת תכנות דינמי."""
            dp = [[0 for x in range(capacity + 1)] for x in range(n + 1)]

            for i in range(n + 1):
                for w in range(capacity + 1):
                    if i == 0 or w == 0:
                        dp[i][w] = 0
                    elif weights[i-1] <= w:
                        dp[i][w] = max(values[i-1] + dp[i-1][w-weights[i-1]],  dp[i-1][w])
                    else:
                        dp[i][w] = dp[i-1][w]

            return dp[n][capacity]

        # דוגמה לשימוש
        capacity = 50
        weights = [10, 20, 30]
        values = [60, 100, 120]
        n = len(values)
        max_value = knapsack_dynamic_programming(capacity, weights, values, n)
        print(f"ערך מקסימלי: {max_value}")  # פלט: 220
        ```

*   **בחירת האלגוריתם תלויה בגודל הבעיה ובדרישות לדיוק הפתרון.**

### סימון O: פישוט הסיבוכיות

בדרך כלל, סיבוכיות מתוארת באמצעות "סימון O גדול" (O-notation). הוא מראה כמה מהר זמן הריצה של האלגוריתם גדל עם גידול בגודל המשימה, *אסימפטוטית*, כלומר, עבור ערכים גדולים מאוד של `n`. קבועים קטנים ופרטי מימוש בדרך כלל מתעלמים. לדוגמה, אלגוריתם שמבצע `2n + 5` פעולות עדיין נחשב *O(n)*.

### מקרה הגרוע ביותר, מקרה ממוצע, מקרה הטוב ביותר

סיבוכיות אלגוריתם יכולה להיות תלויה בנתוני הקלט. בדרך כלל מדברים על סיבוכיות *במקרה הגרוע ביותר* – זוהי הכמות המקסימלית של זמן או משאבים שאלגוריתם עשוי לדרוש. לעיתים מנתחים גם את הסיבוכיות במקרה הממוצע ובמקרה הטוב ביותר.