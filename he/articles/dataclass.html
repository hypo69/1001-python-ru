<h2 dir="rtl">Dataclasses: <span dir="ltr">כשפייתון</span> פוגש נתונים מובנים (עם דוגמאות חדשות בשמות)</h2>
<p dir="rtl">בפייתון, כאשר אתה זקוק למחלקה לאחסון נתונים, בדרך כלל עליך לכתוב קוד <span dir="ltr">boilerplate</span> עבור <span dir="ltr"><code>__init__</code></span>, <span dir="ltr"><code>__repr__</code></span>, <span dir="ltr"><code>__eq__</code></span> ושיטות קסם אחרות. מודול <span dir="ltr"><code>dataclasses</code></span>, שהופיע בפייתון <span dir="ltr">3.7</span>, נועד לפתור בעיה זו על ידי מתן דקורטור <span dir="ltr"><code>@dataclass</code></span> שמייצר אוטומטית שיטות אלו עבורך.</p>
<h3 dir="rtl">מה זה <span dir="ltr">Dataclass</span>?</h3>
<p dir="rtl"><span dir="ltr"><code>dataclass</code></span> היא מחלקה, שכפי שהשם מרמז, מיועדת בעיקר לאחסון נתונים. היא מספקת את היתרונות המרכזיים הבאים:</p>
<ul dir="rtl">
<li><strong>פחות קוד <span dir="ltr">boilerplate</span>:</strong> מייצרת אוטומטית <span dir="ltr"><code>__init__</code></span>, <span dir="ltr"><code>__repr__</code></span>, <span dir="ltr"><code>__eq__</code></span>, <span dir="ltr"><code>__hash__</code></span> (בתנאים מסוימים) ושיטות אחרות בהתבסס על הערות הסוג של השדות שלך.</li>
<li><strong>קריאות:</strong> הקוד הופך תמציתי יותר וממוקד בהגדרת מבנה הנתונים.</li>
<li><strong>אינטרוספקציה:</strong> שדות <span dir="ltr">Dataclass</span> קלים לאינטרוספקציה (בדיקה) באמצעות פונקציות מאותו מודול <span dir="ltr"><code>dataclasses</code></span>.</li>
<li><strong>ביצועים (עם <span dir="ltr"><code>slots=True</code></span>):</strong> יכולה לצרוך פחות זיכרון ולהיות מהירה יותר בגישה לתכונות.</li>
</ul>
<h3 dir="rtl">שימוש בסיסי</h3>
<p dir="rtl">נתחיל בדוגמה פשוטה. נניח שאנו זקוקים למחלקה שתייצג נקודה במרחב דו-ממדי.</p>
<pre class="line-numbers"><code class="language-python">from dataclasses import dataclass

@dataclass
class Point:
    x: int
    y: int

# יצירת מופע
p1 = Point(10, 20)
print(p1) # Point(x=10, y=20) - __repr__ שנוצר אוטומטית

# השוואת מופעים - __eq__ שנוצר אוטומטית
p2 = Point(10, 20)
p3 = Point(30, 40)
print(p1 == p2) # True
print(p1 == p3) # False
</code></pre>
<p dir="rtl">כפי שאתה יכול לראות, לא היינו צריכים לכתוב <span dir="ltr"><code>__init__</code></span> או <span dir="ltr"><code>__repr__</code></span>. הכל עבד "מהקופסה".</p>
<h3 dir="rtl">פרמטרים של הדקורטור <span dir="ltr"><code>@dataclass</code></span></h3>
<p dir="rtl">הדקורטור <span dir="ltr"><code>@dataclass</code></span> מקבל מספר פרמטרים המאפשרים לך להתאים אישית את ההתנהגות שנוצרה.</p>
<pre class="line-numbers"><code class="language-python">@dataclass(
    init=True,         # האם ליצור __init__ (ברירת מחדל True)
    repr=True,         # האם ליצור __repr__ (ברירת מחדל True)
    eq=True,           # האם ליצור __eq__ (ברירת מחדל True)
    order=False,       # האם ליצור __lt__, __le__, __gt__, __ge__ (ברירת מחדל False)
    unsafe_hash=False, # האם ליצור __hash__ (ברירת מחדל False)
    frozen=False,      # האם להפוך מופעים לבלתי ניתנים לשינוי (ברירת מחדל False)
    match_args=True,   # האם לכלול את המחלקה במנגנון התאמת התבניות המבנית (Python 3.10+, ברירת מחדל True)
    kw_only=False,     # האם להפוך את כל השדות לארגומנטים של מילות מפתח בלבד ב- __init__ (Python 3.10+, ברירת מחדל False)
    slots=False        # האם להשתמש ב- __slots__ כדי לחסוך בזיכרון (Python 3.10+, ברירת מחדל False)
)
class MyDataClass:
    # ...
</code></pre>
<p dir="rtl">בואו נבחן את החשובים שבהם, כולל אלה שהיו בבקשתך:</p>
<h4 dir="rtl"><span dir="ltr"><code>init=True</code></span> (ברירת מחדל)</h4>
<p dir="rtl">אם <span dir="ltr"><code>True</code></span>, אז <span dir="ltr"><code>dataclass</code></span> תיצור את שיטת <span dir="ltr"><code>__init__</code></span>. אם יש לך <span dir="ltr"><code>__init__</code></span> משלך, ואתה משאיר <span dir="ltr"><code>init=True</code></span>, אז <span dir="ltr"><code>__init__</code></span> שלך יקרא, אך השדות שהוגדרו ב-<span dir="ltr">dataclass</span> לא יאותחלו דרכו אוטומטית. בדרך כלל, אם אתה כותב <span dir="ltr"><code>__init__</code></span> משלך, אתה מגדיר <span dir="ltr"><code>init=False</code></span> כדי למנוע התנגשויות ולקבל שליטה מלאה על האתחול.</p>
<pre class="line-numbers"><code class="language-python">@dataclass(init=False)
class CustomPersonInit:
    name: str
    age: int

    def __init__(self, name: str, age: int, welcome_message: str = "שלום!"):
        self.name = name
        self.age = age
        print(welcome_message)

alice = CustomPersonInit("אליס", 30) # מדפיס "שלום!"
print(alice) # CustomPersonInit(name='אליס', age=30) - repr עדיין עובד
</code></pre>
<h4 dir="rtl"><span dir="ltr"><code>repr=True</code></span> (ברירת מחדל)</h4>
<p dir="rtl">אם <span dir="ltr"><code>True</code></span>, היא תיצור שיטת <span dir="ltr"><code>__repr__</code></span> המספקת ייצוג מחרוזת נוח של האובייקט, שימושי לניפוי באגים.</p>
<h4 dir="rtl"><span dir="ltr"><code>eq=True</code></span> (ברירת מחדל)</h4>
<p dir="rtl">אם <span dir="ltr"><code>True</code></span>, היא תיצור שיטת <span dir="ltr"><code>__eq__</code></span> המאפשרת לך להשוות שני מופעים של מחלקה לשוויון על ידי בדיקת שוויון כל השדות שלהם.</p>
<h4 dir="rtl"><span dir="ltr"><code>order=False</code></span></h4>
<p dir="rtl">אם <span dir="ltr"><code>True</code></span>, אז <span dir="ltr"><code>dataclass</code></span> תיצור את שיטות <span dir="ltr"><code>__lt__</code></span>, <span dir="ltr"><code>__le__</code></span>, <span dir="ltr"><code>__gt__</code></span>, <span dir="ltr"><code>__ge__</code></span>. זה מאפשר לך להשוות מופעים עבור "פחות מ", "גדול מ", וכו'. ההשוואה נעשית לפי סדר הצהרת השדות. כדי ש-<span dir="ltr"><code>order=True</code></span> יעבוד, <span dir="ltr"><code>eq=True</code></span> חייב להיות מוגדר גם כן.</p>
<pre class="line-numbers"><code class="language-python">@dataclass(order=True)
class Person:
    name: str
    age: int

alice = Person("אליס", 30)
boris = Person("בוריס", 25)
victor = Person("ויקטור", 35) # נוסיף את ויקטור
galina = Person("גלינה", 30)
alice_older = Person("אליס", 35)


print(f"אליס ({alice.age}) > בוריס ({boris.age})? {alice > boris}") # False (מכיוון ש-'אליס' < 'בוריס' לפי שם) -> ההשוואה נעשית לקסיקוגרפית על הטופל (שם, גיל). ('אליס', 30) < ('בוריס', 25) זה True. אז `>` יהיה False.
# הסבר: ('אליס', 30) > ('בוריס', 25) -> False, מכיוון ש-'אליס' < 'בוריס'.
print(f"אליס ({alice.age}) < אליס_מבוגרת ({alice_older.age})? {alice < alice_older}") # True (מכיוון שהשם זהה, אך הגיל 30 < 35)
print(f"גלינה ({galina.age}) == אליס ({alice.age})? {galina == alice}") # False (שמות שונים)
</code></pre>
<p dir="rtl"><strong>הערה חשובה:</strong> סדר השדות חשוב עבור <span dir="ltr"><code>order=True</code></span>.</p>
<h4 dir="rtl"><span dir="ltr"><code>unsafe_hash=False</code></span></h4>
<p dir="rtl">אם <span dir="ltr"><code>True</code></span>, היא תיצור שיטת <span dir="ltr"><code>__hash__</code></span>. <span dir="ltr">Dataclasses</span> אינן ניתנות לגיבוב כברירת מחדל אם הן ניתנות לשינוי (<span dir="ltr"><code>frozen=False</code></span>), מכיוון שאובייקטים ניתנים לגיבוב חייבים להיות בלתי ניתנים לשינוי. אם אתה בטוח שה-<span dir="ltr">dataclass</span> הניתנת לשינוי שלך תשמש רק בהקשרים שבהם הגיבוב שלה לא ישתנה (וזה מסוכן!), תוכל להגדיר <span dir="ltr"><code>unsafe_hash=True</code></span>.
לרוב, <span dir="ltr"><code>__hash__</code></span> נוצר אוטומטית אם:</p>
<ol dir="rtl">
<li><span dir="ltr"><code>frozen=True</code></span>.</li>
<li><span dir="ltr"><code>frozen=False</code></span>, אך <span dir="ltr"><code>eq=True</code></span> וכל השדות ניתנים לגיבוב גם כן.</li>
</ol>
<pre class="line-numbers"><code class="language-python">@dataclass(frozen=True) # Dataclasses קפואות ניתנות לגיבוב
class ImmutablePoint:
    x: int
    y: int

p = ImmutablePoint(1, 2)
print(hash(p)) # עובד

@dataclass(unsafe_hash=True) # מסוכן אם האובייקט ניתן לשינוי
class MutableButHashable:
    value: int

m = MutableButHashable(5)
print(hash(m))
m.value = 10
print(hash(m)) # הגיבוב השתנה, מה שעלול להוביל לבעיות בשימוש ב-set/dict
</code></pre>
<h4 dir="rtl"><span dir="ltr"><code>frozen=False</code></span></h4>
<p dir="rtl">אם <span dir="ltr"><code>True</code></span>, מופעי המחלקה הופכים לבלתי ניתנים לשינוי. לאחר יצירת אובייקט, לא תוכל לשנות את ערכי השדות שלו. זה שימושי ליצירת אובייקטים בלתי ניתנים לשינוי שקל יותר להשתמש בהם ביישומים מרובי-תהליכים או כמפתחות מילון (אם הם ניתנים לגיבוב).</p>
<pre class="line-numbers"><code class="language-python">@dataclass(frozen=True)
class Coordinate:
    lat: float
    lon: float

c = Coordinate(10.0, 20.0)
# c.lat = 15.0 # AttributeError: cannot assign to field 'lat'
</code></pre>
<h4 dir="rtl"><span dir="ltr"><code>kw_only=False</code></span> (פייתון <span dir="ltr">3.10+</span>)</h4>
<p dir="rtl">אם <span dir="ltr"><code>True</code></span>, <strong>כל</strong> השדות ב-<span dir="ltr"><code>__init__</code></span> הופכים לארגומנטים של <strong>מילות מפתח בלבד</strong>. המשמעות היא שעליך להעביר את ערכי השדות לפי שם, ולא לפי מיקום. זה משפר את הקריאות ומונע שגיאות, במיוחד כאשר למחלקה יש שדות רבים או שהם עשויים להיות מאותם סוגים.</p>
<pre class="line-numbers"><code class="language-python">@dataclass(kw_only=True)
class UserConfig:
    username: str
    email: str
    is_active: bool = True
    theme: str = "dark"

# user1 = UserConfig("אליס_איבנובה", "alice@example.com") # TypeError: __init__() takes 0 positional arguments but 3 were given
user1 = UserConfig(username="אליס_איבנובה", email="alice@example.com")
print(user1)

# ניתן לעקוף התנהגות זו עבור שדה ספציפי באמצעות field(kw_only=False)
@dataclass(kw_only=True)
class MixedConfig:
    # חובה מיקום בלבד (לא בסגנון dataclass)
    # השדה `id` לא יהיה kw_only, למרות שהמחלקה מוגדרת כ-kw_only=True
    id: int = field(kw_only=False)
    name: str = field(kw_only=False)

    # השדות הנותרים הם kw_only
    email: str
    age: int = 0

# שימו לב ש-id ו-name מועברים לפי מיקום, ו-email מועבר לפי שם
mixed_config = MixedConfig(123, "בוריס", email="boris@example.com")
print(mixed_config)
# mixed_config_fail = MixedConfig(id=123, name="ויקטור", email="viktor@example.com") # שגיאה, id ו-name יהיו מיקומיים
# תרחיש זה פחות טיפוסי, kw_only מיושם בדרך כלל על כל המחלקה
</code></pre>
<p dir="rtl"><strong>הערה:</strong> <span dir="ltr"><code>field(kw_only=False)</code></span> על שדה עוקף את <span dir="ltr"><code>kw_only=True</code></span> ברמת המחלקה, והופך את השדה הספציפי הזה למיקומי. עם זאת, לרוב, <span dir="ltr"><code>kw_only=True</code></span> משמש עבור כל המחלקה. השימוש העיקרי ב-<span dir="ltr"><code>field(kw_only=True)</code></span> הוא כאשר יש לך <span dir="ltr">dataclass</span> רגיל (ברירת מחדל <span dir="ltr"><code>kw_only=False</code></span>), אך אתה רוצה להפוך *חלק* מהשדות למילות מפתח בלבד.</p>
<h4 dir="rtl"><span dir="ltr"><code>slots=False</code></span> (פייתון <span dir="ltr">3.10+</span>)</h4>
<p dir="rtl">אם <span dir="ltr"><code>True</code></span>, <span dir="ltr"><code>dataclass</code></span> תיצור <span dir="ltr"><code>__slots__</code></span> עבור המחלקה שלך. <span dir="ltr"><code>__slots__</code></span> הוא תכונה מיוחדת המאפשרת לפייתון להקצות כמות קבועה של זיכרון עבור מופעי מחלקה, במקום להשתמש במילון דינמי <span dir="ltr"><code>__dict__</code></span> לאחסון תכונות.</p>
<p dir="rtl"><strong>יתרונות של <span dir="ltr"><code>slots=True</code></span>:</strong></p>
<ul dir="rtl">
<li><strong>חיסכון בזיכרון:</strong> מפחית משמעותית את כמות הזיכרון הנצרכת על ידי כל מופע. זה חשוב במיוחד עבור יישומים היוצרים מיליוני אובייקטים.</li>
<li><strong>גישה מהירה יותר לתכונות:</strong> גישה לתכונות באמצעות <span dir="ltr"><code>__slots__</code></span> יכולה להיות מעט מהירה יותר, מכיוון שפייתון לא צריך לחפש אותן במילון.</li>
</ul>
<p dir="rtl"><strong>חסרונות של <span dir="ltr"><code>slots=True</code></span>:</strong></p>
<ul dir="rtl">
<li><strong>לא ניתן להוסיף תכונות חדשות "בזמן אמת":</strong> לא תוכל להקצות תכונה שלא הוכרזה ב-<span dir="ltr">dataclass</span> (או ב-<span dir="ltr"><code>__slots__</code></span> של מחלקת אב).</li>
<li><strong>קשיים עם ירושה מרובה:</strong> ייתכן שיהיה קשה להשתמש ב-<span dir="ltr"><code>__slots__</code></span> עם ירושה מרובה, במיוחד אם חלק ממחלקות האב אינן משתמשות ב-<span dir="ltr"><code>__slots__</code></span> או משתמשות בהן באופן שונה.</li>
<li><strong>אין <span dir="ltr"><code>__dict__</code></span>:</strong> למופעים לא תהיה תכונת <span dir="ltr"><code>__dict__</code></span> אלא אם כן היא נוספה במפורש ל-<span dir="ltr"><code>__slots__</code></span> או למחלקת אב.</li>
</ul>
<pre class="line-numbers"><code class="language-python">import sys

@dataclass
class RegularPoint:
    x: int
    y: int

@dataclass(slots=True)
class SlottedPoint:
    x: int
    y: int

rp = RegularPoint(1, 2)
sp = SlottedPoint(1, 2)

print(f"גודל RegularPoint: {sys.getsizeof(rp)} בתים")
# בערך 56 בתים בפייתון 3.10+ (עשוי להשתנות)
# print(rp.__dict__) # {'x': 1, 'y': 2} - יש לו __dict__

print(f"גודל SlottedPoint: {sys.getsizeof(sp)} בתים")
# בערך 32 בתים בפייתון 3.10+ (עשוי להשתנות) - קטן משמעותית
# print(sp.__dict__) # AttributeError: 'SlottedPoint' object has no attribute '__dict__'

# ניסיון להוסיף תכונה חדשה ל-dataclass עם slots
try:
    sp.z = 30
except AttributeError as e:
    print(f"שגיאה בעת הוספת תכונה חדשה: {e}")
</code></pre>
<p dir="rtl"><strong>מתי להשתמש ב-<span dir="ltr"><code>slots=True</code></span>?</strong>
כאשר אתה יוצר מספר גדול מאוד של מופעים מאותה מחלקה, וחיסכון בזיכרון הוא בראש סדר העדיפויות. זוהי אופטימיזציה מצוינת, אך יש לה פשרות.</p>
<h3 dir="rtl">הפונקציה <span dir="ltr"><code>field()</code></span>: תצורת שדה מפורטת</h3>
<p dir="rtl">בנוסף לפרמטרים ברמת המחלקה, תוכל להגדיר כל שדה בנפרד באמצעות הפונקציה <span dir="ltr"><code>field()</code></span> ממודול <span dir="ltr"><code>dataclasses</code></span>. זה שימושי במיוחד כאשר אתה זקוק ללוגיקה מורכבת יותר עבור שדות מאשר רק הערת סוג.</p>
<pre class="line-numbers"><code class="language-python">from dataclasses import dataclass, field
from typing import List, Dict, Any
import uuid # ליצירת מזהים

@dataclass
class Product:
    id: str = field(default_factory=lambda: "prod-" + str(uuid.uuid4())[:8], init=False) # לא מאותחל דרך __init__, נוצר אוטומטית
    name: str
    price: float = field(compare=False, metadata={'unit': 'USD', 'min_value': 0.0}) # לא משתתף בהשוואה, יש לו מטא נתונים
    tags: List[str] = field(default_factory=list, repr=False) # משתמש במפעל לרשימה, לא מוצג ב-repr
    description: str = field(default="אין תיאור זמין") # ערך ברירת מחדל רגיל
    details: Dict[str, Any] = field(default_factory=dict, hash=False) # לא משתתף בגיבוב

p = Product(name="מחשב נייד", price=1200.0, tags=["אלקטרוניקה", "טכנולוגיה"])
print(p)
# Product(id='prod-...', name='מחשב נייד', price=1200.0, description='אין תיאור זמין', details={})
# שימו לב ש-'tags' אינו ב-repr, ו-'id' נוצר אוטומטית.

p2 = Product(name="מחשב נייד", price=1500.0, tags=["אלקטרוניקה", "טכנולוגיה"])
print(f"p == p2? {p == p2}") # True, מכיוון שהמחיר אינו משתתף בהשוואה (compare=False)

# p3 = Product(name="מחשב שולחני", price=1000.0, details={"cpu": "Intel"})
# print(hash(p3)) # TypeError: unhashable type: 'dict' (בגלל details: hash=False)
# אם frozen=True, ו-details לא היו hash=False, אז ה-dict היה צריך להיות בלתי ניתן לשינוי.
</code></pre>
<p dir="rtl">בואו נבחן את הפרמטרים של <span dir="ltr"><code>field()</code></span>:</p>
<ul dir="rtl">
<li><strong><span dir="ltr"><code>default</code></span></strong>: ערך ברירת מחדל רגיל עבור השדה.
<pre class="line-numbers"><code class="language-python">value: int = field(default=0)
</code></pre>
</li>
<li><strong><span dir="ltr"><code>default_factory</code></span></strong>: פונקציה ללא ארגומנטים שתקרא כדי לקבל את ערך ברירת המחדל עבור השדה. <strong>הקפד להשתמש ב-<span dir="ltr"><code>default_factory</code></span> עבור ערכי ברירת מחדל ניתנים לשינוי (רשימות, מילונים, אובייקטים) כדי למנוע בעיות עם מצב משותף בין מופעים!</strong>
<pre class="line-numbers"><code class="language-python">items: List[str] = field(default_factory=list)
</code></pre>
</li>
<li><strong><span dir="ltr"><code>init</code></span></strong>: אם <span dir="ltr"><code>True</code></span> (ברירת מחדל), השדה ייכלל בשיטת <span dir="ltr"><code>__init__</code></span> שנוצרה. אם <span dir="ltr"><code>False</code></span>, השדה לא יהיה ארגומנט בבנאי, ועליך לספק עבורו <span dir="ltr"><code>default</code></span> / <span dir="ltr"><code>default_factory</code></span>, או לאתחל אותו ב-<span dir="ltr"><code>__post_init__</code></span>.
<pre class="line-numbers"><code class="language-python">import time
timestamp: float = field(init=False, default_factory=time.time)
</code></pre>
</li>
<li><strong><span dir="ltr"><code>repr</code></span></strong>: אם <span dir="ltr"><code>True</code></span> (ברירת מחדל), השדה ייכלל בשיטת <span dir="ltr"><code>__repr__</code></span> שנוצרה. שימושי להסתרת נתונים גדולים או רגישים.
<pre class="line-numbers"><code class="language-python">password: str = field(repr=False)
</code></pre>
</li>
<li><strong><span dir="ltr"><code>compare</code></span></strong>: אם <span dir="ltr"><code>True</code></span> (ברירת מחדל), השדה ייכלל בשיטות <span dir="ltr"><code>__eq__</code></span> ו-<span dir="ltr"><code>__order__</code></span> שנוצרו. אם <span dir="ltr"><code>False</code></span>, הוא לא ישפיע על השוואת אובייקטים.
<pre class="line-numbers"><code class="language-python">version: str = field(compare=False)
</code></pre>
</li>
<li><strong><span dir="ltr"><code>hash</code></span></strong>: אם <span dir="ltr"><code>True</code></span> (ברירת מחדל), השדה ייכלל בשיטת <span dir="ltr"><code>__hash__</code></span> שנוצרה. אם <span dir="ltr"><code>False</code></span>, הוא לא ישפיע על גיבוב האובייקט. אם המחלקה היא <span dir="ltr"><code>frozen=True</code></span>, אך לשדה כלשהו יש <span dir="ltr"><code>hash=False</code></span>, אז המחלקה לא תוכל ליצור את ה-<span dir="ltr"><code>__hash__</code></span> שלה ותהפוך לבלתי ניתנת לגיבוב.
<pre class="line-numbers"><code class="language-python">config: Dict[str, Any] = field(hash=False, default_factory=dict)
</code></pre>
</li>
<li><strong><span dir="ltr"><code>metadata</code></span></strong>: מילון לאחסון נתונים שרירותיים המשויכים לשדה. <span dir="ltr"><code>dataclasses</code></span> מתעלמים מנתונים אלה, אך הם יכולים לשמש כלים חיצוניים (לדוגמה, לאימות, סריאליזציה, יצירת תיעוד).
<pre class="line-numbers"><code class="language-python">user_id: int = field(metadata={'help': 'מזהה משתמש ייחודי', 'validator': 'positive_int'})
</code></pre>
</li>
<li><strong><span dir="ltr"><code>kw_only</code></span></strong>: (פייתון <span dir="ltr">3.10+</span>) אם <span dir="ltr"><code>True</code></span>, שדה ספציפי זה הופך לארגומנט של מילת מפתח בלבד ב-<span dir="ltr"><code>__init__</code></span>. אם <span dir="ltr"><code>False</code></span>, הוא הופך למיקומי. זה מאפשר לך לערבב ארגומנטים מיקומיים ושל מילת מפתח בלבד כאשר ה-<span dir="ltr"><code>kw_only</code></span> של המחלקה הוא <span dir="ltr"><code>False</code></span> כברירת מחדל.
<pre class="line-numbers"><code class="language-python">@dataclass
class FlexibleParams:
    mandatory_pos: str # מיקומי
    optional_kw: int = field(default=0, kw_only=True) # מילת מפתח בלבד

fp1 = FlexibleParams("חובה", optional_kw=100)
# fp2 = FlexibleParams("חובה", 200) # TypeError: __init__() takes 1 positional argument but 2 were given (optional_kw)
</code></pre>
</li>
</ul>
<h3 dir="rtl">הפונקציה <span dir="ltr"><code>fields()</code></span>: אינטרוספקציה של <span dir="ltr">Dataclass</span></h3>
<p dir="rtl">הפונקציה <span dir="ltr"><code>fields()</code></span> ממודול <span dir="ltr"><code>dataclasses</code></span> מאפשרת לך לקבל מידע על השדות של <span dir="ltr">dataclass</span> או המופע שלה. היא מחזירה טופל של אובייקטי <span dir="ltr"><code>Field</code></span>.</p>
<pre class="line-numbers"><code class="language-python">from dataclasses import dataclass, field, fields
from typing import List

@dataclass
class Book:
    title: str
    author: str = field(metadata={'display_name': 'מחבר', 'max_length': 100})
    pages: int = field(default=0, metadata={'min_value': 1})
    tags: List[str] = field(default_factory=list, repr=False)

# קבלת מידע על השדות של מחלקת Book
book_fields = fields(Book)

for f in book_fields:
    print(f"שם שדה: {f.name}")
    print(f"סוג שדה: {f.type}")
    print(f"ערך ברירת מחדל: {f.default}")
    print(f"משתמש ב-default_factory: {f.default_factory is not None}")
    print(f"כלול ב-init: {f.init}")
    print(f"כלול ב-repr: {f.repr}")
    print(f"כלול ב-compare: {f.compare}")
    print(f"כלול ב-hash: {f.hash}")
    print(f"מטא נתונים: {f.metadata}")
    print(f"מילת מפתח בלבד: {f.kw_only}") # עבור פייתון 3.10+
    print("-" * 20)

# גישה למטא נתונים של שדה ספציפי:
author_field_info = next(f for f in book_fields if f.name == 'author')
print(f"שם תצוגה למחבר: {author_field_info.metadata.get('display_name')}")
</code></pre>
<p dir="rtl">לאובייקט <span dir="ltr"><code>Field</code></span> יש את התכונות הבאות: <span dir="ltr"><code>name</code></span>, <span dir="ltr"><code>type</code></span>, <span dir="ltr"><code>default</code></span>, <span dir="ltr"><code>default_factory</code></span>, <span dir="ltr"><code>init</code></span>, <span dir="ltr"><code>repr</code></span>, <span dir="ltr"><code>hash</code></span>, <span dir="ltr"><code>compare</code></span>, <span dir="ltr"><code>metadata</code></span>, <span dir="ltr"><code>kw_only</code></span>.</p>
<h3 dir="rtl">השיטה <span dir="ltr"><code>__post_init__</code></span></h3>
<p dir="rtl">לפעמים אתה זקוק ללוגיקה נוספת לאחר ש-<span dir="ltr"><code>__init__</code></span> האוטומטי של <span dir="ltr">dataclass</span> סיים לאתחל את השדות. לשם כך, תוכל להגדיר שיטת <span dir="ltr"><code>__post_init__</code></span>. היא תיקרא מיד לאחר <span dir="ltr"><code>__init__</code></span>.</p>
<p dir="rtl">זה שימושי עבור:</p>
<ul dir="rtl">
<li>אימות נתונים.</li>
<li>חישוב שדות נגזרים על בסיס שדות שכבר אותחלו.</li>
<li>ביצוע כל לוגיקה אחרת התלויה בשדות מאותחלים במלואם.</li>
</ul>
<pre class="line-numbers"><code class="language-python">import datetime

@dataclass
class User:
    first_name: str
    last_name: str
    email: str = field(init=False) # שדה זה לא ייכלל בפרמטרים של __init__
    created_at: datetime.datetime = field(default_factory=datetime.datetime.now, init=False)

    def __post_init__(self):
        print(f"--- __post_init__ הופעל עבור {self.first_name} {self.last_name} ---")
        # אימות
        if not self.first_name or not self.last_name:
            raise ValueError("שם פרטי ושם משפחה אינם יכולים להיות ריקים.")
        # חישוב שדה נגזר
        self.email = f"{self.first_name.lower()}.{self.last_name.lower()}@example.com"
        print(f"משתמש {self.first_name} {self.last_name} נוצר עם אימייל: {self.email}")
        print(f"זמן יצירה: {self.created_at}")
        print(f"--- __post_init__ הסתיים ---")

alice_ivanova = User("אליס", "איבנובה")
print("
האובייקט נוצר:
")
print(alice_ivanova)

print("
")

try:
    victor_no_last_name = User("ויקטור", "")
except ValueError as e:
    print(f"שגיאה בעת יצירת משתמש: {e}")
</code></pre>
<h3 dir="rtl">ירושה של <span dir="ltr">Dataclass</span></h3>
<p dir="rtl"><span dir="ltr">Dataclasses</span> תומכות בירושה. שדות ממחלקות בסיס נכללים במחלקות צאצא.</p>
<pre class="line-numbers"><code class="language-python">@dataclass
class Vehicle:
    make: str
    model: str

@dataclass
class Car(Vehicle):
    num_doors: int
    is_electric: bool = False

@dataclass
class ElectricCar(Car):
    battery_kwh: float

alices_car = Car("טויוטה", "קאמרי", 4)
print(alices_car) # Car(make='טויוטה', model='קאמרי', num_doors=4, is_electric=False)

boris_car = ElectricCar("טסלה", "מודל 3", 4, True, 75.0)
print(boris_car) # ElectricCar(make='טסלה', model='מודל 3', num_doors=4, is_electric=True, battery_kwh=75.0)
</code></pre>
<p dir="rtl"><strong>תכונות של ירושה עם <span dir="ltr"><code>slots=True</code></span>:</strong></p>
<ul dir="rtl">
<li>אם מחלקת האב משתמשת ב-<span dir="ltr"><code>__slots__</code></span>, גם מחלקת הצאצא חייבת להשתמש ב-<span dir="ltr"><code>__slots__</code></span> כדי להשיג את חיסכון הזיכרון.</li>
<li>מחלקת הצאצא חייבת להגדיר <span dir="ltr"><code>__slots__</code></span> משלה עבור השדות החדשים שלה.</li>
<li>אם מחלקת הצאצא אינה מגדירה <span dir="ltr"><code>__slots__</code></span>, יהיה לה <span dir="ltr"><code>__dict__</code></span> בנוסף ל-<span dir="ltr">slots</span> של האב.</li>
</ul>
<h3 dir="rtl">מתי להשתמש ב-<span dir="ltr">Dataclasses</span>?</h3>
<ul dir="rtl">
<li><strong>מחלקות מיכל נתונים:</strong> כאשר המטרה העיקרית של המחלקה היא לאחסן נתונים, ואתה זקוק ל-<span dir="ltr"><code>__init__</code></span>, <span dir="ltr"><code>__repr__</code></span>, <span dir="ltr"><code>__eq__</code></span> אוטומטיים.</li>
<li><strong>אובייקטים בלתי ניתנים לשינוי:</strong> כאשר אתה זקוק לאובייקטים שמצבם לא אמור להשתנות לאחר היצירה (<span dir="ltr"><code>frozen=True</code></span>).</li>
<li><strong>תצורות:</strong> להגדרת מבנה פרמטרי התצורה.</li>
<li><strong>אובייקטי העברת נתונים (<span dir="ltr">DTOs</span>):</strong> להעברת נתונים מובנים בין חלקי יישום.</li>
<li><strong>לוגיקה עסקית פשוטה:</strong> כאשר שיטות המחלקה פועלות בעיקר על נתוני המחלקה עצמה, אין להן מצב פנימי מורכב או תופעות לוואי.</li>
</ul>
<h3 dir="rtl">מתי לא להשתמש ב-<span dir="ltr">Dataclasses</span>?</h3>
<ul dir="rtl">
<li><strong>מחלקות עם התנהגות עשירה:</strong> כאשר למחלקה יש לוגיקה עסקית מורכבת, שיטות רבות המקיימות אינטראקציה עם מערכות חיצוניות, או מצב פנימי מורכב, עדיף להשתמש במחלקה רגילה.</li>
<li><strong>מודלי מיפוי <span dir="ltr">OR</span> (<span dir="ltr">ORM</span>):</strong> למרות ש-<span dir="ltr">dataclasses</span> יכולות להיות חלק מ-<span dir="ltr">ORM</span>, הן אינן מחליפות מודלי <span dir="ltr">ORM</span> מלאים, שלעתים קרובות דורשים שיטות ספציפיות לעבודה עם מסד נתונים, טעינה עצלה וכו'.</li>
<li><strong>פולימורפיזם והיררכיית ירושה עמוקה:</strong> אם יש לך היררכיית מחלקות מורכבת עם פולימורפיזם עמוק ועקיפת התנהגות, מחלקות רגילות עשויות להיות גמישות יותר.</li>
</ul>
<h3 dir="rtl">סיכום</h3>
<p dir="rtl"><span dir="ltr"><code>dataclasses</code></span> הן תוספת חזקה ונוחה לפייתון המפשטת משמעותית את יצירת מחלקות מוכוונות נתונים. הן עוזרות לכתוב קוד נקי יותר, קריא יותר וקל יותר לתחזוקה, ואפשרויות כמו <span dir="ltr"><code>slots=True</code></span> ו-<span dir="ltr"><code>kw_only=True</code></span> מספקות הזדמנויות נוספות לאופטימיזציה של ביצועים ולשיפור הארגונומיה של ה-<span dir="ltr">API</span> של הקוד שלך. אל תשכח את <span dir="ltr"><code>field()</code></span> לתצורה מפורטת של כל שדה ואת <span dir="ltr"><code>fields()</code></span> לאינטרוספקציה!</p>