## תורת החבורות - חבורה למחצה

המבנה הפשוט ביותר בתורת החבורות הוא חבורה למחצה. חבורה למחצה היא קבוצה כלשהי, שעבורה מוגדרת פעולה בינארית אסוציאטיבית, המקבלת שני איברים מהקבוצה הזו ומחזירה איבר שלישי. להלן, כל הדוגמאות יינתנו בשפת התכנות פייתון.

בפייתון, אנו יכולים להגדיר את מושג החבורה למחצה באמצעות `typing.Protocol` (לבדיקת טיפוסים סטטית) או פשוט לפי מוסכמה (duck typing). לשם הבהרה, נשתמש במילונים המאחסנים את פעולת `combine`.

```python
from typing import TypeVar, Callable, Protocol, Generic
import functools # עבור reduce

T = TypeVar('T')

# אנו מתארים את מבנה החבורה למחצה באמצעות Protocol (לטיפוס סטטי)
class Semigroup(Protocol[T]):
    # Callable[[T, T], T] פירושו פונקציה המקבלת שני ארגומנטים מטיפוס T
    # ומחזירה ערך מטיפוס T
    combine: Callable[[T, T], T]

# דוגמה: חבורה למחצה של מספרים טבעיים (או שלמים/ממשיים) עם חיבור
# אנו מייצגים חבורה למחצה ספציפית כמילון עם המפתח 'combine'
addition_semigroup: Semigroup[int] = {
    "combine": lambda a, b: a + b
}

# דוגמה: חבורה למחצה של מספרים עם כפל
multiplication_semigroup: Semigroup[int] = {
    "combine": lambda a, b: a * b
}

# דוגמה: חבורה למחצה של מחרוזות עם שרשור
concatenation_semigroup: Semigroup[str] = {
    "combine": lambda a, b: a + b
}
```

הפעולה על איברי החבורה למחצה חייבת בהכרח להיות בעלת תכונת האסוציאטיביות. בואו נבדוק זאת באמצעות פונקציית `assert` המובנית:

```python
def check_associativity(semigroup: Semigroup[T], a: T, b: T, c: T) -> None:
    # אנו בודקים ש- (a * b) * c == a * (b * c)
    # אנו משתמשים בפעולת combine מהחבורה למחצה שהועברה
    left_side = semigroup["combine"](semigroup["combine"](a, b), c)
    right_side = semigroup["combine"](a, semigroup["combine"](b, c))
    assert left_side == right_side, f"האסוציאטיביות נכשלה עבור {semigroup}: ({a}, {b}, {c})"

check_associativity(addition_semigroup, 1, 2, 3)
check_associativity(multiplication_semigroup, 2, 3, 4) # 1*2*3 = 6, (1*2)*3 = 6, 1*(2*3)=6
check_associativity(concatenation_semigroup, 'a', 'b', 'c')
```

לחבורות למחצה אין תכונות מעניינות במיוחד. עם זאת, גם בדוגמה שלהן, אנו רואים את הנוחות של תורת החבורות - היכולת לעבוד עם קבוצות ופעולות עליהן באמצעות ממשק מופשט (במקרה שלנו, מילון עם פונקציית `combine`).

לדוגמה, אנו יכולים לכתוב פונקציית רדוקציה (קיפול) עבור רשימת ערכי חבורה למחצה באמצעות ערך התחלתי. זה כבר מרמז על המבנה הבא - מונואיד.

```python
from typing import List

# פונקציה זו דומה יותר ל-fold מהסעיף הבא,
# מכיוון שהיא דורשת ערך התחלתי. רדוקציה טהורה של חבורה למחצה
# תדרוש רשימה לא ריקה.
def reduce_semigroup_with_initial(
    values: List[T],
    semigroup: Semigroup[T],
    initial_value: T
) -> T:
    # אנו משתמשים ב-functools.reduce כדי להחיל את combine ברצף
    return functools.reduce(semigroup["combine"], values, initial_value)

# כעת אנו יכולים להשתמש בפונקציה זו כדי לצמצם רשימה:
sum_val = reduce_semigroup_with_initial([1, 2, 3, 4], addition_semigroup, 0)
assert sum_val == 10

product_val = reduce_semigroup_with_initial([1, 2, 3, 4], multiplication_semigroup, 1)
assert product_val == 24

concat_val = reduce_semigroup_with_initial(['a', 'b', 'c'], concatenation_semigroup, '')
assert concat_val == 'abc'

```
השימוש בפונקציית רדוקציה של חבורה למחצה מוביל אותנו בצורה חלקה למבנה הבא, המעניין הרבה יותר מתורת החבורות - המונואיד.

## תורת החבורות - מונואיד

מונואיד הוא חבורה למחצה עם איבר ניטרלי מוגדר (`unit` או `identity`).

```python
# אנו מגדירים פרוטוקול עבור מונואיד, בירושה מ-Semigroup
class Monoid(Semigroup[T], Protocol[T]):
    unit: T # איבר ניטרלי

# מונואיד של חיבור מספרים (איבר ניטרלי - 0)
addition_monoid: Monoid[int] = {
    "combine": lambda a, b: a + b,
    "unit": 0
}
```

איבר ניטרלי הוא איבר ששילובו עם כל איבר אחר אינו משנה אותו (`a + 0 = a`, `a * 1 = a`, `s + "" = s`). עבור חיבור מספרים, האיבר הניטרלי הוא, כמובן, אפס.

בואו נבדוק תכונה זו של מונואיד באמצעות `assert`:

```python
def check_unit_combination(monoid: Monoid[T], value: T) -> None:
    # אנו בודקים ש- combine(value, unit) == value
    # ו- combine(unit, value) == value (לשם השלמות)
    assert monoid["combine"](value, monoid["unit"]) == value
    assert monoid["combine"](monoid["unit"], value) == value

check_unit_combination(addition_monoid, 10)
```

האיבר הניטרלי של מונואיד כפל מספרים הוא אחד.

```python
multiplication_monoid: Monoid[int] = {
    "combine": lambda a, b: a * b,
    "unit": 1
}

check_unit_combination(multiplication_monoid, 25)
```

בהתאם לכך, האיבר הניטרלי של מונואיד שרשור מחרוזות הוא מחרוזת ריקה.

```python
concatenation_monoid: Monoid[str] = {
    "combine": lambda a, b: a + b,
    "unit": ""
}

check_unit_combination(concatenation_monoid, 'a')
```

וכעת אנו מגיעים לתכונה המעניינת ביותר של מונואידים - ניתן להשתמש בפעולת הקיפול (`fold`) כדי לעבוד איתם. זוהי למעשה אותה `reduce_semigroup_with_initial`, אך כעת הערך ההתחלתי נלקח ישירות מהמונואיד (`unit`).

```python
def fold(monoid: Monoid[T], values: List[T]) -> T:
    # אנו משתמשים ב-functools.reduce, החל מהאיבר הניטרלי monoid['unit']
    return functools.reduce(monoid["combine"], values, monoid["unit"])

# עם fold, נפתחות בפנינו יכולות קסומות לחלוטין:
sum_folded = fold(addition_monoid, [1, 2, 3, 4])
assert sum_folded == 10

product_folded = fold(multiplication_monoid, [1, 2, 3, 4])
assert product_folded == 24

concatenated_folded = fold(concatenation_monoid, ['a', 'b', 'c', 'd'])
assert concatenated_folded == 'abcd'
```

אנו יכולים גם להגדיר מונואידים עבור פעולות השוואת מספרים. עבור `min`, האיבר הניטרלי יהיה אינסוף, ועבור `max` - מינוס אינסוף.

```python
import math # עבור float('inf')
min_monoid: Monoid[float] = { # אנו משתמשים ב-float עבור אינסוף
    "combine": lambda a, b: min(a, b),
    "unit": float('inf')
}
max_monoid: Monoid[float] = {
    "combine": lambda a, b: max(a, b),
    "unit": float('-inf')
}
min_fold_result = fold(min_monoid, [1, 9, 6, 4])
assert min_fold_result == 1
max_fold_result = fold(max_monoid, [1, 9, 6, 4])
assert max_fold_result == 9
```

ויותר מכך, אנו יכולים להגדיר, לדוגמה, מונואיד של פונקציות. לדוגמה, מונואיד של פונקציות אונריות (המקבלות ארגומנט אחד) על מספרים, כאשר פעולת `combine` תהיה הרכבת פונקציות, והאיבר הניטרלי (`unit`) יהיה פונקציית הזהות (`lambda x: x`).

```python
# טיפוס עבור פונקציה אונרית מ-int ל-int
IntUnaryFunc = Callable[[int], int]

# מונואיד עבור הרכבת פונקציות (int -> int)
# חשוב: סדר ההרכבה הוא f(g(x))
function_monoid: Monoid[IntUnaryFunc] = {
    "combine": lambda f, g: lambda x: f(g(x)), # f אחרי g
    "unit": lambda x: x # פונקציית הזהות
}

add_one: IntUnaryFunc = lambda x: x + 1
double: IntUnaryFunc = lambda x: x * 2

# קיפול רשימת פונקציות: [add_one, double]
# יוחל תחילה unit, ואז double, ואז add_one.
# fold(monoid, [f, g]) שווה ערך ל-combine(combine(unit, f), g) = combine(f, g)
# combine(f, g) = lambda x: f(g(x))
function_fold_result_func = fold(function_monoid, [add_one, double])

# נחיל את התוצאה על המספר 1: add_one(double(1)) = add_one(2) = 3
assert function_fold_result_func(1) == 3

# אם סדר הפונקציות חשוב וצריך g(f(x)), יש לשנות את combine:
# "combine": lambda f, g: lambda x: g(f(x))
```

בדוגמת המונואיד, אנו רואים שתורת החבורות מאפשרת לנו לעבוד עם קבוצות ופעולות רבות ושונות עליהן באותה צורה.

זוכרים, בבית הספר אמרו לנו שכל מספר בחזקת אפס שווה לאחד, אבל אף פעם לא הסבירו למה?

תכונה זו מתבהרת במבט ראשון על מונואיד הכפל. העלאה בחזקה היא יישום חוזר ונשנה של פעולת `combine` של מונואיד הכפל. לדוגמה, `2^3` הוא `combine(combine(unit, 2), 2), 2)` או, מה שזהה, `combine(combine(2, 2), 2)`.

```python
# 2^3 באמצעות מונואיד הכפל
power_3 = multiplication_monoid["combine"](
    multiplication_monoid["combine"](2, 2), # 2*2
    2                                       # (2*2)*2
)
assert power_3 == 8
```

אבל מהי חזקת אפס? זוהי יישום פעולת `combine` אפס פעמים על האיבר ההתחלתי. איזו תוצאה עלינו לקבל? אם איננו מיישמים `combine` כלל, נשאר לנו רק האיבר הניטרלי `unit`, שבמקרה של מונואיד הכפל שווה לאחד. לכן `x^0 = 1`.

## תורת החבורות - חבורה

חבורה היא מונואיד, שעבור כל איבר בו מוגדר איבר הופכי מאותה קבוצה, כך ששילוב האיבר עם ההופכי שלו נותן את האיבר הניטרלי.

```python
# אנו מגדירים פרוטוקול עבור חבורה, בירושה מ-Monoid
class Group(Monoid[T], Protocol[T]):
    inverse: Callable[[T], T] # פונקציה לקבלת האיבר ההופכי

# דוגמה קלאסית לחבורה היא קבוצת המספרים השלמים עם פעולת החיבור
addition_group: Group[int] = {
    "combine": lambda a, b: a + b,
    "unit": 0,
    "inverse": lambda a: -a # האיבר ההופכי לחיבור הוא הנגדי
}
```

התכונה העיקרית של חבורה היא ששילוב איבר עם האיבר ההופכי שלו תמיד מניב את האיבר הניטרלי של החבורה:

```python
def check_inversion_combination(group: Group[T], value: T) -> None:
    # אנו בודקים ש- combine(value, inverse(value)) == unit
    # ו- combine(inverse(value), value) == unit
    assert group["combine"](value, group["inverse"](value)) == group["unit"]
    assert group["combine"](group["inverse"](value), value) == group["unit"]

check_inversion_combination(addition_group, 5) # 5 + (-5) == 0
```

ניתן לומר שחבורה היא מבנה מתמטי המופשט את מושג הסימטריה. באמצעות מבנה זה חוקרים פיזיקאים את תכונות המרחב, הזמן, האנרגיה והחלקיקים האלמנטריים - בבסיס המנגנון המתמטי של תורת היחסות ומכניקת הקוונטים נמצאת תורת החבורות. בעזרתה, בשנת 1918, הוכיחה אמי נתר את משפטיה המפורסמים לפיהם כל חוק שימור, בין אם זה חוק שימור אנרגיה, תנע או מטען, נובע מסימטריות פיזיקליות יסודיות.

בנוסף, מונואידים וחבורות מיושמים לעיתים קרובות בתכנות פונקציונלי. אם תלמד מעט מתורת החבורות, תראה שבעיות ומבנים רבים בתכנות הם מקרים פרטיים של מבנה מתמטי מופשט יותר. הדוגמה הפשוטה ביותר לחבורה בתכנות היא מערכת Undo-Redo, המיושמת ביישומים רבים (הפעולה היא פעולת המשתמש, הפעולה ההופכית היא ביטול הפעולה, האיבר הניטרלי הוא היעדר שינויים).

## מונדולוגיה

יופי הסימטריות ריתק אנשים מאז ימי קדם. בבית הספר שהוקם על ידי הפילוסוף והגיאומטריקן היווני הקדום האגדי פיתגורס, תלמידיו סגדו למונאדה, המתוארת כעיגול עם נקודה עבה במרכזו:

*(תמונה של מונאדת פיתגורס)*

המשמעות המיסטית של המונאדה טמונה בנקודת המרכז שלה - נקודה זו מגלמת את ה"כלום" שממנו נוצר היקום. לפי הפיתגוראים, אין הגבלות על הופעת כל הדברים האפשריים מכלום, אך במקביל לדברים אלה, מופיעים גם ההפכים שלהם. על ידי פרישת נקודה אפס-ממדית למספר אינסופי של הפכים, אנו מקבלים מעגל - צורה שעליה נמצא מספר אינסופי של נקודות, שעבור כל אחת מהן, ביחס למרכז המעגל, קיימת נקודה הפוכה. באופן כללי, תיאור זה מתיישב לחלוטין עם מושג החבורה מתורת החבורות.

במגנום אופוס הפילוסופי שלו בשם "מונדולוגיה", הפילוסוף והמתמטיקאי הגרמני הגדול גוטפריד וילהלם לייבניץ הציג את השקפת עולמו, לפיה כל המציאות שלנו מורכבת ממספר אינסופי של מונאדות כפולות כאלה. לכבוד מושג המונאדה הפיתגוראי-לייבניציאני הזה, נקרא המבנה העיקרי מתורה מתמטית אחרת - תורת הקטגוריות.

אם תורת החבורות מופשטת פעולות אלגבריות וגיאומטריות אינטואיטיביות בסיסיות למבנים כלליים, אז תורת הקטגוריות היא, כביכול, הצעד הבא בסולם ההפשטות - הפשטה של הפשטות. תורת הקטגוריות חוקרת מבנים מתמטיים שונים - חבורות, גרפים, קבוצות - כקטגוריות מופשטות עם אובייקטים (איברים) ומורפיזמים (פעולות) ביניהם. מורפיזמים מתוארים בדרך כלל כחצים ונקראים "חצים". הד של שם זה הן פונקציות למבדה (`lambda`) או פונקציות רגילות (`def`) בתכנות, שאתה כנראה מכיר, הממירות ערכים מסוימים לאחרים.

בואו נבחן את מושגי היסוד של תורת הקטגוריות.

## תורת הקטגוריות - חץ

חץ (או מורפיזם) בתורת הקטגוריות נקרא מיפוי (פונקציה) בין שתי קטגוריות (קבוצות של אובייקטים) - התאמה של כל אובייקט מהקטגוריה הראשונה לאובייקט כלשהו מהקטגוריה השנייה. ניקח לדוגמה שתי קטגוריות פשוטות ביותר - מספרים שלמים לא שליליים ומחרוזות מהאות "a".

```
0 -> ""
1 -> "a"
2 -> "aa"
3 -> "aaa"
4 -> "aaaa"
...
```

כאן נראה בבירור שכל איבר מקטגוריית המספרים ממופה לאיבר מקטגוריית המחרוזות המורכבות מהאות 'a'. כל מיפוי כזה יכול להיות מתואר באמצעות פונקציה. במקרה זה, זה:

```python
def map_number_to_a_string(num: int) -> str:
    # נוודא שהמספר אינו שלילי עבור חזרה
    if num < 0:
        raise ValueError("מספר הקלט חייב להיות לא שלילי")
    return "a" * num # בפייתון, מחרוזת חוזרת על עצמה על ידי כפל

assert map_number_to_a_string(3) == "aaa"
```

אין הכרח שאיבר מהקטגוריה הראשונה יתאים לאיבר ייחודי מהשנייה. לדוגמה, עבור החץ הבא מקטגוריית המספרים לקטגוריית האמת (ערכים בוליאניים), בקטגוריה השנייה יש רק שני איברים (`True` ו-`False`), אך כל איבר מהראשונה ממופה לאחד מהאיברים מהשנייה:

```
0 -> False
1 -> False
2 -> False
3 -> True
4 -> True
...
n -> True (עבור n >= 3)
```

הפונקציה (חץ) במקרה זה יכולה להיות מתוארת כ:

```python
def map_number_to_boolean(number: int) -> bool:
    return number >= 3

assert map_number_to_boolean(2) == False
assert map_number_to_boolean(5) == True
```

## תורת הקטגוריות - פונקטור ואנדופונקטור

אנו יכולים לעטוף אובייקטים מכל קטגוריה במעין מכלים מופשטים. אם יש לנו קטגוריות (טיפוסים) A ו-B, ויש לנו מכל F כלשהו (לדוגמה, `list`, `Optional`, `Future`), שיכול להכיל בתוכו אובייקט אחד או יותר מקטגוריות A או B, אז אנו מקבלים שתי קטגוריות חדשות (טיפוסים) F(A) ו-F(B) (לדוגמה, `list[A]` ו-`list[B]`).

לדוגמה, אם יש לנו קטגוריית מספרים (`int`) וקטגוריית מחרוזות (`str`), ויש לנו מכל `list`, אז אנו מקבלים שתי קטגוריות חדשות - רשימת מספרים (`list[int]`) ורשימת מחרוזות (`list[str]`). בפייתון, קשרים אלה משתקפים במערכת הטיפוסים:

```python
number: int = 1
string_value: str = 'a'

numbers: list[int] = [1, 2, 3]
strings: list[str] = ['a', 'b', 'c']
```

בתורת הקטגוריות מתוארים מיפויים בין קטגוריות של אובייקטים וקטגוריות של מכלים, אשר שומרים על המבנה במהלך הטרנספורמציה. מיפויים כאלה נקראים פונקטורים. המיפוי עצמו נקרא `map` (או `fmap`).

קיימים מספר סוגים שונים של פונקטורים. הנפוץ ביותר מביניהם הוא האנדופונקטור, שבו הטרנספורמציה מתרחשת בתוך אותה קטגוריית מכל F(A) -> F(B) (לדוגמה, `list[A] -> list[B]`).

```python
# טיפוס כללי עבור משתנים A ו-B
A = TypeVar('A')
B = TypeVar('B')

# פרוטוקול עבור פונקטור
class Functor(Protocol[A]):
    # מתודת map מקבלת פונקציה (חץ) מ-A ל-B
    # ומחזירה פונקטור חדש עם איברים מטיפוס B.
    # חשוב: היא מחזירה מופע מאותו טיפוס פונקטור (לדוגמה, list).
    def map(self, func: Callable[[A], B]) -> 'Functor[B]':
        ...

# דוגמה קלאסית לאנדופונקטור בפייתון היא רשימה (list).
# למרות של-list אין מתודת .map כברירת מחדל, אנו יכולים לממש אותה בקלות
# או להשתמש ב-list comprehensions (שזה יותר אידיומטי).

# דוגמה לשימוש ב-list comprehension כאנלוגיה ל-map:
map_number_to_boolean_func = lambda number: number >= 3
numbers_list: list[int] = [1, 2, 3, 4]

# נחיל את הפונקציה על כל איבר ברשימה, נקבל רשימה חדשה
booleans_list: list[bool] = [map_number_to_boolean_func(n) for n in numbers_list]
assert booleans_list == [False, False, True, True]

# ניתן גם להשתמש בפונקציה המובנית map, המחזירה איטרטור:
booleans_iterator = map(map_number_to_boolean_func, numbers_list)
assert list(booleans_iterator) == [False, False, True, True]
```

לפיכך, אם יש לנו חץ (פונקציה) `A -> B`, אז באמצעות פונקטור (לדוגמה, `list` ופעולות ה-`map`/list comprehension שלו), אנו יכולים לבנות חץ `F[A] -> F[B]`.

עבור פונקטורים חייבים להתקיים מספר חוקים.

החוק הראשון - חוק הזהות: `functor.map(id) == functor` (החלת פונקציית הזהות לא אמורה לשנות את הפונקטור).

```python
def id_func(x: T) -> T:
    return x

# בדיקה עבור רשימה:
numbers_list = [1, 2, 3]
assert [id_func(x) for x in numbers_list] == numbers_list
```

החוק השני - חוק ההרכבה: `functor.map(g o f) == functor.map(f).map(g)` (כאשר `g o f` היא הרכבת פונקציות, `lambda x: g(f(x))`). מיפוי הרכבת פונקציות שווה ערך למיפוי רציף של פונקציות אלה.

```python
f: Callable[[int], str] = lambda x: str(x) # int -> str
g: Callable[[str], bool] = lambda x: len(x) > 1 # str -> bool
compose_gf: Callable[[int], bool] = lambda x: g(f(x)) # int -> bool

numbers_list = [5, 10, 15]

# צד שמאל: map(g o f)
left_side = [compose_gf(x) for x in numbers_list] # [False, True, True]

# צד ימין: map(f) ואז map(g)
intermediate = [f(x) for x in numbers_list] # ['5', '10', '15']
right_side = [g(y) for y in intermediate] # [False, True, True]

assert left_side == right_side
```

## תורת הקטגוריות - מונאדה

מונאדה מרחיבה את יכולות הפונקטור, על ידי הוספת פעולת `flatMap` (המכונה לעיתים `bind` או `>>=`) ודרך "לעטוף" ערך רגיל בהקשר מונאדי (המכונה לעיתים קרובות `unit`, `return` או `pure`, בפייתון עבור רשימות זה יכול להיות פשוט `lambda x: [x]`).

```python
# פרוטוקול עבור מונאדה (יורש מ-Functor)
# חשוב: זוהי ייצוג פשוט. טיפוס נכון של מונאדות בפייתון מורכב.
class Monad(Functor[A], Protocol[A]):
    # flatMap מקבל פונקציה שמחזירה בעצמה מונאדה
    def flatMap(self, func: Callable[[A], 'Monad[B]']) -> 'Monad[B]':
        ...

    # מתודה סטטית או מחלקתית ל"עטיפת" ערך
    @classmethod
    def unit(cls, value: A) -> 'Monad[A]':
         ...

# שוב, אנו משתמשים ברשימה כדוגמה למונאדה בפייתון.
# למרות של-list אין מתודות flatMap/unit, אנו יכולים לדמות אותן.

# 'unit' עבור רשימה: לעטוף ערך ברשימה
list_unit = lambda x: [x]

# 'flatMap' עבור רשימה: להחיל פונקציה על כל איבר,
# ולאחר מכן "לשטח" (flatten) את התוצאה (לשלב רשימות).
# זה נעשה בקלות באמצעות list comprehension עם שתי לולאות for.
def list_flat_map(data: list[A], func: Callable[[A], list[B]]) -> list[B]:
    # עבור כל x ב-data, נחיל את func(x), שיחזיר רשימה.
    # לאחר מכן עבור כל y ברשימה הפנימית הזו, נוסיף את y לתוצאה.
    return [y for x in data for y in func(x)]

# דוגמה לשימוש
numbers = [1, 2, 3]
# פונקציה שעבור מספר n מחזירה רשימה [n, n+1]
func_n_nplus1 = lambda number: [number, number + 1]

flat_mapped_numbers = list_flat_map(numbers, func_n_nplus1)
# תוצאה צפויה:
# עבור 1 -> [1, 2]
# עבור 2 -> [2, 3]
# עבור 3 -> [3, 4]
# שילוב: [1, 2, 2, 3, 3, 4]
assert flat_mapped_numbers == [1, 2, 2, 3, 3, 4]
```

דוגמאות ידועות נוספות למונאדות (או מבנים דמויי מונאדה) בפייתון יכולות להיות:
*   `asyncio.Future` (או `awaitables` באופן כללי) עבור פעולות אסינכרוניות (כאשר `await` דומה ל-`flatMap`).
*   טיפוס `Optional` (הממומש לעיתים קרובות כ-`Union[T, None]`, אם כי עבור מונאדה נכונה נדרש מבנה `Maybe` או `Option` מחמיר יותר) לעבודה עם ערכים שעשויים להיות חסרים.
*   מונאדות שונות מספריות תכנות פונקציונליות עבור פייתון (לדוגמה, `pymonad`, `returns`).

בעיקרו של דבר, מונאדה היא פשוט הפשטה של חישובים כשלעצמם, המאפשרת לבנות צינורות עיבוד נתונים, לנהל תופעות לוואי, לטפל בשגיאות או באסינכרוניות באופן אחיד.

*(תמונה/תרשים של מונאדה)*

עבור מונאדות, חייבים להתקיים מספר חוקים מונאדיים מיוחדים (זהות שמאלית וימנית, אסוציאטיביות של `flatMap`), אשר, עם זאת, לא אציג כאן, מכיוון שהגיע הזמן לסיים פוסט ארוך זה. אני רק רוצה לציין שהיתרון החשוב ביותר של מונאדות הוא שהן מאפשרות לסדר את ביצוע החישובים המבודדים. דוגמה לסדר כזה בפייתון היא השימוש ב-`await` לביצוע רציף של פעולות אסינכרוניות (`asyncio.Future`), הדומה מבחינה רעיונית להרכבה מונאדית.

## מסקנה

לסיכום, ברצוני לומר שתורת החבורות ותורת הקטגוריות נמצאות בבסיס כל המתמטיקה, מדעי המחשב והפיזיקה הידועים לאדם. זוהי פשוט שפת היקום - המבטאת ביותר והיפה ביותר מבחינה פואטית. הייתי לומד אותה רק בגלל שאלוהים דיבר בה!