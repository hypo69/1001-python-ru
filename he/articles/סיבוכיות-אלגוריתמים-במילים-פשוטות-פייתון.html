<h2 dir="rtl">סיבוכיות אלגוריתמים במילים פשוטות ודוגמאות בפייתון</h2>

<p dir="rtl">בתכנות, קיימות דרכים רבות לפתור את אותה בעיה. עם זאת, לא כל הפתרונות יעילים באותה מידה. אחד ההיבטים המרכזיים שיש לקחת בחשבון בעת פיתוח אלגוריתמים הוא הסיבוכיות שלהם. הבנת סיבוכיות האלגוריתם מאפשרת להעריך כמה מהר הוא יפעל וכמה משאבים (לדוגמה, זיכרון) יידרשו לביצועו, במיוחד כאשר נפח נתוני הקלט גדל. הבנת סיבוכיות אלגוריתמים היא מיומנות בסיסית המאפשרת לכתוב קוד יעיל יותר.</p>

<h3 dir="rtl">מהי סיבוכיות אלגוריתם?</h3>

<p dir="rtl">תאר לעצמך שיש לך משימה: למצוא שם ספציפי בספר טלפונים.</p>

<ul>
<li><p dir="rtl"><strong>דרך פשוטה (חיפוש לינארי):</strong> אתה לוקח את הספר ומתחיל לדפדף דף אחר דף עד שתמצא את השם הרצוי. אם השם נמצא בסוף הספר, תצטרך לדפדף בכל הספר!</p></li>
<li><p dir="rtl"><strong>דרך חכמה (חיפוש בינארי):</strong> אתה פותח את הספר באמצע. אם השם שאתה מחפש מופיע לפני השם בדף זה, אתה סוגר את החצי השני של הספר ומחפש בחצי הראשון. אם השם מופיע אחרי, אתה מחפש בחצי השני. וכך אתה חוזר על הפעולה עד שתמצא את השם הרצוי. בכל שלב, אתה זורק חצי מהספר!</p></li>
</ul>

<p dir="rtl"><strong>סיבוכיות אלגוריתם</strong> – היא דרך לתאר כמה &quot;זמן&quot; (או משאבים, כמו זיכרון) יידרש לאלגוריתם כדי לבצע את משימתו, בהתאם למידת &quot;גודל&quot; המשימה.</p>

<ul>
<li><p dir="rtl"><strong>חיפוש לינארי:</strong> אם בספר יש <span dir="ltr">10</span> עמודים, ייתכן שתצטרך לדפדף ב-<span dir="ltr">10</span> עמודים. אם בספר יש <span dir="ltr">100</span> עמודים, ייתכן שתצטרך לדפדף ב-<span dir="ltr">100</span> עמודים. כמות העבודה גדלה <em>לינארית</em> עם גודל המשימה. זה נקרא <strong><span dir="ltr">O(n)</span></strong>, כאשר <span dir="ltr">'n'</span> הוא גודל המשימה (מספר העמודים בספר).</p></li>

<li><p dir="rtl"><strong>חיפוש בינארי:</strong> אם בספר יש <span dir="ltr">16</span> עמודים, תצטרך לכל היותר <span dir="ltr">4</span> צעדים כדי למצוא את השם. אם בספר יש <span dir="ltr">32</span> עמודים, תצטרך לכל היותר <span dir="ltr">5</span> צעדים. כמות העבודה גדלה הרבה יותר לאט מגודל המשימה. זה נקרא <strong><span dir="ltr">O(log n)</span></strong> (נקרא &quot;או של לוג <span dir="ltr">n</span>&quot;).</p></li>

<li><p dir="rtl">אלגוריתם <strong><span dir="ltr">O(n)</span></strong> הופך איטי יותר <em>בפרופורציה ישרה</em> לגידול בגודל המשימה.</p></li>
<li><p dir="rtl">אלגוריתם <strong><span dir="ltr">O(log n)</span></strong> הופך איטי יותר <em>הרבה יותר לאט</em> מגידול בגודל המשימה.</p></li>
</ul>

<p dir="rtl">תאר לעצמך שאתה מפתח מנוע חיפוש. אם תשתמש באלגוריתם <span dir="ltr">O(n)</span> לחיפוש באינטרנט (המכיל מיליארדי דפי אינטרנט), זה ייקח זמן רב להפליא! ואלגוריתם <span dir="ltr">O(log n)</span> יטפל במשימה זו הרבה יותר מהר.</p>

<h3 dir="rtl">סוגים עיקריים של סיבוכיות אלגוריתמים</h3>

<p dir="rtl">להלן כמה מהסוגים הנפוצים ביותר של סיבוכיות:</p>

<ul>
<li><p dir="rtl"><strong><span dir="ltr">O(1)</span> – סיבוכיות קבועה:</strong> זמן הריצה תמיד זהה, ללא קשר לגודל המשימה. לדוגמה, קבלת האלמנט הראשון מרשימה.</p>

<pre class="line-numbers"><code class="language-python">def get_first_element(my_list):
    """O(1) - Get the first element in the list."""
    return my_list[0]
</code></pre>
</li>

<li><p dir="rtl"><strong><span dir="ltr">O(log n)</span> – סיבוכיות לוגריתמית:</strong> זמן הריצה גדל לאט מאוד עם גידול בגודל המשימה. דוגמה מצוינת היא חיפוש בינארי.</p>

<pre class="line-numbers"><code class="language-python">def binary_search(my_list, target):
    """O(log n) - Binary search in a sorted list."""
    low = 0
    high = len(my_list) - 1

    while low <= high:
        mid = (low + high) // 2
        if my_list[mid] == target:
            return mid
        elif my_list[mid] < target:
            low = mid + 1
        else:
            high = mid - 1
    return -1  # Element not found
</code></pre>
</li>

<li><p dir="rtl"><strong><span dir="ltr">O(n)</span> – סיבוכיות לינארית:</strong> זמן הריצה גדל בפרופורציה ישרה לגודל המשימה. לדוגמה, מעבר על כל אלמנט ברשימה.</p>

<pre class="line-numbers"><code class="language-python">def linear_search(my_list, target):
    """O(n) - Linear search in a list."""
    for i in range(len(my_list)):
        if my_list[i] == target:
            return i
    return -1  # Element not found
</code></pre>
</li>

<li><p dir="rtl"><strong><span dir="ltr">O(n log n)</span> – סיבוכיות לינארית-לוגריתמית:</strong> נפוץ באלגוריתמי מיון יעילים, כגון מיון מיזוג ומיון מהיר.</p>

<pre class="line-numbers"><code class="language-python">def merge_sort(my_list):
    """O(n log n) - Merge sort."""
    if len(my_list) <= 1:
        return my_list

    mid = len(my_list) // 2
    left = merge_sort(my_list[:mid])
    right = merge_sort(my_list[mid:])

    return merge(left, right)

def merge(left, right):
    """Helper function for merge_sort."""
    merged = []
    i = j = 0

    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            merged.append(left[i])
            i += 1
        else:
            merged.append(right[j])
            j += 1

    merged.extend(left[i:])
    merged.extend(right[j:])
    return merged
</code></pre>
</li>

<li><p dir="rtl"><strong><span dir="ltr">O(n^2)</span> – סיבוכיות ריבועית:</strong> זמן הריצה גדל <em>בריבוע</em> של גודל המשימה. לדוגמה, השוואת כל אלמנט ברשימה לכל אלמנט אחר באותה רשימה.</p>

<pre class="line-numbers"><code class="language-python">def bubble_sort(my_list):
    """O(n^2) - Bubble sort."""
    n = len(my_list)
    for i in range(n):
        for j in range(0, n-i-1):
            if my_list[j] > my_list[j+1] :
                my_list[j], my_list[j+1] = my_list[j+1], my_list[j]
</code></pre>
</li>

<li><p dir="rtl"><strong><span dir="ltr">O(2^n)</span> – סיבוכיות אקספוננציאלית:</strong> זמן הריצה גדל במהירות רבה עם גידול בגודל המשימה. נפוץ באלגוריתמים המשתמשים בכוח גס.</p>

<pre class="line-numbers"><code class="language-python">def fibonacci_recursive(n):
  """O(2^n) - Recursive calculation of Fibonacci number."""
  if n <= 1:
      return n
  return fibonacci_recursive(n-1) + fibonacci_recursive(n-2)
</code></pre>
</li>

<li><p dir="rtl"><strong><span dir="ltr">O(n!)</span> – סיבוכיות עצרתית:</strong> סוג הסיבוכיות האיטי ביותר. מתרחש בעת מעבר על כל התמורות האפשריות של אלמנטים.</p></li>
</ul>

<h3 dir="rtl">דוגמאות לבעיות ואלגוריתמים עם סיבוכיות שונה</h3>

<p dir="rtl">בואו נסתכל על כמה דוגמאות לבעיות ואלגוריתמים שונים לפתרונן, כדי לראות כיצד הסיבוכיות משפיעה על הביצועים.</p>

<p dir="rtl"><strong>1. מיון רשימה:</strong></p>

<ul>
<li><p dir="rtl"><strong>משימה:</strong> למיין רשימת אלמנטים בסדר מסוים (לדוגמה, בסדר עולה).</p></li>
<li><p dir="rtl"><strong>אלגוריתמים:</strong></p>
<ul>
<li><p dir="rtl"><strong>מיון בועות (<span dir="ltr">Bubble Sort</span>):</strong></p>

<pre class="line-numbers"><code class="language-python">def bubble_sort(my_list):
    n = len(my_list)
    for i in range(n):
        for j in range(0, n-i-1):
            if my_list[j] > my_list[j+1] :
                my_list[j], my_list[j+1] = my_list[j+1], my_list[j]
# Example usage
my_list = [64, 34, 25, 12, 22, 11, 90]
bubble_sort(my_list)
print("מערך ממוין:", my_list) # Output: [11, 12, 22, 25, 34, 64, 90]
</code></pre>
</li>

<li><p dir="rtl"><strong>מיון מיזוג (<span dir="ltr">Merge Sort</span>):</strong></p>

<pre class="line-numbers"><code class="language-python">def merge_sort(my_list):
    if len(my_list) <= 1:
        return my_list

    mid = len(my_list) // 2
    left = merge_sort(my_list[:mid])
    right = merge_sort(my_list[mid:])

    return merge(left, right)

def merge(left, right):
    merged = []
    i = j = 0

    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            merged.append(left[i])
            i += 1
        else:
            merged.append(right[j])
            j += 1

    merged.extend(left[i:])
    merged.extend(right[j:])
    return merged

# Example usage
my_list = [64, 34, 25, 12, 22, 11, 90]
sorted_list = merge_sort(my_list)
print("מערך ממוין:", sorted_list) # Output: [11, 12, 22, 25, 34, 64, 90]
</code></pre>
</li>
</ul>
</li>
<li><p dir="rtl"><strong>מסקנה:</strong> עבור רשימות גדולות של אלמנטים, אלגוריתמים עם <span dir="ltr">O(n log n)</span> (מיון מיזוג) עדיפים על אלגוריתמים עם <span dir="ltr">O(n^2)</span> (מיון בועות).</p></li>
</ul>

<p dir="rtl"><strong>2. מציאת המסלול הקצר ביותר בגרף:</strong></p>

<ul>
<li><p dir="rtl"><strong>משימה:</strong> למצוא את המסלול הקצר ביותר בין שני צמתים בגרף (לדוגמה, בין שתי ערים על מפה).</p></li>
<li><p dir="rtl"><strong>אלגוריתמים:</strong></p>
<ul>
<li><p dir="rtl"><strong>אלגוריתם דייקסטרה (<span dir="ltr">Dijkstra's Algorithm</span>):</strong></p>

<pre class="line-numbers"><code class="language-python">import heapq

def dijkstra(graph, start):
    """Dijkstra's algorithm for finding the shortest paths."""
    distances = {node: float('inf') for node in graph}
    distances[start] = 0
    priority_queue = [(0, start)]  # (distance, node)

    while priority_queue:
        distance, node = heapq.heappop(priority_queue)

        if distance > distances[node]:
            continue

        for neighbor, weight in graph[node].items():
            new_distance = distance + weight
            if new_distance < distances[neighbor]:
                distances[neighbor] = new_distance
                heapq.heappush(priority_queue, (new_distance, neighbor))

    return distances

# Example usage
graph = {
    'A': {'B': 5, 'C': 1},
    'B': {'A': 5, 'C': 2, 'D': 1},
    'C': {'A': 1, 'B': 2, 'D': 4, 'E': 8},
    'D': {'B': 1, 'C': 4, 'E': 3, 'F': 6},
    'E': {'C': 8, 'D': 3},
    'F': {'D': 6}
}
start_node = 'A'
shortest_paths = dijkstra(graph, start_node)
print(f"המסלולים הקצרים ביותר מ-{start_node}: {shortest_paths}")
</code></pre>
</li>
</ul>
</li>
<li><p dir="rtl"><strong>מסקנה:</strong> בחירת האלגוריתם תלויה בסוג הגרף (משוקלל/לא משוקלל, נוכחות משקלים שליליים) ובגודל הגרף. אלגוריתם דייקסטרה יעיל עבור גרפים עם משקלים לא שליליים.</p></li>
</ul>

<p dir="rtl"><strong>3. חיפוש תת-מחרוזת במחרוזת:</strong></p>

<ul>
<li><p dir="rtl"><strong>משימה:</strong> למצוא את כל המופעים של תת-מחרוזת ספציפית במחרוזת גדולה יותר.</p></li>
<li><p dir="rtl"><strong>אלגוריתמים:</strong></p>
<ul>
<li><p dir="rtl"><strong>חיפוש מחרוזות נאיבי (<span dir="ltr">Naive String Search</span>):</strong></p>

<pre class="line-numbers"><code class="language-python">def naive_string_search(text, pattern):
    """Naive string search algorithm."""
    occurrences = []
    for i in range(len(text) - len(pattern) + 1):
        if text[i:i+len(pattern)] == pattern:
            occurrences.append(i)
    return occurrences

# Example usage
text = "This is a simple example text."
pattern = "example"
occurrences = naive_string_search(text, pattern)
print(f"מופעים של '{pattern}' בטקסט: {occurrences}")  # Output: [17]
</code></pre>
</li>
</ul>
</li>
<li><p dir="rtl"><strong>מסקנה:</strong> עבור חיפושי תת-מחרוזות תכופים במחרוזות גדולות, קיימים אלגוריתמים יעילים יותר, כגון <span dir="ltr">KMP</span>.</p></li>
</ul>

<p dir="rtl"><strong>4. בעיית התרמיל (<span dir="ltr">Knapsack Problem</span>):</strong></p>

<ul>
<li><p dir="rtl"><strong>משימה:</strong> יש לך תרמיל בקיבולת מסוימת וקבוצת פריטים עם משקלים וערכים שונים. עליך לבחור פריטים שימקסמו את הערך הכולל, מבלי לחרוג מקיבולת התרמיל.</p></li>
<li><p dir="rtl"><strong>אלגוריתמים:</strong></p>
<ul>
<li><p dir="rtl"><strong>תכנות דינמי (<span dir="ltr">Dynamic Programming</span>):</strong></p>

<pre class="line-numbers"><code class="language-python">def knapsack_dynamic_programming(capacity, weights, values, n):
    """Solving the knapsack problem using dynamic programming."""
    dp = [[0 for x in range(capacity + 1)] for x in range(n + 1)]

    for i in range(n + 1):
        for w in range(capacity + 1):
            if i == 0 or w == 0:
                dp[i][w] = 0
            elif weights[i-1] <= w:
                dp[i][w] = max(values[i-1] + dp[i-1][w-weights[i-1]],  dp[i-1][w])
            else:
                dp[i][w] = dp[i-1][w]

    return dp[n][capacity]

# Example usage
capacity = 50
weights = [10, 20, 30]
values = [60, 100, 120]
n = len(values)
max_value = knapsack_dynamic_programming(capacity, weights, values, n)
print(f"ערך מקסימלי: {max_value}")  # Output: 220
</code></pre>
</li>
</ul>
</li>
<li><p dir="rtl"><strong>בחירת האלגוריתם תלויה בגודל הבעיה ובדרישות לדיוק הפתרון.</strong></p></li>
</ul>

<h3 dir="rtl">סימון <span dir="ltr">O</span>: פישוט הסיבוכיות</h3>

<p dir="rtl">בדרך כלל, סיבוכיות מתוארת באמצעות &quot;סימון <span dir="ltr">O</span> גדול&quot; (<span dir="ltr">O-notation</span>). הוא מראה כמה מהר זמן הריצה של האלגוריתם גדל עם גידול בגודל המשימה, <em>אסימפטוטית</em>, כלומר, עבור ערכים גדולים מאוד של <span dir="ltr"><code>n</code></span>. קבועים קטנים ופרטי מימוש בדרך כלל מתעלמים. לדוגמה, אלגוריתם שמבצע <span dir="ltr"><code>2n + 5</code></span> פעולות עדיין נחשב <em><span dir="ltr">O(n)</span></em>.</p>

<h3 dir="rtl">מקרה הגרוע ביותר, מקרה ממוצע, מקרה הטוב ביותר</h3>

<p dir="rtl">סיבוכיות אלגוריתם יכולה להיות תלויה בנתוני הקלט. בדרך כלל מדברים על סיבוכיות <em>במקרה הגרוע ביותר</em> – זוהי הכמות המקסימלית של זמן או משאבים שאלגוריתם עשוי לדרוש. לעיתים מנתחים גם את הסיבוכיות במקרה הממוצע ובמקרה הטוב ביותר.</p>