# קבוצות (סטים) בפייתון

**1. מבוא: מהן קבוצות?**

במדעי המחשב ובמתמטיקה, קבוצות – זוהי דרך לייצג אוספים של אלמנטים ייחודיים. חשוב להבין ש:

*   **ייחודיות:** כל אלמנט בקבוצה חייב להיות ייחודי. חזרות אינן מותרות.
*   **אי-סדר:** סדר האלמנטים בקבוצה אינו חשוב.


**2. קבוצות ופירות**

נדמיין שיש לנו רק את הפירות עצמם:

*   🍎 (תפוח)
*   🍐 (אגס)
*   🍉 (אבטיח)
*   🧺 (סלסלה)

חשוב ש:

1.  **בסט *אין* פירות זהים:** אם בסט יש תפוח, לא יהיה שם תפוח זהה נוסף. כל פרי ייחודי בסט שלו.
2.  **סדר הפירות אינו חשוב:** אם בסט יש תפוח ואגס, זה אותו דבר כאילו היו שם אגס ותפוח. הסדר אינו משנה.

לדוגמה, `{🍎, 🍐, 🍉}` — זוהי קבוצה, שבה יש תפוח, אגס ואבטיח.

**3. מדוע קבוצות דורשות ייחודיות של אלמנטים?**

*   קבוצות מיועדות למעקב אחר *נוכחות* אלמנטים, ולא אחר *כמותם*.
*   ייחודיות האלמנטים מפשטת את ביצוע הפעולות על קבוצות.
*   קבוצות משמשות למניעת יתירות נתונים.

**4. פעולות על קבוצות (סטים של פירות):**

1.  **איחוד (Union): "אוספים את כל הפירות לסט אחד"**
    *   מאחדים שני סטים של פירות, אוספים את כל הפירות לסט חדש. אם בשני הסטים יש פירות זהים, בסט החדש יהיה רק פרי אחד כזה.
    *   אם בסט A יש {🍎, 🍐}, ובסט B יש {🍐, 🍉}, אז בסט A ∪ B יהיה {🍎, 🍐, 🍉}.

2.  **חיתוך (Intersection): "מוצאים פירות משותפים"**
    *   מחפשים *רק* את הפירות שנמצאים גם בסט A וגם בסט B.
    *   אם בסט A יש {🍎, 🍐}, ובסט B יש {🍐, 🍉}, אז בסט A ∩ B יהיה רק {🍐}.

3.  **הפרש (Difference): "פירות שנמצאים בסט אחד, אך לא באחר"**
    *   מחפשים *רק* את הפירות שנמצאים בסט A, אך אינם נמצאים בסט B.
    *   אם בסט A יש {🍎, 🍐}, ובסט B יש {🍐, 🍉}, אז בסט A - B יהיה {🍎}, ובסט B - A יהיה {🍉}.

4.  **הפרש סימטרי (Symmetric Difference): "פירות שנמצאים רק באחד מהסטים"**
    *   מחפשים *את כל* הפירות שנמצאים בסט A או בסט B, אך לא בשניהם בו זמנית.
    *   אם בסט A יש {🍎, 🍐}, ובסט B יש {🍐, 🍉}, אז בסט A ^ B יהיה {🍎, 🍉}.

5.  **תת-קבוצה (Subset): "האם כל הפירות מסט אחד נמצאים באחר?"**
    *   בודקים האם סט A הוא תת-קבוצה של סט B. זה אומר שכל הפירות מסט A נמצאים גם בסט B.
    *   **דוגמה:** אם בסט A יש {🍎, 🍐}, ובסט B יש {🍎, 🍐, 🍉}, אז A <= B.

6.  **על-קבוצה (Superset): "האם סט אחד מכיל את כל הפירות מסט אחר?"**
    *   בודקים האם סט A הוא על-קבוצה של סט B. זה אומר שכל הפירות מסט B נמצאים גם בסט A.
    *   אם בסט A יש {🍎, 🍐, 🍉}, ובסט B יש {🍎, 🍐}, אז A >= B.



```python
from typing import Set

def create_fruit_set(fruit_string: str) -> Set[str]:
    """
    יוצר קבוצת פירות ממחרוזת.

    Args:
        fruit_string: מחרוזת פירות (🍎, 🍐, 🍉, 🧺).

    Returns:
        קבוצת פירות ייחודיים.
    """
    if not all(fruit in ["🍎", "🍐", "🍉", "🧺"] for fruit in fruit_string):
        raise ValueError("מחרוזת יכולה להכיל רק סמלים 🍎, 🍐, 🍉, 🧺")
    return set(fruit_string)  # השתמש ב-set() ליצירת קבוצה

def display_set(fruit_set: Set[str]) -> str:
  """
  ממיר קבוצת פירות למחרוזת להצגה.

    Args:
        fruit_set: קבוצת פירות.

    Returns:
        מחרוזת להצגה.
  """
  return "{" + ", ".join(fruit_set) + "}"


# יוצרים קבוצות פירות
fruits_set_A = create_fruit_set("🍎🍐")  # קבוצה A: {🍎, 🍐}
fruits_set_B = create_fruit_set("🍐🍉")  # קבוצה B: {🍐, 🍉}
fruits_set_C = create_fruit_set("🍎🍐🍉")  # קבוצה C: {🍎, 🍐, 🍉}
fruits_set_D = create_fruit_set("🧺")  # קבוצה D: {🧺}

# מדפיסים קבוצות
print(f"קבוצה A: {display_set(fruits_set_A)}")
print(f"קבוצה B: {display_set(fruits_set_B)}")
print(f"קבוצה C: {display_set(fruits_set_C)}")
print(f"קבוצה D: {display_set(fruits_set_D)}")

# איחוד קבוצות (Union)
union_result = fruits_set_A | fruits_set_B
print(f"A ∪ B: {display_set(union_result)}")  # תוצאה: {🍎, 🍐, 🍉}

# חיתוך קבוצות (Intersection)
intersection_result = fruits_set_A & fruits_set_B
print(f"A ∩ B: {display_set(intersection_result)}")  # תוצאה: {🍐}

# הפרש קבוצות (Difference)
difference_result_AB = fruits_set_A - fruits_set_B
print(f"A - B: {display_set(difference_result_AB)}")  # תוצאה: {🍎}
difference_result_BA = fruits_set_B - fruits_set_A
print(f"B - A: {display_set(difference_result_BA)}")  # תוצאה: {🍉}

# הפרש סימטרי של קבוצות (Symmetric Difference)
symmetric_difference_result = fruits_set_A ^ fruits_set_B
print(f"A ^ B: {display_set(symmetric_difference_result)}")  # תוצאה: {🍎, 🍉}

# תת-קבוצה (Subset)
subset_result1 = fruits_set_A <= fruits_set_C
print(f"A <= C: {subset_result1}")  # תוצאה: True (A היא תת-קבוצה של C)
subset_result2 = fruits_set_A <= fruits_set_B
print(f"A <= B: {subset_result2}") # תוצאה: False (A אינה תת-קבוצה של B)

# על-קבוצה (Superset)
superset_result1 = fruits_set_C >= fruits_set_A
print(f"C >= A: {superset_result1}")  # תוצאה: True (C היא על-קבוצה של A)
superset_result2 = fruits_set_B >= fruits_set_A
print(f"B >= A: {superset_result2}")  # תוצאה: False (B אינה על-קבוצה של A)

# בדיקת נוכחות אלמנט
print(f"🍎 ב-A: {'🍎' in fruits_set_A}")  # תוצאה: True
print(f"🍉 ב-A: {'🍉' in fruits_set_A}")  # תוצאה: False
```

*   **`create_fruit_set(fruit_string)`:** פונקציה זו יוצרת קבוצה ממחרוזת פירות.
    *   `set(fruit_string)` הופך את המחרוזת לקבוצה, מסיר כפילויות והופך את סדר האלמנטים ללא רלוונטי.
    *   אנו בודקים שהמחרוזת מורכבת רק מתווי יוניקוד מותרים.
*   **`display_set(fruit_set)`:** פונקציה זו משמשת להמרת קבוצה למחרוזת קריאה לצורך פלט.
*   **דוגמאות:** אנו יוצרים מספר קבוצות ומפעילים עליהן פעולות שונות. תוצאות כל פעולה מודפסות למסך.



**5. משימות לתרגול:**

1.  צור קבוצות פירות משלך ונסה את כל הפעולות עליהן.
2.  יישם את הפונקציה `is_disjoint(set1, set2)`, שתבדוק האם שתי קבוצות זרות זו לזו (חיתוך = קבוצה ריקה).
3.  יישם את הפונקציה `power_set(fruit_set)`, שתחזיר את קבוצת כל תתי-הקבוצות של קבוצה נתונה.
4.  נסה ליישם קבוצות לפתרון בעיה אמיתית. לדוגמה, יש לך שתי רשימות אורחים למסיבה, מצא אורחים שנמצאים בשתי הרשימות, אורחים שנמצאים רק ברשימה הראשונה וכו'.
