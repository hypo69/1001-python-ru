# סינגלטון (Singleton) ב-`Python`

ב-`Python`, סינגלטון – זוהי תבנית עיצוב המבטיחה שלמחלקה יהיה רק מופע אחד, ומספקת נקודת גישה גלובלית למופע זה. זה אומר שבעת ניסיון ליצור אובייקט חדש של מחלקה זו, תמיד תקבל את אותו אובייקט.

סינגלטונים שימושיים כאשר יש צורך להגביל את מספר המופעים של מחלקה, לדוגמה:

*   לניהול חיבור לבסיס נתונים (כדי לא לפתוח חיבורים רבים).
*   לאחסון תצורת יישום גלובלית (כדי שכל חלקי היישום ישתמשו באותה תצורה).
*   לרישום (כדי שכל ההודעות יגיעו לקובץ אחד).

כמה דרכים ליישום סינגלטון ב-`Python`.

<hr>

**דרכים ליישום סינגלטון:**

1.  **באמצעות דריסת שיטת `__new__`**

    *   השיטה `__new__` אחראית על יצירת מופע של מחלקה. על ידי דריסתה, אוכל לשלוט בתהליך זה.
    *   בדוגמה זו אשמור את המופע היחיד של המחלקה במשתנה `_instance`.
    *   אם המופע עדיין לא נוצר, אצור אותו; אחרת, אחזיר את המופע הקיים.
    *   **קוד `Python`:**

        ```python
        class Singleton:
            _instance = None  # שומר את המופע היחיד

            def __new__(cls, *args, **kwargs):
                """
                דורס את שיטת __new__ כדי לשלוט ביצירת מופע.

                Args:
                    cls: המחלקה שעבורה נוצר המופע.
                    *args: ארגומנטים מיקומיים לבנאי.
                    **kwargs: ארגומנטים בעלי שם לבנאי.

                Returns:
                    המופע היחיד של המחלקה.
                """
                if not cls._instance: # אם המופע עדיין לא נוצר
                    cls._instance = super().__new__(cls, *args, **kwargs) # יוצר מופע חדש
                return cls._instance # מחזיר את המופע הקיים

        # דוגמה לשימוש
        s1 = Singleton()
        s2 = Singleton()

        print(s1 is s2)  # יוציא True, מכיוון שזהו אותו אובייקט
        ```
<hr>

2.  **באמצעות דקורטור**

    *   דקורטור – זוהי פונקציה המשנה מחלקה.
    *   בדוגמה זו אצור פונקציית דקורטור `singleton`, המקבלת מחלקה ומחזירה את גרסתה העטופה.
    *   בתוך הדקורטור אשמור את מופעי המחלקות במילון `instances`.
    *   אם מופע המחלקה עדיין לא נוצר, אצור אותו ואשמור אותו במילון; אחרת, אחזיר את המופע הקיים.
    *   **קוד `Python`:**

        ```python
        def singleton(cls):
            """
            דקורטור ליצירת סינגלטון.

            Args:
                cls: המחלקה שיש להפוך לסינגלטון.

            Returns:
                המחלקה שהשתנתה, שהיא סינגלטון.
            """
            instances = {} # שומר מופעים

            def wrapper(*args, **kwargs):
                """
                פונקציית עטיפה המחזירה את המופע היחיד של המחלקה.

                Args:
                   *args: ארגומנטים מיקומיים לבנאי.
                   **kwargs: ארגומנטים בעלי שם לבנאי.

                Returns:
                    המופע היחיד של המחלקה.
                """
                if cls not in instances: # אם המופע עדיין לא נוצר
                    instances[cls] = cls(*args, **kwargs) # יוצר מופע ושומר אותו
                return instances[cls] # מחזיר את המופע הקיים
            return wrapper

        @singleton # מיישם את הדקורטור על המחלקה
        class MyClass:
            pass

        # דוגמה לשימוש
        obj1 = MyClass()
        obj2 = MyClass()

        print(obj1 is obj2)  # יוציא True, מכיוון שזהו אותו אובייקט
        ```
<hr>

3.  **באמצעות מטא-מחלקה**

    *   מטא-מחלקה מאפשרת לשלוט ביצירת מחלקות.
    *   בדוגמה זו אצור מטא-מחלקה `SingletonMeta`, שתפקח על יצירת מופעים.
    *   המטא-מחלקה שומרת מופעי מחלקות במילון `_instances`.
    *   בעת יצירת מופע חדש, אבדוק אם הוא כבר קיים במילון; אם לא – אצור אותו; אחרת, אחזיר את המופע הקיים.
    *   **קוד `Python`:**

        ```python
        class SingletonMeta(type):
            """
            מטא-מחלקה ליצירת סינגלטון.
            """
            _instances = {} # שומר מופעים

            def __call__(cls, *args, **kwargs):
                """
                דורס את שיטת __call__ כדי לשלוט ביצירת מופע.

                Args:
                    cls: המחלקה שעבורה נוצר המופע.
                    *args: ארגומנטים מיקומיים לבנאי.
                    **kwargs: ארגומנטים בעלי שם לבנאי.

                Returns:
                    המופע היחיד של המחלקה.
                """
                if cls not in cls._instances: # אם המופע עדיין לא נוצר
                    cls._instances[cls] = super().__call__(*args, **kwargs) # יוצר מופע חדש
                return cls._instances[cls] # מחזיר את המופע הקיים

        class Singleton(metaclass=SingletonMeta):
            """
            מחלקה שהיא סינגלטון.
            """
            pass

        # דוגמה לשימוש
        s1 = Singleton()
        s2 = Singleton()

        print(s1 is s2)  # יוציא True, מכיוון שזהו אותו אובייקט
             ```
  <hr> 

4.  **באמצעות מודול**

    *   ב-`Python` מודול הוא סינגלטון בפני עצמו.
    *   אני יכול ליצור אובייקט במודול, והוא יהיה המופע היחיד.
    *   **קוד `Python`:**
        ```python
        # קובץ singleton.py
        class Singleton:
            pass

        instance = Singleton()
        ```
        ```python
        # בקובץ אחר
        from singleton import instance

        obj1 = instance
        obj2 = instance

        print(obj1 is obj2)  # יוציא True, מכיוון שזהו אותו אובייקט
        ```

**יתרונות הסינגלטון:**

*   **הבטחת מופע יחיד:** סינגלטון מבטיח שלמחלקה יהיה רק מופע אחד. זה שימושי לניהול משאבים שחייבים להיות ייחודיים.
*   **גישה גלובלית:** סינגלטון מספק נקודת גישה גלובלית למופע המחלקה, מה שמפשט את השימוש במופע זה בכל חלק בתוכנית.

**חסרונות הסינגלטון:**

*   **מצב גלובלי:** סינגלטון יכול להוביל לשימוש במצב גלובלי, מה שעלול לגרום לתופעות לוואי בלתי צפויות ולסבך את הבדיקות.
*   **הפרת עקרונות OOP:** סינגלטון יכול להפר את עקרון האחריות היחידה ואת האנקפסולציה.

**מתי להשתמש בסינגלטון?**

*   כאשר אתה צריך שאובייקט יתקיים כמופע יחיד (לדוגמה, תצורה, לוגר, חיבור לבסיס נתונים).
*   כאשר אתה זקוק לגישה גלובלית לאובייקט זה.
