# ייבוא מודולים בפייתון

ייבוא ספריות בפייתון מאפשר להשתמש במודולים ופונקציות חיצוניים או משלך, המוגדרים בקבצים או ספריות אחרות. זה עוזר לארגן את הקוד, לשפר את קריאותו ולמנוע כפילויות.

### מהם מודולים?
מודול בפייתון הוא פשוט קובץ עם סיומת `.py`, המכיל קוד (פונקציות, מחלקות, משתנים וכו'). כאשר אתה רוצה להשתמש בקוד ממודול אחר, עליך לייבא אותו לקובץ הנוכחי.

### מודולים חיצוניים ופנימיים
1. **מודולים חיצוניים** — אלו מודולים שאינם חלק מהספרייה הסטנדרטית של פייתון ויש להתקין אותם בנפרד. לדוגמה, מודולים לעבודה עם שרת אינטרנט, עיבוד נתונים או למידת מכונה, כגון `numpy`, `requests` ואחרים.

2. **מודולים פנימיים** — אלו מודולים שכבר כלולים בספרייה הסטנדרטית של פייתון. לדוגמה, מודולים לעבודה עם קבצים, זמן, פעולות מתמטיות: `os`, `math`, `datetime`.

### התקנת מודולים חיצוניים באמצעות pip
כדי להתקין מודול חיצוני, נשתמש בפקודה `pip` — זהו כלי לניהול חבילות פייתון. לדוגמה, כדי להתקין את ספריית `requests`, יש להריץ את הפקודה הבאה בטרמינל:
```bash
pip install requests
```
פקודה זו תוריד ותתקין את הספרייה בפרויקט שלך.

### ייבוא מודולים
כאשר אתה רוצה להשתמש במודול בפייתון, עליך לייבא אותו:
1. **ייבוא מודול שלם**:
   ```python
   import os
   ```
   לאחר מכן תוכל להשתמש בכל הפונקציות והמשתנים מהמודול, לדוגמה:
   ```python
   os.listdir()  # רשימת קבצים בספרייה
   ```

2. **ייבוא אלמנטים ספציפיים ממודול**:
   ```python
   from math import sqrt
   ```
   כעת ניתן להשתמש בפונקציה `sqrt` ללא צורך לפנות למודול `math`.

3. **ייבוא עם כינוי**:
   ```python
   import pandas as pd
   ```
   במקרה זה, כדי להשתמש בפונקציות של ספריית `pandas`, תכתוב `pd`, ולא את השם המלא `pandas`.

### ייבוא מודולים משלך
אם אתה כותב מספר קבצים בפרויקט אחד, ניתן ליצור מודולים משלך. לדוגמה, אם יש לך קובץ `utils.py` עם פונקציות שימושיות, תוכל לייבא אותו לקבצים אחרים כך:
```python
import utils
```
או לייבא פונקציה ספציפית:
```python
from utils import my_function
```

### למה ליצור מודול אחד ולייבא אותו לחלקים אחרים של הפרויקט?
1. **ארגון קוד**: הפרדת לוגיקה למודולים שונים עוזרת למנוע בלאגן בפרויקט גדול. לדוגמה, ניתן ליצור מודול לעבודה עם נתונים, אחר לעיבוד בקשות, ושלישי לממשק.
   
2. **שימוש חוזר בקוד**: כאשר לוגיקה מופרדת למודולים, ניתן להשתמש בה בחלקים שונים של הפרויקט. זה מפחית כפילויות קוד ומקל על תחזוקה.

3. **קריאות ותחזוקתיות**: כאשר קוד מופרד למודולים, מפתחים אחרים (או אתה בעצמך בעתיד) יוכלו להבין ולתחזק את הפרויקט בקלות רבה יותר.

דוגמה:
```python
# utils.py
def greet(name):
    return f"Hello, {name}!"
    
# main.py
from utils import greet

print(greet("Alice"))
```

בדוגמה זו, הפונקציה `greet` מוגדרת במודול אחד (`utils.py`), אך משמשת במודול אחר (`main.py`), מה שמשפר את המבנה והופך את הקוד למודולרי ונוח יותר לשינוי.

---

  [לתוכן העניינים](https://github.com/hypo69/101_python_computer_games_ru/blob/master/cheat_sheets#readme)
