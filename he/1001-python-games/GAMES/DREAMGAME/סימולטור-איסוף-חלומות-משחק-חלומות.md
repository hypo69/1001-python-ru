מחבר הקוד המקורי:
https://github.com/Mstislav95/CashFlow_101/blob/main/CashFlow_model.ipynb

https://ok4u.club/cashflow101-rules/

https://www.youtube.com/watch?v=sG_RWsvYT7k&ab_channel=MstislavEfimov


# משחק חלומות: סימולטור איסוף "חלומות"

## תיאור

סימולציה של משחק שבו השחקן נע על לוח המשחק, מטיל שתי קוביות בעלות שישה צדדים. 
על חלק מהתאים בלוח ממוקמים "חלומות", שהשחקן יכול "לאסוף". 
מטרת המשחק - להבין אילו "חלומות" הם הסבירים ביותר לאיסוף תחת הכללים הנתונים.

## כללי המשחק

1.  השחקן מתחיל את המשחק במיקום ההתחלתי (נניח שהוא 0).
2.  בתור אחד, השחקן מטיל שתי קוביות בעלות שישה צדדים ונע מספר תאים השווה לסכום הערכים שהתקבלו.
3.  לוח המשחק מכיל 48 תאים. אם השחקן נע מעבר לתא ה-48, הוא חוזר להתחלה, "מסתובב" על הלוח (לדוגמה, אם המיקום הנוכחי הוא 47 והתקבל 4, המיקום החדש יהיה 3).
4.  על חלק מהתאים (המצוינים ברשימת `dream_numbers`) נמצאים "חלומות".
5.  אם השחקן נוחת על תא עם "חלום" ועדיין לא ביקר בו באיטרציה הנוכחית, ה"חלום" נחשב שנאסף.
6.  המשחק נמשך מספר מהלכים מוגדר (`moves`).
7.  המשחק מדומה מספר פעמים מוגדר (`num_iterations`).
8.  כתוצאה מפעולת התוכנית, מחושבת תדירות איסוף כל "חלום" וההסתברות לאיסופו.

## תכונות קוד

*   **מודלים**: הקוד מדמה את תנועת השחקן על לוח המשחק באמצעות הטלות קוביות.
*   **איסוף "חלומות"**: הקוד עוקב מתי השחקן נוחת על תאים עם "חלומות" וסופר את מספרם.
*   **ניתוח**: התוכנית מנתחת את תוצאות הסימולציה ומחשבת את התדירות וההסתברות לאיסוף כל "חלום".
*   **מחלקה `DreamGame`**: הקוד עטוף במחלקה `DreamGame`, מה שהופך אותו למובנה יותר וניתן לשימוש חוזר.
*   **יצירת שמות חלומות**: שמות "חלומות" נוצרים באמצעות מודל Gemini, מה שהופך כל משחק לייחודי.
*   **אופטימיזציה**: הקוד מותאם באמצעות `collections.Counter` לספירת תדירויות וגנרטורים לאיטרציה על סימולציות.

## יכולות

*   **התאמה אישית של פרמטרים**: ניתן להתאים בקלות את מספר המהלכים למשחק (`moves`) ואת מספר סימולציות המשחק (`num_iterations`).
*   **שמות דינמיים**: שמות "חלומות" נוצרים באופן דינמי באמצעות מודל Gemini, מה שמוסיף גיוון למשחק.
*   **ניתוח הסתברויות**: קבלת ההסתברות לאיסוף כל "חלום" מאפשרת לנתח ולהשוות את זמינותם.
*   **הרחבה**: הקוד ניתן להרחבה בקלות וניתן לשנותו כדי להוסיף מכניקות משחק חדשות.

## פירוק קוד

### מחלקה `DreamGame`

המחלקה `DreamGame` עוטפת את כל לוגיקת המשחק.

#### `__init__(self, dream_numbers: List[int], moves: int = 3, num_iterations: int = 100_000)`

בנאי המחלקה, המאתחל את המשחק:

*   `dream_numbers`: רשימת מספרים, המייצגים מיקומי "חלומות".
*   `moves`: מספר מהלכים למשחק אחד.
*   `num_iterations`: מספר סימולציות המשחק.
*   `self.dreams`: מילון, המקשר מספרי חלומות לשמותיהם. מאוכלס באמצעות `_generate_dream_names`.

#### `_generate_dream_names(self) -> None`

שיטה המייצרת שמות "חלומות" באמצעות מודל Gemini.

*   יוצרת בקשה למודל Gemini ליצירת מספר מוגדר של שמות "חלומות" ייחודיים.
*   מעבדת את התשובה ויוצרת מילון `self.dreams`, המקשר מספר "חלום" לשמו.
*   מעלה שגיאה אם המודל אינו מחזיר טקסט או אינו יכול ליצור את מספר השמות הנדרש.

#### `_simulate_game(self) -> Counter[str]`

שיטה המדמה משחק אחד:

*   מאתחלת מונה `dreams_frequency` למעקב אחר תדירות איסוף "חלומות".
*   מאתחלת את המשתנה `square`, המייצג את מיקום השחקן הנוכחי על הלוח, ואת `visited_dreams` למעקב אחר חלומות שנאספו.
*   מבצעת מספר מהלכים מוגדר (`moves`), ומזיזה את השחקן על לוח המשחק.
*   אם השחקן נוחת על תא עם "חלום" ועדיין לא ביקר בו, מגדילה את המונה עבור "חלום" זה.
*   מחזירה אובייקט `Counter` עם תדירות איסוף "חלומות".

#### `run_experiment(self) -> pd.DataFrame`

שיטה המריצה את סימולציית המשחק מספר פעמים ומחזירה DataFrame עם התוצאות:

*   מריצה את סימולציית המשחק מספר פעמים מוגדר (`num_iterations`).
*   מסכמת את תדירויות איסוף "חלומות" מכל סימולציה.
*   ממירה את התוצאות ל-DataFrame, כאשר העמודות הן "חלום" ו"תדירות".
*   ממיינת את ה-DataFrame בסדר יורד לפי תדירות.
*   מוסיפה עמודה "הסתברות", המחושבת כיחס בין "תדירות" למספר הכולל של סימולציות.
*   מחזירה DataFrame עם התוצאות.

### שימוש

בסוף הסקריפט נוצר מופע של המחלקה `DreamGame` והניסוי מופעל. התוצאה מודפסת למסך כ-DataFrame.

```python
if __name__ == '__main__':
    dream_numbers = [1, 3, 5, 7, 10, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47]
    game = DreamGame(dream_numbers, moves=3, num_iterations=10_000)
    df_result = game.run_experiment()
    print(df_result)
```

## דרישות

*   Python 3.6+
*   ספריות: `pandas`, `google-generativeai`
*   משתנה סביבה `GOOGLE_API_KEY` עם מפתח ה-API של Gemini שלך

## התקנה

1.  התקן Python 3.6+
2.  התקן ספריות: `pip install pandas google-generativeai`
3.  הגדר את משתנה הסביבה `GOOGLE_API_KEY` עם מפתח ה-API של Gemini שלך.
4.  הפעל את הסקריפט `python your_script_name.py`

## דוגמאות שימוש
```python
    dream_numbers = [2,4,8,16,32,44]
    game = DreamGame(dream_numbers, moves=5, num_iterations=1000)
    df_result = game.run_experiment()
    print(df_result)
```
בדוגמה זו: 
 * נוצר אובייקט משחק
 * מדומה 10,000 משחקים עם שלושה מהלכים
 * מוצגת תוצאת הסימולציה כ-pandas DataFrame.

```python
    dream_numbers = [2,4,8,16,32,44]
    game = DreamGame(dream_numbers, moves=5, num_iterations=1000)
    df_result = game.run_experiment()
    print(df_result)
```
בדוגמה זו: 
 * נוצר אובייקט משחק עם מספרי חלומות שונים
 * מדומה 1000 משחקים עם חמישה מהלכים
 * מוצגת תוצאת הסימולציה כ-pandas DataFrame.

## רישיון

MIT
