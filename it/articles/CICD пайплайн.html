<p>üöÄ <strong>CI/CD: Dalle basi alla produzione su GCP con GitHub Actions ‚Äì Una guida completa con esempi</strong> üöÄ</p>
<p>Ciao, sviluppatori! In questo articolo parler√≤ di CI/CD ‚Äì un concetto.</p>
<h3>Cos'√® una pipeline CI/CD nel contesto della programmazione?</h3>
<p><strong>Una pipeline CI/CD (Continuous Integration / Continuous Delivery o Continuous Deployment)</strong> √® un processo automatizzato che consente agli sviluppatori di consegnare rapidamente e in modo affidabile le modifiche al codice in un ambiente di produzione.</p>
<p>Analizziamo i concetti chiave:</p>
<p>üîß <strong>CI ‚Äî Continuous Integration (Integrazione Continua)</strong><br>
Questa √® una pratica in cui gli sviluppatori integrano frequentemente le modifiche in una codebase condivisa. Ogni modifica di questo tipo viene automaticamente:
*   <strong>Costruita</strong> (build)
*   <strong>Testata</strong> (test unitari, test di integrazione)
*   <strong>Verificata per la conformit√† agli standard</strong> (linting, analisi statica)
</p>
<p>üëâ **Obiettivo della CI:** Identificare gli errori il prima possibile, prima che rompano qualcosa di importante o finiscano in una release.</p>
<p>üöÄ **CD ‚Äî Continuous Delivery (Consegna Continua) o Continuous Deployment (Distribuzione Continua)**<br>
Qui ci sono due opzioni:
</p>
<p>‚úÖ **Continuous Delivery (Consegna Continua)**<br>
Dopo il successo della fase CI, le modifiche vengono automaticamente:
*   Sottoposte a test aggiuntivi (ad esempio, test E2E ‚Äì end-to-end)
*   Distribuite su un server di staging (test)
</p>
<p>üëâ **Ma la distribuzione in produzione richiede ancora una conferma manuale.** Questo d√† al team il controllo su *quando* esattamente gli utenti vedranno le modifiche.</p>
<p>ü§ñ **Continuous Deployment (Distribuzione Continua)**<br>
Questo √® il passo successivo dopo la Continuous Delivery. Qui, la distribuzione in produzione avviene **completamente automaticamente**, se tutte le fasi precedenti della pipeline (build, tutti i test) sono state completate con successo. Questo √® il livello pi√π avanzato di automazione.</p>
<h3>üîÑ Di cosa √® composta di solito una pipeline CI/CD?</h3>
<p>Una pipeline tipica include le seguenti fasi:</p>
<ol>
<li><strong>Checkout</strong> ‚Äî Clonazione dell'ultima versione del codice dal repository.</li>
<li><strong>Build</strong> ‚Äî Costruzione del progetto (compilazione, assemblaggio di artefatti, immagini Docker).</li>
<li><strong>Test</strong> ‚Äî Esecuzione di vari tipi di test (unitari, di integrazione, E2E).</li>
<li><strong>Lint/Code Quality</strong> ‚Äî Controllo del codice per la conformit√† allo stile e potenziali errori utilizzando analizzatori statici.</li>
<li><strong>Deploy</strong> ‚Äî Distribuzione dell'applicazione (su un server di staging o di produzione).</li>
<li><strong>Notify</strong> ‚Äî Invio di notifiche sullo stato della pipeline al team (ad esempio, in Slack, Email).</li>
</ol>
<h3>üõ† Strumenti popolari per CI/CD:</h3>
<ul>
<li><strong>GitHub Actions</strong> (il nostro focus oggi!)</li>
<li>GitLab CI/CD</li>
<li>Jenkins</li>
<li>CircleCI</li>
<li>Bitbucket Pipelines</li>
<li>Azure DevOps</li>
<li>TeamCity</li>
</ul>
<h3>üß† Perch√© abbiamo bisogno di CI/CD?</h3>
<ul>
<li><strong>Riduce l'errore umano:</strong> L'automazione elimina gli errori associati alle operazioni manuali.</li>
<li><strong>Rilevamento rapido dei bug:</strong> Gli errori vengono trovati prima, rendendoli pi√π facili e meno costosi da correggere.</li>
<li><strong>Automazione delle attivit√† di routine:</strong> Gli sviluppatori dedicano meno tempo alla costruzione e alla distribuzione e pi√π tempo alla codifica.</li>
<li><strong>Miglioramento della qualit√† del codice:</strong> Controlli e test continui aumentano il livello di qualit√† complessivo.</li>
<li><strong>Consegna rapida delle funzionalit√† agli utenti:</strong> Le nuove funzionalit√† raggiungono l'utente finale pi√π rapidamente e pi√π frequentemente.</li>
</ul>
<h3>üì¶ Esempi semplici di CI/CD con GitHub Actions</h3>
<p>Diamo un'occhiata alle pipeline di base per le tecnologie pi√π diffuse. Tutti gli esempi utilizzano GitHub Actions e vengono salvati nella directory <code>.github/workflows/</code> del tuo progetto.</p>
<h4>üêç CI/CD per Python (con <code>pytest</code> e <code>flake8</code>)</h4>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/python-ci.yml
name: Python CI

on: [push, pull_request]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11' # Specifica la tua versione

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt # Assicurati di avere requirements.txt
          pip install flake8 pytest

      - name: Lint with flake8
        run: |
          # Controlla il codice nelle cartelle src e tests (adatta al tuo progetto)
          flake8 src tests

      - name: Run tests
        run: |
          pytest
</code></pre>
<h4>üåê CI/CD per Node.js (con <code>npm test</code> e <code>eslint</code>)</h4>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/node-ci.yml
name: Node.js CI

on: [push, pull_request]

jobs:
  build:
    runs-on: ubuntu-latest

    strategy:
      matrix:
        node-version: [18.x] # Specifica la tua versione di Node.js

    steps:
      - uses: actions/checkout@v3

      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}

      - name: Install dependencies
        run: npm install # o npm ci per un'installazione pi√π prevedibile

      - name: Lint with ESLint
        run: npx eslint . # Assicurati che ESLint sia configurato nel progetto

      - name: Run tests
        run: npm test
</code></pre>
<h4>üê≥ CI/CD per Docker (build e push su Docker Hub)</h4>
<p>Per questo esempio, avrai bisogno dei segreti <code>DOCKER_USERNAME</code> e <code>DOCKER_PASSWORD</code> (o un token) nelle impostazioni del tuo repository GitHub (<code>Settings -> Secrets and variables -> Actions</code>).</p>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/docker-ci.yml
name: Docker CI/CD

on:
  push:
    branches: [ main ] # Esegui solo per il branch main

jobs:
  docker:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Log in to Docker Hub
        run: echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin

      - name: Build Docker image
        # Sostituisci myapp con il nome della tua applicazione
        run: docker build -t ${{ secrets.DOCKER_USERNAME }}/myapp:latest .

      - name: Push Docker image
        run: docker push ${{ secrets.DOCKER_USERNAME }}/myapp:latest
</code></pre>
<h3>üöö Distribuzione su piattaforme popolari</h3>
<p>Ora che abbiamo artefatti costruiti e testati (ad esempio, un'immagine Docker), vediamo come possono essere distribuiti.</p>
<h4>üü£ Distribuzione su Heroku</h4>
<p><strong>üîê Segreti GitHub:</strong> <code>HEROKU_API_KEY</code>, <code>HEROKU_APP_NAME</code>.</p>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/deploy-heroku.yml
name: Deploy to Heroku

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Install Heroku CLI
        run: curl https://cli-assets.heroku.com/install.sh | sh
      - name: Login to Heroku
        env:
          HEROKU_API_KEY: ${{ secrets.HEROKU_API_KEY }}
        run: heroku auth:token
      - name: Deploy to Heroku
        env:
          HEROKU_API_KEY: ${{ secrets.HEROKU_API_KEY }}
        run: |
          heroku git:remote -a ${{ secrets.HEROKU_APP_NAME }}
          git push heroku main -f # Fai attenzione con -f (force push)
</code></pre>
<p>Se stai distribuendo un'immagine Docker su Heroku:</p>
<pre class="line-numbers"><code class="language-yaml"># ... (passaggi di build e login a Docker Hub/GHCR dagli esempi precedenti) ...
# deploy:
#   name: Deploy to Heroku
#   needs: build # Dipende dal job di build dell'immagine
#   runs-on: ubuntu-latest
#   steps:
#     # ...
#     - name: Login to Heroku container registry
#       run: echo "${{ secrets.HEROKU_API_KEY }}" | docker login --username=_ --password-stdin registry.heroku.com
#     - name: Tag image for Heroku
#       # Supponendo che l'immagine sia costruita come ghcr.io/username/repo/myapp:latest
#       run: docker tag ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}/myapp:latest registry.heroku.com/${{ secrets.HEROKU_APP_NAME }}/web
#     - name: Push image to Heroku
#       run: docker push registry.heroku.com/${{ secrets.HEROKU_APP_NAME }}/web
#     - name: Release Heroku App
#       env:
#         HEROKU_API_KEY: ${{ secrets.HEROKU_API_KEY }}
#       run: heroku container:release web --app ${{ secrets.HEROKU_APP_NAME }}
</code></pre>
<h3>üü® Distribuzione su AWS (ad esempio, file statici su S3)</h3>
<p><strong>üîê Segreti GitHub:</strong> <code>AWS_ACCESS_KEY_ID</code>, <code>AWS_SECRET_ACCESS_KEY</code>, <code>AWS_REGION</code>, <code>S3_BUCKET_NAME</code>.</p>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/deploy-aws-s3.yml
name: Deploy Static Site to AWS S3

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
      - name: Sync files to S3
        # Sostituisci ./public con il percorso dei tuoi file statici
        run: aws s3 sync ./public s3://${{ secrets.S3_BUCKET_NAME }} --delete
</code></pre>
<p>Per la distribuzione su **AWS Elastic Beanstalk** viene solitamente utilizzata la CLI EB, la pipeline sar√† simile, ma con i comandi `eb deploy`.</p>
<h3>üîµ Distribuzione su Google Cloud Platform (GCP App Engine)</h3>
<p><strong>üîê Segreti GitHub:</strong> `GCP_CREDENTIALS` (chiave JSON dell'account di servizio), `GCP_PROJECT_ID`.

```yaml
# .github/workflows/deploy-gcp-app-engine.yml
name: Deploy to GCP App Engine

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ secrets.GCP_PROJECT_ID }}
          service_account_key: ${{ secrets.GCP_CREDENTIALS }}
          export_default_credentials: true
      - name: Deploy to App Engine
        # Assicurati di avere app.yaml nella root del progetto
        run: gcloud app deploy --quiet
```

#### üü™ Distribuzione su Render.com

Render spesso distribuisce automaticamente al push su GitHub, se il repository √® connesso. Ma per un trigger manuale (o come parte di una pipeline pi√π complessa) √® possibile utilizzare un Deploy Hook.
**üîê Segreti GitHub:** `RENDER_DEPLOY_HOOK` (URL ottenuto dalle impostazioni del servizio Render).

```yaml
# .github/workflows/deploy-render.yml
name: Trigger Render Deploy

on:
  workflow_dispatch: # Avvio manuale dall'interfaccia utente di GitHub

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Trigger Render Deploy Hook
        run: curl -X POST ${{ secrets.RENDER_DEPLOY_HOOK }}
```

<h3>üåü CI/CD avanzato: Build Docker ‚Üí Push su GHCR ‚Üí Staging/Production su GCP Cloud Run</h3>
<p>E ora la ciliegina sulla torta! Costruiamo una pipeline avanzata:
1.  Build dell'immagine Docker.
2.  Pubblicazione dell'immagine nel GitHub Container Registry (ghcr.io).
3.  Distribuzione automatica nell'ambiente di **staging** su GCP Cloud Run.
4.  Distribuzione nell'ambiente di **produzione** su GCP Cloud Run **dopo conferma manuale**.
</p>
<p>Per questo, avremo bisogno di diversi file di workflow.</p>
<p><strong>Segreti GitHub richiesti:</strong></p>
<ul>
<li>`GCP_PROJECT_ID`: ID del tuo progetto GCP.</li>
<li>`GCP_CREDENTIALS`: Chiave JSON dell'account di servizio GCP con autorizzazioni per la distribuzione su Cloud Run e l'accesso a GHCR (se necessario). Di solito `GITHUB_TOKEN` √® sufficiente per l'accesso a GHCR da Actions.</li>
<li>`GCP_REGION`: Regione per Cloud Run (ad esempio, `europe-west1`).</li>
</ul>
<h3>1. Build e pubblicazione dell'immagine Docker su GHCR</h3>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/build.yml
name: Build & Push to GHCR

on:
  push:
    branches: [main] # Esegui al push su main

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read      # Per checkout
      packages: write     # Per push su GHCR

    steps:
      - uses: actions/checkout@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}/myapp:latest
          # Puoi aggiungere un tag per SHA del commit per l'unicit√†:
          # tags: |
          #   ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}/myapp:latest
          #   ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}/myapp:${{ github.sha }}
</code></pre>
<ul>
<li>`github.repository_owner`: Proprietario del repository (il tuo username o organizzazione).</li>
<li>`github.event.repository.name`: Nome del repository.</li>
<li>`myapp`: Nome della tua applicazione/immagine.</li>
</ul>
<h3>2. Distribuzione automatica su Staging (GCP Cloud Run)</h3>
<p>Questo workflow verr√† eseguito automaticamente dopo il completamento con successo di `build.yml`.</p>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/deploy-staging.yml
name: Deploy to GCP Cloud Run (Staging)

on:
  workflow_run:
    workflows: ["Build & Push to GHCR"]
    types:
      - completed

jobs:
  deploy-staging:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' }}

    environment:
      name: staging
      url: ${{ steps.deploy.outputs.url }}

    steps:
      - uses: actions/checkout@v3

      - id: 'auth'
        uses: 'google-github-actions/auth@v2'
        with:
          credentials_json: '${{ secrets.GCP_CREDENTIALS }}'

      - name: 'Deploy to Cloud Run (Staging)'
        id: deploy
        uses: 'google-github-actions/deploy-cloudrun@v2'
        with:
          service: 'myapp-staging'
          region: '${{ secrets.GCP_REGION }}'
          image: 'ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}/myapp:latest'
          project_id: '${{ secrets.GCP_PROJECT_ID }}'
          flags: '--allow-unauthenticated --platform=managed'
</code></pre>
<h3>3. Distribuzione in produzione con conferma manuale (GCP Cloud Run)</h3>
<p>Questo workflow viene attivato manualmente tramite l'interfaccia utente di GitHub Actions.</p>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/deploy-prod.yml
name: Deploy to GCP Cloud Run (Production)

on:
  workflow_dispatch: # Consente l'avvio manuale

jobs:
  deploy-production:
    runs-on: ubuntu-latest

    environment:
      name: production
      url: ${{ steps.deploy.outputs.url }}

    steps:
      - uses: actions/checkout@v3

      - id: 'auth'
        uses: 'google-github-actions/auth@v2'
        with:
          credentials_json: '${{ secrets.GCP_CREDENTIALS }}'

      - name: 'Deploy to Cloud Run (Production)'
        id: deploy
        uses: 'google-github-actions/deploy-cloudrun@v2'
        with:
          service: 'myapp-production'
          region: '${{ secrets.GCP_REGION }}'
          image: 'ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}/myapp:latest'
          project_id: '${{ secrets.GCP_PROJECT_ID }}'
          flags: '--allow-unauthenticated --platform=managed'
          # Per la produzione puoi aggiungere --no-traffic e poi spostare gradualmente il traffico
          # traffic:
          #   latest: true
          #   percent: 100
</code></pre>
<h3>Punti importanti di questa pipeline avanzata:</h3>
<ul>
<li><strong>GitHub Container Registry (ghcr.io):</strong> Lo usiamo per archiviare le immagini Docker. √à comodo perch√© √® strettamente integrato con GitHub Actions.</li>
<li><strong><code>workflow_run</code>:</strong> Consente di eseguire un workflow (distribuzione di staging) al completamento di un altro (build).</li>
<li><strong><code>workflow_dispatch</code>:</strong> Offre la possibilit√† di attivare manualmente un workflow (distribuzione di produzione), garantendo il controllo.</li>
<li><strong>GitHub Environments:</strong> Ti consentono di configurare regole di protezione per la produzione (ad esempio, richiedere l'approvazione di revisori specifici) e di archiviare segreti specifici dell'ambiente.</li>
<li><strong>GCP Cloud Run:</strong> Un'ottima opzione serverless per eseguire applicazioni containerizzate.</li>
</ul>
<h3>üîê Sicurezza ‚Äì √® importante!</h3>
<ul>
<li><strong>Usa i segreti GitHub:</strong> Non archiviare mai token, password, chiavi API direttamente nei file YAML. Usa `Settings -> Secrets and variables -> Actions` nel tuo repository.</li>
<li><strong>Privilegi minimi:</strong> Per gli account di servizio (ad esempio, GCP), concedi solo le autorizzazioni strettamente necessarie per l'esecuzione delle attivit√† CI/CD.</li>
<li><strong>Isola gli ambienti:</strong> Staging e produzione dovrebbero essere il pi√π isolati possibile. Progetti/account diversi nei provider cloud sono una buona pratica.</li>
<li><strong>Protezione dei branch:</strong> Configura la protezione per il branch `main` (o `master`) in modo che i push siano possibili solo tramite Pull Request con controlli CI obbligatori.</li>
</ul>