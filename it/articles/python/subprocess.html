<h2>Lavorare con la libreria <code>subprocess</code> in Python</h2>
<h3>1. <strong>Cos&#39;&egrave; <code>subprocess</code> e a cosa serve?</strong></h3>
<p>Il modulo <code>subprocess</code> in Python fornisce un&#39;interfaccia per creare nuovi processi, 
connettersi ai loro flussi di input/output/errore e ottenere i loro codici di ritorno. 
Permette agli script Python di avviare e gestire altri programmi, 
scritti in qualsiasi linguaggio, che siano utility di sistema, script di shell o altri eseguibili.</p>
<p><strong>Contesto storico:</strong></p>
<p>Prima dell&#39;introduzione di <code>subprocess</code>, per avviare processi esterni si utilizzavano funzioni del modulo <code>os</code>, come <code>os.system()</code>, <code>os.spawn*()</code>, e anche il modulo <code>commands</code> (in Python 2). Questi approcci presentavano una serie di svantaggi:</p>
<ul>
<li><code>os.system()</code>: Esegue un comando tramite la shell di sistema, il che &egrave; insicuro quando si lavora con input utente e meno flessibile nella gestione dei flussi.</li>
<li><code>os.spawn*()</code>: Pi&ugrave; flessibili, ma complessi da usare e dipendenti dalla piattaforma.</li>
<li>Il modulo <code>popen2</code> (e le sue varianti): Forniva accesso ai flussi, ma era complesso e presentava problemi di blocco.</li>
</ul>
<p>Il modulo <code>subprocess</code> &egrave; stato introdotto in Python 2.4 (PEP 324) come un modo unificato e pi&ugrave; sicuro per interagire con i processi figli. Incapsula le migliori funzionalit&agrave; dei moduli precedenti e fornisce un&#39;API pi&ugrave; pulita.</p>
<p><strong>Compiti principali risolti con <code>subprocess</code>:</strong></p>
<ul>
<li>Esecuzione di comandi del sistema operativo (ad esempio, <code>ls</code>, <code>dir</code>, <code>ping</code>).</li>
<li>Avvio di utility esterne per l&#39;elaborazione dei dati (ad esempio, <code>grep</code>, <code>awk</code>, <code>ffmpeg</code>, <code>ImageMagick</code>).</li>
<li>Integrazione con sistemi di controllo versione (<code>git</code>, <code>svn</code>).</li>
<li>Avvio di compilatori o interpreti di altri linguaggi.</li>
<li>Automazione dell&#39;amministrazione di sistema.</li>
<li>Organizzazione dell&#39;interazione tra diversi programmi.</li>
</ul>
<hr>
<h3>2. Funzioni e classi principali</h3>
<p>Il modulo <code>subprocess</code> offre diversi modi per avviare processi:</p>
<ul>
<li><strong><code>subprocess.run(args, ..., capture_output=False, text=False, check=False, timeout=None)</code></strong>
<ul>
<li>Questa &egrave; l&#39;API di alto livello <strong>raccomandata</strong>, introdotta in Python 3.5.</li>
<li>Esegue un comando, attende il suo completamento e restituisce un oggetto <code>CompletedProcess</code>.</li>
<li>Adatta alla maggior parte dei casi in cui &egrave; necessario semplicemente eseguire un comando e ottenere il risultato.</li>
</ul>
<pre class="line-numbers"><code class="language-python">import subprocess

# Esecuzione semplice
result = subprocess.run(["ls", "-l"], capture_output=True, text=True, check=True)
print("Stdout:", result.stdout)
# Se check=True e il comando ha restituito un valore diverso da 0, verr&agrave; sollevato CalledProcessError
</code></pre>
</li>
<li><strong><code>subprocess.Popen(args, ..., stdin=None, stdout=None, stderr=None, shell=False, cwd=None, env=None)</code></strong>
<ul>
<li>Questa &egrave; la classe principale per creare e gestire processi figli.</li>
<li>Fornisce la massima flessibilit&agrave;: esecuzione non bloccante, controllo dettagliato dei flussi di I/O, possibilit&agrave; di inviare segnali al processo.</li>
<li>La funzione <code>run()</code> al suo interno utilizza <code>Popen</code>.</li>
</ul>
<pre class="line-numbers"><code class="language-python">import subprocess

process = subprocess.Popen(["sleep", "5"])
print(f"Processo avviato con PID: {process.pid}")
# ... si pu&ograve; fare altro lavoro ...
process.wait() # Attendi il completamento
print(f"Processo completato con codice: {process.returncode}")
</code></pre>
</li>
<li><strong>Funzioni obsolete ma ancora presenti (fino a Python 3.5 erano l&#39;API principale):</strong>
<ul>
<li><code>subprocess.call(args, ...)</code>: Esegue un comando e attende il suo completamento. Restituisce il codice di ritorno. Simile a <code>os.system()</code>, ma pi&ugrave; sicuro se <code>shell=False</code>.</li>
<li><code>subprocess.check_call(args, ...)</code>: Come <code>call()</code>, ma solleva <code>CalledProcessError</code> se il codice di ritorno non &egrave; 0.</li>
<li><code>subprocess.check_output(args, ...)</code>: Esegue un comando, attende il completamento e restituisce il suo output standard (stdout) come stringa di byte. Solleva <code>CalledProcessError</code> se il codice di ritorno non &egrave; 0.</li>
</ul>
<p>Sebbene queste funzioni funzionino ancora, <code>subprocess.run()</code> fornisce un&#39;interfaccia pi&ugrave; comoda e unificata per gli stessi compiti.</p>
</li>
</ul>
<hr>
<h3>3. Argomenti chiave delle funzioni <code>run()</code> e <code>Popen()</code></h3>
<p>Questi argomenti consentono di configurare finemente l&#39;avvio e l&#39;interazione con il processo figlio:</p>
<ul>
<li><strong><code>args</code></strong>:
<ul>
<li>Primo e obbligatorio argomento.</li>
<li>Pu&ograve; essere un elenco di stringhe (consigliato) o una singola stringa (se <code>shell=True</code>).</li>
<li>Il primo elemento dell&#39;elenco &egrave; il nome dell&#39;eseguibile, gli altri sono i suoi argomenti.</li>
<li>Esempio: <code>[&quot;python&quot;, &quot;myscript.py&quot;, &quot;--arg1&quot;, &quot;value1&quot;]</code></li>
</ul>
</li>
<li><strong><code>stdin</code>, <code>stdout</code>, <code>stderr</code></strong>:
<ul>
<li>Definiscono come verranno gestiti l&#39;input standard, l&#39;output e il flusso di errore del processo figlio.</li>
<li>Valori possibili:
<ul>
<li><code>None</code> (predefinito): Ereditati dal processo padre.</li>
<li><code>subprocess.PIPE</code>: Viene creata una pipe, tramite la quale &egrave; possibile scambiare dati. <code>process.stdin</code>, <code>process.stdout</code>, <code>process.stderr</code> diventano oggetti simili a file.</li>
<li><code>subprocess.DEVNULL</code>: Reindirizza il flusso &quot;nel nulla&quot; (analogo a <code>/dev/null</code>).</li>
<li>Un descrittore di file aperto (un numero intero).</li>
<li>Un oggetto file esistente (ad esempio, un file aperto <code>open('output.txt', 'w')</code>).</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>capture_output=True</code> (per <code>run()</code>):</strong>
<ul>
<li>Un&#39;opzione comoda, equivalente all&#39;impostazione di <code>stdout=subprocess.PIPE</code> e <code>stderr=subprocess.PIPE</code>.</li>
<li>Il risultato sar&agrave; disponibile in <code>result.stdout</code> e <code>result.stderr</code>.</li>
</ul>
</li>
<li><strong><code>text=True</code> (o <code>universal_newlines=True</code> per compatibilit&agrave;):</strong>
<ul>
<li>Se <code>True</code>, i flussi <code>stdout</code> e <code>stderr</code> (e anche <code>stdin</code>, se viene passata una stringa) verranno aperti in modalit&agrave; testo utilizzando la codifica predefinita (solitamente UTF-8). La decodifica/codifica avviene automaticamente.</li>
<li>Se <code>False</code> (predefinito), i flussi vengono trattati come byte.</li>
<li>A partire da Python 3.7, <code>text</code> &egrave; l&#39;alias preferito per <code>universal_newlines</code>. &Egrave; anche possibile specificare una codifica specifica tramite <code>encoding</code> e un gestore di errori tramite <code>errors</code>.</li>
</ul>
</li>
<li><strong><code>shell=False</code> (predefinito):</strong>
<ul>
<li>Se <code>False</code> (consigliato per motivi di sicurezza e prevedibilit&agrave;), <code>args</code> deve essere un elenco. Il comando viene eseguito direttamente.</li>
<li>Se <code>True</code>, <code>args</code> viene passato come stringa alla shell di sistema (ad esempio, <code>/bin/sh</code> in Unix, <code>cmd.exe</code> in Windows) per l&#39;interpretazione. Ci&ograve; consente di utilizzare le funzionalit&agrave; della shell (variabili, sostituzioni, pipe), ma &egrave; <strong>PERICOLOSO</strong> se <code>args</code> contiene input utente non verificato (rischio di iniezione di comandi).</li>
</ul>
</li>
<li><strong><code>cwd=None</code>:</strong>
<ul>
<li>Imposta la directory di lavoro corrente per il processo figlio. Per impostazione predefinita, eredita dal processo padre.</li>
</ul>
</li>
<li><strong><code>env=None</code>:</strong>
<ul>
<li>Un dizionario che definisce le variabili d&#39;ambiente per il nuovo processo. Per impostazione predefinita, viene ereditato l&#39;ambiente del processo padre. Se specificato, sostituisce completamente l&#39;ambiente ereditato. Per aggiungere/modificare variabili mantenendo le altre, &egrave; necessario prima copiare <code>os.environ</code> e poi modificarlo.</li>
</ul>
</li>
<li><strong><code>timeout=None</code>:</strong>
<ul>
<li>Tempo massimo in secondi consentito per l&#39;esecuzione del comando. Se il processo non termina entro questo tempo, verr&agrave; sollevata un&#39;eccezione <code>subprocess.TimeoutExpired</code>. <code>Popen.communicate()</code> accetta anche <code>timeout</code>.</li>
</ul>
</li>
<li><strong><code>check=False</code> (per <code>run()</code>):</strong>
<ul>
<li>Se <code>True</code> e il processo termina con un codice di ritorno diverso da zero, verr&agrave; sollevata un&#39;eccezione <code>subprocess.CalledProcessError</code>.</li>
</ul>
</li>
</ul>
<hr>
<h3>4. Gestione dei risultati e degli errori</h3>
<p><strong>Oggetto <code>CompletedProcess</code> (risultato di <code>run()</code>):</strong></p>
<pre class="line-numbers"><code class="language-python">import subprocess

try:
    # Tentiamo di eseguire un comando che potrebbe fallire
    result = subprocess.run(
        ["git", "stotus"], # 'stotus' - errore di battitura per dimostrare l&#39;errore
        capture_output=True,
        text=True,
        check=True, # Sollever&agrave; un&#39;eccezione se returncode != 0
        timeout=10
    )
    print("Comando eseguito con successo.")
    print("Codice di ritorno:", result.returncode)
    print("Stdout:", result.stdout)
    print("Stderr:", result.stderr) # Solitamente vuoto in caso di successo

except subprocess.CalledProcessError as e:
    print(f"Errore di esecuzione del comando (CalledProcessError):")
    print(f"  Comando: {e.cmd}")
    print(f"  Codice di ritorno: {e.returncode}")
    print(f"  Stdout: {e.stdout}") # Pu&ograve; contenere output prima dell&#39;errore
    print(f"  Stderr: {e.stderr}") # Solitamente qui le informazioni sull&#39;errore
except subprocess.TimeoutExpired as e:
    print(f"Il comando non &egrave; terminato entro {e.timeout} secondi.")
    print(f"  Comando: {e.cmd}")
    if e.stdout: print(f"  Stdout (parziale): {e.stdout.decode(errors='ignore')}") # stdout &egrave; in byte
    if e.stderr: print(f"  Stderr (parziale): {e.stderr.decode(errors='ignore')}") # stderr &egrave; in byte
except FileNotFoundError:
    print("Errore: comando o programma non trovato.")
except Exception as e:
    print(f"Si &egrave; verificato un altro errore: {e}")
</code></pre>
<p><strong>Attributi <code>CompletedProcess</code>:</strong></p>
<ul>
<li><code>args</code>: Argomenti utilizzati per avviare il processo.</li>
<li><code>returncode</code>: Codice di ritorno del processo. 0 di solito significa successo.</li>
<li><code>stdout</code>: Output standard del processo (byte o stringa, se <code>text=True</code> e <code>capture_output=True</code>).</li>
<li><code>stderr</code>: Flusso di errore standard del processo (byte o stringa, se <code>text=True</code> e <code>capture_output=True</code>).</li>
</ul>
<p><strong>Eccezioni:</strong></p>
<ul>
<li><code>subprocess.CalledProcessError</code>: Sollevata se <code>check=True</code> (per <code>run()</code>) o se vengono usati <code>check_call()</code>, <code>check_output()</code> e il comando termina con un codice diverso da zero. Contiene <code>returncode</code>, <code>cmd</code>, <code>output</code> (o <code>stdout</code>), <code>stderr</code>.</li>
<li><code>subprocess.TimeoutExpired</code>: Se il timeout &egrave; scaduto. Contiene <code>cmd</code>, <code>timeout</code>, <code>stdout</code>, <code>stderr</code> (output parziale, se presente).</li>
<li><code>FileNotFoundError</code>: Se l&#39;eseguibile non viene trovato.</li>
</ul>
<p><strong>Interazione con l&#39;oggetto <code>Popen</code>:</strong></p>
<p>La classe <code>Popen</code> offre maggiore controllo:</p>
<pre class="line-numbers"><code class="language-python">import subprocess
import time

# Avvia un processo in background
process = subprocess.Popen(["sleep", "5"])
print(f"Processo PID: {process.pid} avviato.")

# Controllo dello stato non bloccante
while process.poll() is None: # poll() restituisce None se il processo &egrave; ancora in esecuzione
    print("Processo ancora in esecuzione...")
    # &Egrave; possibile leggere l&#39;output man mano che arriva (attenzione, potrebbe bloccare!)
    # line = process.stdout.readline()
    # if line: print(f"Output: {line.strip()}")
    time.sleep(1)

# Attesa del completamento e ottenimento di tutto l&#39;output/errori
# stdout_data, stderr_data = process.communicate(timeout=10) # Metodo sicuro

# Se communicate() non &egrave; stato usato, dopo poll() != None &egrave; possibile leggere il resto
if process.stdout:
    for line in process.stdout:
        print(f"Output finale: {line.strip()}")

print(f"Processo completato con codice: {process.returncode}")

# Se necessario, terminare forzatamente
# process.terminate() # Invia SIGTERM
# time.sleep(0.5)
# if process.poll() is None: # Se non &egrave; terminato
#     process.kill()      # Invia SIGKILL
</code></pre>
<ul>
<li><code>process.poll()</code>: Controlla se il processo figlio &egrave; terminato. Restituisce il codice di ritorno o <code>None</code>. Non bloccante.</li>
<li><code>process.wait(timeout=None)</code>: Attende il completamento del processo figlio. Restituisce il codice di ritorno. Bloccante.</li>
<li><code>process.communicate(input=None, timeout=None)</code>:
<ul>
<li>Il modo pi&ugrave; sicuro per interagire con un processo, quando si usano <code>PIPE</code>.</li>
<li>Invia dati a <code>stdin</code> (se <code>input</code> &egrave; specificato), legge tutti i dati da <code>stdout</code> e <code>stderr</code> fino alla fine e attende il completamento del processo.</li>
<li>Restituisce una tupla <code>(stdout_data, stderr_data)</code>.</li>
<li>Aiuta a evitare deadlock che possono verificarsi con la lettura/scrittura diretta in <code>process.stdout</code>/<code>process.stdin</code>, se i buffer si riempiono.</li>
</ul>
</li>
<li><code>process.terminate()</code>: Invia un segnale <code>SIGTERM</code> al processo (terminazione &quot;soft&quot;).</li>
<li><code>process.kill()</code>: Invia un segnale <code>SIGKILL</code> al processo (terminazione &quot;hard&quot;).</li>
<li><code>process.send_signal(signal)</code>: Invia il segnale specificato al processo.</li>
<li><code>process.stdin</code>, <code>process.stdout</code>, <code>process.stderr</code>: Oggetti simili a file per le pipe, se create con <code>PIPE</code>.</li>
</ul>
<hr>
<h3>5. Scenari di utilizzo avanzati</h3>
<p><strong>Reindirizzamento dell&#39;output di un comando all&#39;input di un altro (pipe/pipeline):</strong></p>
<p>Emuliamo <code>ps aux | grep python</code>:</p>
<pre class="line-numbers"><code class="language-python">import subprocess

# Avvia il primo comando, il suo stdout sar&agrave; PIPE
ps_process = subprocess.Popen(["ps", "aux"], stdout=subprocess.PIPE)

# Avvia il secondo comando, il suo stdin sar&agrave; l&#39;stdout del primo comando
# Anche l&#39;stdout del secondo comando &egrave; PIPE per leggere il risultato
grep_process = subprocess.Popen(
    ["grep", "python"],
    stdin=ps_process.stdout, # Collega stdout di ps a stdin di grep
    stdout=subprocess.PIPE,
    text=True
)

# Importante! Chiudere l&#39;stdout del primo comando nel processo padre,
# in modo che grep riceva EOF quando ps termina.
if ps_process.stdout:
    ps_process.stdout.close()

# Ottieni l&#39;output da grep
stdout_data, stderr_data = grep_process.communicate()

print("Risultato della pipeline:")
print(stdout_data)

if stderr_data:
    print("Errori grep:", stderr_data)

# Assicurati che entrambi i processi siano terminati
ps_process.wait() # grep_process.wait() # communicate() ha gi&agrave; atteso
print(f"ps return code: {ps_process.returncode}")
print(f"grep return code: {grep_process.returncode}")
</code></pre>
<p><em>Nota:</em> Per pipeline semplici, <code>subprocess.run(&quot;ps aux | grep python&quot;, shell=True, ...)</code> pu&ograve; essere pi&ugrave; semplice, ma meno sicuro e flessibile.</p>
<p><strong>Esecuzione asincrona di processi:</strong></p>
<p><code>Popen</code> &egrave; intrinsecamente non bloccante. Puoi avviare pi&ugrave; processi e gestirli in parallelo.</p>
<pre class="line-numbers"><code class="language-python">import subprocess
import time

commands = [
    ["ping", "-c", "5", "google.com"],
    ["sleep", "2"],
    ["ls", "-l", "/nonexistentpath"] # Comando con errore
]

processes = []
for cmd_args in commands:
    print(f"Avvio: {" ".join(cmd_args)}")
    # Per l&#39;asincronia, stdout/stderr &egrave; meglio reindirizzarlo,
    # per non interferire tra loro o con la console del padre.
    # DEVNULL se l&#39;output non &egrave; necessario, PIPE se necessario in seguito.
    proc = subprocess.Popen(cmd_args, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    processes.append(proc)

# Fai altro lavoro o attendi il completamento
while any(p.poll() is None for p in processes):
    print("In attesa del completamento di tutti i processi...")
    time.sleep(0.5)

print("\nRisultati:")
for i, p in enumerate(processes):
    print(f"Comando '{' '.join(commands[i])}' completato con codice: {p.returncode}")
</code></pre>
<p><strong>Interazione interattiva con un processo:</strong></p>
<p>Questo &egrave; un compito complesso che richiede un&#39;attenta gestione dei flussi per evitare blocchi. <code>communicate()</code> &egrave; ottimo per uno scambio una tantum. Per una sessione interattiva a lungo termine potrebbe essere necessaria la lettura/scrittura diretta in <code>p.stdin</code>, <code>p.stdout</code>, <code>p.stderr</code> utilizzando I/O non bloccante o thread separati.</p>
<pre class="line-numbers"><code class="language-python">import subprocess

# Esempio: avvio di una sessione python interattiva
process = subprocess.Popen(
    ['python', '-i'], # -i per la modalit&agrave; interattiva
    stdin=subprocess.PIPE,
    stdout=subprocess.PIPE,
    stderr=subprocess.PIPE,
    text=True,
    bufsize=1 # Buffering di linea per stdout/stderr (per interattivit&agrave;)
)

def send_command(cmd_str):
    print(f">>>>> {cmd_str}")
    process.stdin.write(cmd_str + '\n')
    process.stdin.flush() # Importante!

def read_output():
    # La lettura dell&#39;output pu&ograve; essere complessa, poich&eacute; &egrave; necessario sapere quando fermarsi.
    # Questo &egrave; un esempio molto semplificato. Per compiti reali sono necessarie soluzioni pi&ugrave; robuste.
    # Ad esempio, leggere fino a un certo pattern (prompt della riga di comando).
    output = ""
    # Leggi stdout. In un&#39;applicazione reale, questo dovrebbe essere fatto in modo non bloccante o in un thread separato.
    # Qui si presume che dopo il comando ci sar&agrave; immediatamente un output.
    # Questa &egrave; un&#39;ipotesi molto fragile per il caso generale!
    while True: # Attenzione, potrebbe bloccarsi!
        line = process.stdout.readline()
        if not line: break # EOF
        if ">>>>> " in line or "... " in line: # Rilevatore di prompt primitivo
            output += line
            break
        output += line
    return output.strip()

# Inizializzazione: leggere il prompt iniziale
initial_output = ""
# Lettura del benvenuto di Python
# Questo &egrave; molto semplificato, poich&eacute; non sappiamo esattamente quante righe leggere
for _ in range(5): # Tentiamo di leggere alcune righe
    try:
        # Popen stdout non ha timeout, &egrave; necessario leggere con cautela
        # stdout.readline() potrebbe bloccarsi.
        # Nelle applicazioni reali, qui &egrave; necessario select o thread.
        line = process.stdout.readline()
        if not line: break
        initial_output += line
        if ">>>>>" in line: break # Trovato il prompt
    except BlockingIOError:
        break # Se ci fosse stata una lettura non bloccante
print(f"Initial output:\n{initial_output.strip()}")


send_command("a = 10")
# Per l&#39;interazione interattiva, la lettura dell&#39;output &egrave; la parte pi&ugrave; difficile.
# communicate() non &egrave; adatto, poich&eacute; chiude i flussi.
# &Egrave; necessario leggere attentamente da process.stdout e process.stderr, 
# possibilmente in thread separati, per non bloccare il principale.
# Questo esempio NON &egrave; pronto per la produzione per interazioni complesse.
# print(read_output()) # Questo read_output &egrave; molto primitivo

send_command("print(a * 2)")
# print(read_output())

# Termina il processo
process.stdin.write("exit()\n")
process.stdin.flush()
stdout_data, stderr_data = process.communicate(timeout=5) # Attendi il completamento e raccogli il resto

print("\nFinal stdout:")
print(stdout_data)
if stderr_data:
    print("\nFinal stderr:")
    print(stderr_data)

print(f"Python process finished with code: {process.returncode}")

# Per una vera interazione interattiva, spesso si usano pty (pseudo-terminali)
# tramite il modulo `pty` nei sistemi Unix-like, o librerie come `pexpect`.
</code></pre>
<p><em>Avvertenza</em>: L&#39;interazione interattiva diretta con <code>Popen</code> tramite <code>stdin</code>/<code>stdout</code>/<code>stderr</code> &egrave; complessa a causa di blocchi e buffering. Per un&#39;interazione affidabile, spesso si usano librerie come <code>pexpect</code> (per Unix) o analoghe, che lavorano con pseudo-terminali (pty).</p>
<p><strong>Lavorare con le codifiche:</strong></p>
<ul>
<li>Usa <code>text=True</code> (o <code>universal_newlines=True</code>) per la decodifica/codifica automatica.</li>
<li>Se necessario, puoi specificare <code>encoding=&quot;la_tua_codifica&quot;</code> e <code>errors=&quot;gestore_errori&quot;</code> (ad esempio, <code>replace</code>, <code>ignore</code>).</li>
<li>Se <code>text=False</code> (predefinito), <code>stdout</code> e <code>stderr</code> saranno stringhe di byte. Dovrai decodificarle manualmente: <code>result.stdout.decode('utf-8', errors='replace')</code>.</li>
</ul>
<hr>
<h3>6. Sicurezza e migliori pratiche</h3>
<ul>
<li><strong>Rischi di <code>shell=True</code> e iniezione di comandi:</strong>
<ul>
<li><strong>Non usare mai</strong> <code>shell=True</code> con comandi costruiti da input utente non verificato. Questo apre la strada all&#39;iniezione di comandi.</li>
<li>Esempio di vulnerabilit&agrave;:
<pre class="line-numbers"><code class="language-python"># PERICOLOSO!
filename = input("Inserisci il nome del file da eliminare: ") # L&#39;utente inserisce "myinnocentfile.txt; rm -rf /"
subprocess.run(f"rm {filename}", shell=True, check=True)
</code></pre>
</li>
<li>Se <code>shell=True</code> &egrave; assolutamente necessario (ad esempio, per usare pipe <code>|</code> o sostituzioni <code>*</code> direttamente nella stringa del comando), esegui attentamente l&#39;escape di tutte le parti del comando formate esternamente usando <code>shlex.quote()</code> (a partire da Python 3.3).</li>
</ul>
</li>
<li><strong>Validazione ed escape dell&#39;input utente:</strong>
<ul>
<li>Anche se <code>shell=False</code>, se gli argomenti del comando sono formati da input utente, devono essere validati. Ad esempio, se si prevede un nome di file, assicurati che sia effettivamente un nome di file valido e non qualcosa come <code>../../../etc/passwd</code>.</li>
</ul>
</li>
<li><strong>Passaggio degli argomenti come elenco (quando <code>shell=False</code>):</strong>
<ul>
<li>Questo &egrave; il metodo pi&ugrave; sicuro. Ogni argomento viene passato come elemento separato dell&#39;elenco e il sistema operativo li gestisce correttamente, senza tentare di interpretarli come parte di un comando della shell.</li>
<li>Esempio: <code>subprocess.run([&quot;rm&quot;, filename_from_user])</code> &mdash; qui <code>filename_from_user</code> sar&agrave; sempre trattato come un singolo argomento (nome del file), anche se contiene spazi o caratteri speciali.</li>
</ul>
</li>
<li><strong>Gestione degli errori e dei codici di ritorno:</strong>
<ul>
<li>Controlla sempre <code>returncode</code> o usa <code>check=True</code> (per <code>run()</code>) / <code>check_call()</code> / <code>check_output()</code> per assicurarti che il comando sia stato eseguito con successo.</li>
<li>Gestisci le possibili eccezioni (<code>CalledProcessError</code>, <code>TimeoutExpired</code>, <code>FileNotFoundError</code>).</li>
</ul>
</li>
<li><strong>Gestione delle risorse:</strong>
<ul>
<li>Se apri pipe (<code>PIPE</code>), assicurati che vengano chiuse alla fine. <code>Popen.communicate()</code> lo fa automaticamente. Se lavori direttamente con <code>p.stdin</code>/<code>stdout</code>/<code>stderr</code>, potrebbe essere necessaria la loro chiusura esplicita.</li>
<li>Nelle applicazioni a lunga esecuzione, assicurati che i processi figli terminino correttamente e non diventino &quot;zombie&quot;. Usa <code>p.wait()</code> o <code>p.communicate()</code>. Se necessario, usa <code>p.terminate()</code> o <code>p.kill()</code>.</li>
</ul>
</li>
<li><strong>Codifiche:</strong> Fai attenzione alle codifiche quando usi <code>text=True</code> o quando decodifichi manualmente stringhe di byte. I problemi di codifica &ndash; una fonte comune di errori.</li>
</ul>
<hr>
<h3>7. Esempi pratici</h3>
<p><strong>1. Esecuzione di un comando semplice e controllo del codice di ritorno:</strong></p>
<pre class="line-numbers"><code class="language-python">import subprocess

try:
    # Esegui 'ls' per una directory esistente
    result = subprocess.run(["ls", "-l", "/tmp"], check=True)
    print(f"Comando 'ls /tmp' eseguito, codice di ritorno: {result.returncode}")

    # Esegui 'ls' per una directory inesistente
    result_fail = subprocess.run(["ls", "/nonexistent"], check=True, stderr=subprocess.PIPE, text=True)
    # Questa riga non verr&agrave; eseguita se check=True, poich&eacute; verr&agrave; sollevata un&#39;eccezione
except subprocess.CalledProcessError as e:
    print(f"Errore di esecuzione del comando: {e.cmd}")
    print(f"Codice di ritorno: {e.returncode}")
    if e.stderr:
        print(f"Stderr: {e.stderr.strip()}")
</code></pre>
<p><strong>2. Acquisizione dell&#39;output del comando:</strong></p>
<pre class="line-numbers"><code class="language-python">import subprocess

try:
    result = subprocess.run(
        ["git", "status", "--short"],
        capture_output=True,
        text=True,
        check=True,
        cwd="."  # Specifica la directory corrente come directory di lavoro per git
    )
    print("Stato Git:")
    print(result.stdout)
except FileNotFoundError:
    print("Errore: comando 'git' non trovato. Git &egrave; installato e nel PATH?")
except subprocess.CalledProcessError as e:
    print(f"Errore git: {e.stderr}")
</code></pre>
<p><strong>3. Invio di dati all&#39;input di un processo (usando <code>communicate</code>):</strong></p>
<pre class="line-numbers"><code class="language-python">import subprocess

# Invia testo a 'grep' per la ricerca
input_text = "hello world\npython is fun\nhello python"
try:
    process = subprocess.Popen(
        ["grep", "python"],
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True
    )
    stdout_data, stderr_data = process.communicate(input=input_text, timeout=5)

    if process.returncode == 0: # grep ha trovato corrispondenze
        print("Righe trovate:")
        print(stdout_data)
    elif process.returncode == 1: # grep non ha trovato corrispondenze
        print("Corrispondenze 'python' non trovate.")
    else: # altro errore grep
        print(f"Errore grep (codice {process.returncode}):")
        if stderr_data: print(stderr_data)

except subprocess.TimeoutExpired:
    print("Grep non ha risposto in tempo.")
    process.kill() # Uccidi il processo se &egrave; bloccato
    process.communicate() # Raccogli l&#39;output/errori rimanenti
</code></pre>
<p><strong>4. Creazione di una pipeline (<code>ls -l | wc -l</code>) senza <code>shell=True</code>:</strong>
(Un esempio pi&ugrave; dettagliato era nella sezione 5)</p>
<pre class="line-numbers"><code class="language-python">import subprocess

ls_proc = subprocess.Popen(["ls", "-l"], stdout=subprocess.PIPE)
wc_proc = subprocess.Popen(["wc", "-l"], stdin=ls_proc.stdout, stdout=subprocess.PIPE, text=True)

if ls_proc.stdout: # Assicurati che stdout esista
    ls_proc.stdout.close()  # Permette a wc_proc di ricevere EOF quando ls_proc termina

output, _ = wc_proc.communicate()
print(f"Numero di file/directory: {output.strip()}")
</code></pre>
<p><strong>5. Utilizzo di <code>timeout</code>:</strong></p>
<pre class="line-numbers"><code class="language-python">import subprocess

try:
    # Comando che verr&agrave; eseguito per 5 secondi
    result = subprocess.run(["sleep", "5"], timeout=2)
    print("Comando 'sleep 5' completato (non avrebbe dovuto con timeout=2).")
except subprocess.TimeoutExpired as e:
    print(f"Comando '{e.cmd}' non completato entro {e.timeout} secondi.")
</code></pre>
<hr>
<h3>8. Conclusione e risorse utili</h3>
<p>Il modulo <code>subprocess</code> &egrave; uno strumento indispensabile per qualsiasi sviluppatore Python che necessiti di interagire con programmi esterni o con l&#39;ambiente di sistema. Offre un equilibrio tra semplicit&agrave; d&#39;uso (tramite <code>subprocess.run()</code>) e potente flessibilit&agrave; (tramite <code>subprocess.Popen()</code>).</p>
<p><strong>Punti chiave:</strong></p>
<ul>
<li>Preferisci <code>subprocess.run()</code> per la maggior parte dei compiti.</li>
<li>Usa <code>subprocess.Popen()</code> per l&#39;esecuzione asincrona o la gestione complessa dei flussi.</li>
<li><strong>Evita <code>shell=True</code></strong>, soprattutto con input utente, a causa dei rischi per la sicurezza. Passa i comandi come elenco di argomenti.</li>
<li>Gestisci sempre i codici di ritorno e le possibili eccezioni.</li>
<li>Fai attenzione alle codifiche quando lavori con l&#39;output di testo (<code>text=True</code> o decodifica manuale).</li>
<li><code>communicate()</code> &mdash; il tuo amico per lo scambio sicuro di dati tramite <code>PIPE</code>.</li>
</ul>
<p><strong>Risorse utili:</strong></p>
<ul>
<li>Documentazione ufficiale Python per il modulo <code>subprocess</code>: <a href="https://docs.python.org/3/library/subprocess.html">https://docs.python.org/3/library/subprocess.html</a></li>
<li>PEP 324 &ndash; <code>subprocess</code> - A New Process Module: <a href="https://peps.python.org/pep-0324/">https://peps.python.org/pep-0324/</a></li>
</ul>
