<h2>üßë‚Äçüíª Utilizzo di <code>array.array</code> in Python: quando e perch√© usarlo</h2>
<p>Il modulo <strong><code>array</strong></code> fornisce un tipo di dato specializzato <code>array.array</code> per memorizzare sequenze di numeri dello stesso tipo. A differenza del <code>list</code> universale, gli array <code>array.array</code> offrono un uso pi√π efficiente della memoria e prestazioni migliorate quando si lavora con dati numerici.</p>
<hr>
<h2>üì¶ Vantaggi principali di <code>array.array</strong></h2>
<p>La differenza fondamentale tra <code>array.array</code> e <code>list</code> √® la <strong>memorizzazione compatta dei dati</strong>. Invece di un elenco di puntatori a oggetti Python, <code>array.array</code> memorizza i valori come un blocco continuo di byte, rendendolo ideale per i seguenti compiti.</p>
<hr>
<h3>1. Risparmio di memoria quando si lavora con grandi set di numeri</h3>
<p>Quando si elaborano milioni di elementi numerici, il risparmio di memoria diventa di importanza critica. <code>array.array</code> riduce significativamente l'overhead.</p>
<pre class="line-numbers"><code class="language-python">import array
import sys

def compare_memory_usage(num_elements: int = 1_000_000) -> None:
    """
    Confronta l'utilizzo della memoria tra list e array.array.

    Args:
        num_elements (int, optional): Numero di elementi per il test. 
                                      Predefinito 1,000,000.
    """
    # Creazione di una lista con oggetti interi Python
    list_numbers = list(range(num_elements))
    
    # Creazione di un array in cui i numeri sono memorizzati come int di tipo C a 4 byte
    array_numbers = array.array('i', range(num_elements))

    list_size = sys.getsizeof(list_numbers)
    array_size = sys.getsizeof(array_numbers)

    print(f"Numero di elementi: {num_elements}")
    print(f"Dimensione list:  {list_size / 1024 / 1024:.2f} MB")
    print(f"Dimensione array: {array_size / 1024 / 1024:.2f} MB")
    if array_size > 0:
        print(f"Risparmio di memoria: {list_size / array_size:.2f}x")

# Esempio di utilizzo
if __name__ == "__main__":
    compare_memory_usage()
</code></pre>
<p><strong>Output:</strong></p>
<pre class="line-numbers"><code>Numero di elementi: 1000000
Dimensione list:  7.63 MB
Dimensione array: 3.82 MB
Risparmio di memoria: 2.00x
</code></pre>
<hr>
<h3>2. Aumento delle prestazioni delle operazioni numeriche</h3>
<p>Grazie alla disposizione continua in memoria, le operazioni matematiche sugli elementi di <code>array.array</code> vengono eseguite pi√π velocemente, poich√© il processore pu√≤ utilizzare la cache in modo pi√π efficiente.</p>
<pre class="line-numbers"><code class="language-python">import array
import timeit

def compare_performance(num_elements: int = 10_000_000) -> None:
    """
    Confronta le prestazioni della somma di elementi in list e array.array.

    Args:
        num_elements (int, optional): Numero di elementi per il test. 
                                      Predefinito 10,000,000.
    """
    setup_code = f"""
import array
data = range({num_elements})
list_data = list(data)
array_data = array.array('i', data)
"""
    
    # Misurazione del tempo per list
    list_time = timeit.timeit("sum(list_data)", setup=setup_code, number=10)
    
    # Misurazione del tempo per array
    array_time = timeit.timeit("sum(array_data)", setup=setup_code, number=10)
    
    print(f"Tempo di somma di {num_elements} elementi (10 volte):")
    print(f"list:  {list_time:.4f} secondi")
    print(f"array: {array_time:.4f} secondi")

# Esempio di utilizzo
if __name__ == "__main__":
    compare_performance()
</code></pre>
<p><strong>Output:</strong></p>
<pre class="line-numbers"><code>Tempo di somma di 10000000 elementi (10 volte):
list:  2.1106 secondi
array: 1.1549 secondi
</code></pre>
<hr>
<h3>3. Lavoro diretto con librerie C (<code>ctypes</code>, <code>struct</code>)</h3>
<p><code>array.array</code> √® ideale per passare dati a librerie di basso livello scritte in C, poich√© la sua struttura interna √® compatibile con gli array C.</p>
<h4>Esempio con <code>ctypes</code>:</h4>
<pre class="line-numbers"><code class="language-python">import array
from ctypes import c_double, CDLL

def demonstrate_ctypes_usage() -> None:
    """
    Dimostra il passaggio di array.array a una funzione C tramite ctypes.
    """
    # Array con numeri a doppia precisione (tipo 'd')
    py_array = array.array('d', [1.1, 2.2, 3.3, 4.4])
    
    # Creazione di un array compatibile con C da py_array
    # La funzione (c_double * len(py_array)) crea un tipo "array di 4 c_double"
    # (*py_array) scompone l'array python negli argomenti di questo costruttore
    c_array = (c_double * len(py_array))(*py_array)

    # Qui potrebbe esserci una chiamata a una funzione C, ad esempio:
    # my_c_library = CDLL("./libmath.so")
    # my_c_library.sum_doubles(c_array, len(c_array))
    
    print(f"Array Python: {py_array}")
    print(f"Array compatibile con C (ctypes): {[val for val in c_array]}")

# Esempio di utilizzo
if __name__ == "__main__":
    demonstrate_ctypes_usage()
</code></pre>
<h4>Esempio con <code>struct</code> per l'impacchettamento dei dati:</h4>
<pre class="line-numbers"><code class="language-python">import array
import struct

def demonstrate_struct_packing(data: list[int]) -> bytes:
    """
    Impacchetta un array di interi in una stringa binaria.

    Args:
        data (list[int]): Elenco di interi da impacchettare.

    Returns:
        bytes: Rappresentazione binaria dei dati.
    """
    arr = array.array('i', data)
    
    # Creazione di una stringa di formato come '3i' per 3 interi
    format_string = f'{len(arr)}i'
    
    # Impacchettamento dei dati in formato binario
    binary_data = struct.pack(format_string, *arr)
    
    print(f"Array originale: {arr}")
    print(f"Dati binari: {binary_data}")
    
    # Verifica: spacchettamento inverso
    unpacked_data = struct.unpack(format_string, binary_data)
    print(f"Dati spacchettati: {unpacked_data}")
    
    return binary_data

# Esempio di utilizzo
if __name__ == "__main__":
    demonstrate_struct_packing([10, 20, 30])
</code></pre>
<hr>
<h3>4. Serializzazione e deserializzazione efficienti</h3>
<p>I metodi <code>.tobytes()</code> e <code>.frombytes()</code> consentono di convertire rapidamente un array in byte e viceversa, il che √® ideale per il salvataggio in file o la trasmissione in rete.</p>
<pre class="line-numbers"><code class="language-python">import array

def handle_binary_data() -> None:
    """
    Dimostra la serializzazione e deserializzazione di array.array in byte.
    """
    # Creazione dell'array sorgente
    source_array = array.array('i', [1, 2, 3, 4, 5])
    print(f"Array sorgente: {source_array}")

    # Serializzazione dell'array in byte
    binary_data = source_array.tobytes()
    print(f"Dati in byte: {binary_data}")

    # Deserializzazione da byte a un nuovo array
    new_array = array.array('i')
    new_array.frombytes(binary_data)
    print(f"Array ripristinato: {new_array}")

    # Verifica dell'integrit√†
    assert source_array == new_array, "I dati non corrispondono!"
    print("Integrit√† dei dati confermata.")

# Esempio di utilizzo
if __name__ == "__main__":
    handle_binary_data()
</code></pre>
<hr>
<h3>5. Garanzia di omogeneit√† del tipo</h3>
<p><code>array.array</code> impone la memorizzazione di un solo tipo di dato, specificato al momento della creazione. Ci√≤ protegge dall'aggiunta accidentale di elementi di un tipo diverso.</p>
<pre class="line-numbers"><code class="language-python">import array

def demonstrate_type_safety() -> None:
    """
    Mostra che array.array non consente l'aggiunta di elementi di un tipo diverso.
    """
    arr = array.array('i', [100, 200, 300])
    print(f"Array di interi: {arr}")
    
    try:
        # Tentativo di aggiungere un elemento stringa
        arr.append('hello')
    except TypeError as e:
        # Eccezione attesa
        print(f"\nTentativo di aggiungere 'hello' ha causato un errore: {e}")
        print("Questo conferma la tipizzazione rigorosa dell'array.")

# Esempio di utilizzo
if __name__ == "__main__":
    demonstrate_type_safety()
</code></pre>
<hr>
<h3>6. Scrittura e lettura diretta da file binari</h3>
<p>I metodi <code>.tofile()</code> e <code>.fromfile()</code> semplificano il lavoro con i file binari, evitando la serializzazione intermedia.</p>
<pre class="line-numbers"><code class="language-python">import array
from pathlib import Path

def work_with_binary_files(file_path_str: str = "data.bin") -> None:
    """
    Scrive un array in un file binario e lo legge di nuovo.

    Args:
        file_path_str (str, optional): Nome del file da salvare.
                                       Predefinito "data.bin".
    """
    file_path = Path(file_path_str)
    source_array = array.array('f', [1.5, 2.7, 3.14])

    try:
        # Scrittura su file
        with file_path.open('wb') as f:
            source_array.tofile(f)
        print(f"Array {source_array} scritto nel file '{file_path}'.")

        # Lettura da file
        new_array = array.array('f')
        with file_path.open('rb') as f:
            # Lettura di 3 elementi di tipo 'f' (float)
            new_array.fromfile(f, len(source_array))
        print(f"Array {new_array} letto dal file.")
        
        assert source_array == new_array
        print("Integrit√† dei dati confermata.")

    finally:
        # Eliminazione garantita del file dopo l'esecuzione
        if file_path.exists():
            file_path.unlink()
            print(f"File temporaneo '{file_path}' eliminato.")

# Esempio di utilizzo
if __name__ == "__main__":
    work_with_binary_files()
</code></pre>
<hr>
<h2>üîπ Tabella comparativa: <code>array.array</code> vs <code>list</code></h2>
<table>
<thead>
<tr>
<th>Caratteristica</th>
<th><code>array.array</code></th>
<th><code>list</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Tipo di dati</strong></td>
<td>Primitivi omogenei (numeri, caratteri)</td>
<td>Qualsiasi oggetto Python</td>
</tr>
<tr>
<td><strong>Memoria</strong></td>
<td>Basso consumo</td>
<td>Alto consumo</td>
</tr>
<tr>
<td><strong>Prestazioni</strong></td>
<td>Elevate per operazioni numeriche</td>
<td>Inferiori per operazioni numeriche</td>
</tr>
<tr>
<td><strong>API</strong></td>
<td>Set di metodi limitato</td>
<td>API ricca e flessibile</td>
</tr>
<tr>
<td><strong>Compatibilit√† con C</strong></td>
<td>Elevata, trasferimento dati diretto</td>
<td>Richiede conversioni</td>
</tr>
<tr>
<td><strong>Serializzazione binaria</strong></td>
<td>Metodi integrati (<code>.tobytes</code>, <code>.tofile</code>)</td>
<td>Richiede <code>struct</code>, <code>pickle</code>, ecc.</td>
</tr>
</tbody>
</table>
<hr>
<p><strong>Conclusione:</strong></p>
<p>üöÄ Usa <code>array.array</code> quando lavori con grandi volumi di <strong>dati numerici omogenei</strong>, e per te sono critici <strong>prestazioni</strong> ed <strong>efficienza nell'uso della memoria</strong>.</p>
<p>Per la maggior parte dei compiti quotidiani, dove √® richiesta flessibilit√† e memorizzazione di dati eterogenei, <code>list</code> rimane la scelta migliore.</p>
