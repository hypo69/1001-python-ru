### **Tempo polinomiale**

**Il tempo polinomiale** — è un termine usato nella teoria della complessità computazionale per descrivere il tempo di esecuzione di un algoritmo, che cresce come un polinomio (polinomio) dalla dimensione dei dati di input. Se il tempo di esecuzione di un algoritmo può essere espresso come \(O(n^k)\), dove \(n\) — dimensione dei dati di input, e \(k\) — costante, allora tale algoritmo funziona in tempo polinomiale.

#### **Esempi:**
1.  **Ordinamento di un elenco**: Algoritmi, come il merge sort o il quick sort, funzionano in \(O(n \log n)\), che è tempo polinomiale.
2.  **Ricerca del percorso più breve in un grafo**: L'algoritmo di Dijkstra funziona in \(O(n^2)\) o \(O(n \log n)\) a seconda dell'implementazione, che è anche polinomiale.

#### **Caratteristiche:**
-   Gli algoritmi, che funzionano in tempo polinomiale, sono considerati **efficienti** e **praticamente applicabili**.
-   I problemi, che possono essere risolti in tempo polinomiale, appartengono alla classe **P**.

---

### **Tempo esponenziale**

**Il tempo esponenziale** — è il tempo di esecuzione di un algoritmo, che cresce esponenzialmente a seconda della dimensione dei dati di input. Se il tempo di esecuzione può essere espresso come \(O(k^n)\), dove \(n\) — dimensione dei dati di input, e \(k\) — costante, allora tale algoritmo funziona in tempo esponenziale.

#### **Esempi:**
1.  **Problema del commesso viaggiatore**: La risoluzione con il metodo della forza bruta di tutti i percorsi possibili richiede \(O(n!)\) tempo, che è peggio dell'esponenziale.
2.  **Enumerazione di tutti i sottoinsiemi**: Un algoritmo, che controlla tutti i possibili sottoinsiemi di un insieme di \(n\) elementi, funziona in \(O(2^n)\).

#### **Caratteristiche:**
-   Gli algoritmi, che funzionano in tempo esponenziale, sono considerati **inefficienti** per grandi input, poiché il tempo di esecuzione diventa impraticabilmente lungo anche per \(n\) relativamente piccoli.
-   I problemi, che possono essere risolti solo in tempo esponenziale, spesso richiedono l'uso di **metodi approssimati**, **euristiche** o **calcolo parallelo**.

---

### **Confronto tra tempo polinomiale ed esponenziale**

| **Caratteristica** | **Tempo polinomiale** | **Tempo esponenziale** |
| :--- | :--- | :--- |
| **Crescita del tempo di esecuzione** | Lenta (ad esempio, \(n^2\), \(n^3\)) | Rapida (ad esempio, \(2^n\), \(3^n\)) |
| **Esempi di problemi** | Ordinamento, ricerca del percorso più breve | Problema del commesso viaggiatore, enumerazione di sottoinsiemi |
| **Applicabilità pratica** | Efficiente per grandi dati | Inapplicabile per grandi dati |
| **Classe di complessità** | P | NP-difficili, NP-completi |

---

### **Perché è importante?**

1.  **Tempo polinomiale**:
    -   Gli algoritmi, che funzionano in tempo polinomiale, sono considerati **praticamente applicabili**, poiché possono elaborare grandi volumi di dati in un tempo ragionevole.
    -   I problemi della classe **P** (risolvibili in tempo polinomiale) sono la base per molte applicazioni nell'informatica, come l'elaborazione dei dati, le reti, la crittografia e l'intelligenza artificiale.

2.  **Tempo esponenziale**:
    -   Gli algoritmi, che funzionano in tempo esponenziale, diventano **impraticabili** anche per input relativamente piccoli. Ad esempio, per \(n = 100\), \(2^n\) supera già il numero di atomi nell'universo osservabile.
    -   I problemi, che possono essere risolti solo in tempo esponenziale, spesso richiedono l'uso di **metodi approssimati**, **euristiche** o **calcolo parallelo**.

---

### **Esempio per la comprensione**

Immagina di avere un problema e di volerlo risolvere per \(n = 10\) e \(n = 100\):

-   **Tempo polinomiale (\(n^2\))**:
    -   Per \(n = 10\): \(10^2 = 100\) operazioni.
    -   Per \(n = 100\): \(100^2 = 10\,000\) operazioni.

-   **Tempo esponenziale (\(2^n\))**:
    -   Per \(n = 10\): \(2^{10} = 1\,024\) operazioni.
    -   Per \(n = 100\): \(2^{100} \approx 1.26 \times 10^{30}\) operazioni.

Come si può vedere, per \(n = 100\) un algoritmo polinomiale eseguirà 10.000 operazioni, il che è abbastanza realistico, mentre un algoritmo esponenziale richiederà \(1.26 \times 10^{30}\) operazioni, il che è praticamente impossibile.

Per costruire grafici che illustrano la differenza tra tempo polinomiale ed esponenziale, è possibile utilizzare varie funzioni matematiche. Ecco esempi di funzioni che possono essere utilizzate per la visualizzazione:

---

### **Funzioni polinomiali**
1.  **Funzione lineare**: 
    \( f(n) = n \) 
    Esempio: tempo di esecuzione di un algoritmo che elabora ogni elemento una volta.

2.  **Funzione quadratica**: 
    \( f(n) = n^2 \) 
    Esempio: tempo di esecuzione di un algoritmo con cicli annidati, ad esempio il bubble sort.

3.  **Funzione cubica**: 
    \( f(n) = n^3 \) 
    Esempio: tempo di esecuzione di un algoritmo che elabora dati tridimensionali.

4.  **Funzione logaritmica**: 
    \( f(n) = \log n \) 
    Esempio: tempo di esecuzione della ricerca binaria.

5.  **Funzione lineare-logaritmica**: 
    \( f(n) = n \log n \) 
    Esempio: tempo di esecuzione del quick sort o del merge sort.

---

### **Funzioni esponenziali**
1.  **Funzione esponenziale**: 
    \( f(n) = 2^n \) 
    Esempio: tempo di esecuzione di un algoritmo che enumera tutti i sottoinsiemi di un insieme.

2.  **Funzione fattoriale**: 
    \( f(n) = n! \) 
    Esempio: tempo di esecuzione di un algoritmo che enumera tutte le permutazioni (ad esempio, il problema del commesso viaggiatore).

3.  **Funzione esponenziale con base diversa**: 
    \( f(n) = 3^n \) 
    Esempio: tempo di esecuzione di un algoritmo che esplora tutte le possibili combinazioni.

---

### **Esempio di codice per la creazione di grafici (Python, Matplotlib)**

```python
import matplotlib.pyplot as plt
import numpy as np
import math # Import the standard math module

# Range of n values
n = np.linspace(1, 20, 100)

# Polynomial functions
linear = n
quadratic = n**2
cubic = n**3
logarithmic = np.log(n)
nlogn = n * np.log(n)

# Exponential functions
exponential = 2**n
# Use math.factorial from the imported math module
factorial = [math.factorial(int(i)) for i in n]  # Factorial is defined only for integers

# Plotting the graphs
plt.figure(figsize=(10, 6))

# Polynomial functions
plt.plot(n, linear, label='Linear: $f(n) = n$')
plt.plot(n, quadratic, label='Quadratic: $f(n) = n^2$')
plt.plot(n, cubic, label='Cubic: $f(n) = n^3$')
plt.plot(n, logarithmic, label='Logarithmic: $f(n) = \log n$')
plt.plot(n, nlogn, label='Linearithmic: $f(n) = n \log n$')

# Exponential functions
plt.plot(n, exponential, label='Exponential: $f(n) = 2^n$')
plt.plot(n, factorial, label='Factorial: $f(n) = n!$')

# Graph settings
plt.yscale('log')  # Logarithmic scale for convenience
plt.xlabel('Input size (n)')
plt.ylabel('Time complexity')
plt.title('Comparison of Polynomial and Exponential Time Complexity')
plt.legend()
plt.grid(True)
plt.show()
```

---
![Exponetialy](../assets/exponetialy.png)

### **Cosa mostrerà il grafico?**
-   **Funzioni polinomiali** crescono lentamente e rimangono nella parte inferiore del grafico.
-   **Funzioni esponenziali** crescono molto rapidamente e si spostano verso l'alto anche per piccoli valori di \(n\).
-   L'uso di una **scala logaritmica** (sull'asse Y) aiuta a visualizzare la differenza tra funzioni polinomiali ed esponenziali, poiché i loro valori differiscono di ordini di grandezza.

```