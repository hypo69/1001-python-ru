<p>ğŸš€ <strong>CI/CD: Od podstaw do produkcji na GCP z GitHub Actions â€“ Kompletny przewodnik z przykÅ‚adami</strong> ğŸš€</p>
<p>Witajcie, deweloperzy! W tym artykule opowiem o CI/CD â€“ koncepcji.</p>
<h3>Czym jest potok CI/CD w kontekÅ›cie programowania?</h3>
<p><strong>Potok CI/CD (Continuous Integration / Continuous Delivery lub Continuous Deployment)</strong> to zautomatyzowany proces, ktÃ³ry pozwala deweloperom szybko i niezawodnie dostarczaÄ‡ zmiany w kodzie do Å›rodowiska produkcyjnego.</p>
<p>RozÅ‚Ã³Å¼my kluczowe pojÄ™cia:</p>
<p>ğŸ”§ <strong>CI â€” Continuous Integration (CiÄ…gÅ‚a Integracja)</strong><br>
Jest to praktyka, w ktÃ³rej deweloperzy czÄ™sto wprowadzajÄ… zmiany do wspÃ³lnej bazy kodu. KaÅ¼da taka zmiana jest automatycznie:
*   <strong>Budowana</strong> (build)
*   <strong>Testowana</strong> (testy jednostkowe, testy integracyjne)
*   <strong>Sprawdzana pod kÄ…tem zgodnoÅ›ci ze standardami</strong> (linting, analiza statyczna)
</p>
<p>ğŸ‘‰ **Cel CI:** Wykrywanie bÅ‚Ä™dÃ³w na najwczeÅ›niejszym etapie, zanim zepsujÄ… coÅ› waÅ¼nego lub trafiÄ… do wydania.</p>
<p>ğŸš€ **CD â€” Continuous Delivery (CiÄ…gÅ‚e Dostarczanie) lub Continuous Deployment (CiÄ…gÅ‚e WdraÅ¼anie)**<br>
Tutaj sÄ… dwie opcje:
</p>
<p>âœ… **Continuous Delivery (CiÄ…gÅ‚e Dostarczanie)**<br>
Po pomyÅ›lnym przejÅ›ciu etapu CI, zmiany automatycznie:
*   PrzechodzÄ… dodatkowe testy (np. E2E â€“ testy end-to-end)
*   TrafiajÄ… na serwer stagingowy (testowy)
</p>
<p>ğŸ‘‰ **Ale wdroÅ¼enie na produkcjÄ™ nadal wymaga rÄ™cznego potwierdzenia.** Daje to zespoÅ‚owi kontrolÄ™ nad tym, *kiedy* dokÅ‚adnie uÅ¼ytkownicy zobaczÄ… zmiany.</p>
<p>ğŸ¤– **Continuous Deployment (CiÄ…gÅ‚e WdraÅ¼anie)**<br>
Jest to kolejny krok po Continuous Delivery. Tutaj wdroÅ¼enie na produkcjÄ™ odbywa siÄ™ **caÅ‚kowicie automatycznie**, jeÅ›li wszystkie poprzednie etapy potoku (kompilacja, wszystkie testy) zakoÅ„czyÅ‚y siÄ™ pomyÅ›lnie. Jest to najbardziej zaawansowany poziom automatyzacji.</p>
<h3>ğŸ”„ Z czego zazwyczaj skÅ‚ada siÄ™ potok CI/CD?</h3>
<p>Typowy potok obejmuje nastÄ™pujÄ…ce etapy:</p>
<ol>
<li><strong>Checkout</strong> â€” Klonowanie najnowszej wersji kodu z repozytorium.</li>
<li><strong>Build</strong> â€” Budowanie projektu (kompilacja, tworzenie artefaktÃ³w, obrazÃ³w Docker).</li>
<li><strong>Test</strong> â€” Uruchamianie rÃ³Å¼nych rodzajÃ³w testÃ³w (jednostkowych, integracyjnych, E2E).</li>
<li><strong>Lint/Code Quality</strong> â€” Sprawdzanie kodu pod kÄ…tem zgodnoÅ›ci ze stylem i potencjalnych bÅ‚Ä™dÃ³w za pomocÄ… statycznych analizatorÃ³w.</li>
<li><strong>Deploy</strong> â€” WdraÅ¼anie aplikacji (na serwer stagingowy lub produkcyjny).</li>
<li><strong>Notify</strong> â€” WysyÅ‚anie powiadomieÅ„ o statusie potoku do zespoÅ‚u (np. w Slacku, e-mailu).</li>
</ol>
<h3>ğŸ›  Popularne narzÄ™dzia CI/CD:</h3>
<ul>
<li><strong>GitHub Actions</strong> (nasz dzisiejszy fokus!)</li>
<li>GitLab CI/CD</li>
<li>Jenkins</li>
<li>CircleCI</li>
<li>Bitbucket Pipelines</li>
<li>Azure DevOps</li>
<li>TeamCity</li>
</ul>
<h3>ğŸ§  Po co w ogÃ³le potrzebne jest CI/CD?</h3>
<ul>
<li><strong>Zmniejsza czynnik ludzki:</strong> Automatyzacja eliminuje bÅ‚Ä™dy zwiÄ…zane z rÄ™cznymi operacjami.</li>
<li><strong>Szybkie wykrywanie bÅ‚Ä™dÃ³w:</strong> BÅ‚Ä™dy sÄ… znajdowane wczeÅ›niej, co sprawia, Å¼e sÄ… Å‚atwiejsze i taÅ„sze w naprawie.</li>
<li><strong>Automatyzacja rutynowych zadaÅ„:</strong> Deweloperzy spÄ™dzajÄ… mniej czasu na budowaniu i wdraÅ¼aniu, a wiÄ™cej na kodowaniu.</li>
<li><strong>Poprawa jakoÅ›ci kodu:</strong> CiÄ…gÅ‚e sprawdzanie i testowanie podnosi ogÃ³lny poziom jakoÅ›ci.</li>
<li><strong>Szybkie dostarczanie funkcji uÅ¼ytkownikom:</strong> Nowe funkcje docierajÄ… do uÅ¼ytkownika koÅ„cowego szybciej i czÄ™Å›ciej.</li>
</ul>
<h3>ğŸ“¦ Proste przykÅ‚ady CI/CD z GitHub Actions</h3>
<p>Przyjrzyjmy siÄ™ podstawowym potokom dla popularnych technologii. Wszystkie przykÅ‚ady uÅ¼ywajÄ… GitHub Actions i sÄ… zapisywane w katalogu <code>.github/workflows/</code> Twojego projektu.</p>
<h4>ğŸ CI/CD dla Pythona (z `pytest` i `flake8`)</h4>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/python-ci.yml
name: Python CI

on: [push, pull_request]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11' # OkreÅ›l swojÄ… wersjÄ™

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt # Upewnij siÄ™, Å¼e masz requirements.txt
          pip install flake8 pytest

      - name: Lint with flake8
        run: |
          # SprawdÅº kod w folderach src i tests (dostosuj do swojego projektu)
          flake8 src tests

      - name: Run tests
        run: |
          pytest
</code></pre>
<h4>ğŸŒ CI/CD dla Node.js (z `npm test` i `eslint`)</h4>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/node-ci.yml
name: Node.js CI

on: [push, pull_request]

jobs:
  build:
    runs-on: ubuntu-latest

    strategy:
      matrix:
        node-version: [18.x] # OkreÅ›l swojÄ… wersjÄ™ Node.js

    steps:
      - uses: actions/checkout@v3

      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}

      - name: Install dependencies
        run: npm install # lub npm ci dla bardziej przewidywalnej instalacji

      - name: Lint with ESLint
        run: npx eslint . # Upewnij siÄ™, Å¼e ESLint jest skonfigurowany w projekcie

      - name: Run tests
        run: npm test
</code></pre>
<h4>ğŸ³ CI/CD dla Docker (budowanie i wypychanie do Docker Hub)</h4>
<p>W tym przykÅ‚adzie bÄ™dziesz potrzebowaÄ‡ sekretÃ³w <code>DOCKER_USERNAME</code> i <code>DOCKER_PASSWORD</code> (lub tokena) w ustawieniach repozytorium GitHub (<code>Settings -> Secrets and variables -> Actions</code>).</p>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/docker-ci.yml
name: Docker CI/CD

on:
  push:
    branches: [ main ] # Uruchamiaj tylko dla gaÅ‚Ä™zi main

jobs:
  docker:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Log in to Docker Hub
        run: echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin

      - name: Build Docker image
        # ZastÄ…p myapp nazwÄ… swojej aplikacji
        run: docker build -t ${{ secrets.DOCKER_USERNAME }}/myapp:latest .

      - name: Push Docker image
        run: docker push ${{ secrets.DOCKER_USERNAME }}/myapp:latest
</code></pre>
<h3>ğŸšš WdraÅ¼anie na popularne platformy</h3>
<p>Teraz, gdy mamy zbudowane i przetestowane artefakty (np. obraz Docker), zobaczmy, jak moÅ¼na je wdroÅ¼yÄ‡.</p>
<h4>ğŸŸ£ WdraÅ¼anie na Heroku</h4>
<p><strong>ğŸ” Sekrety GitHub:</strong> <code>HEROKU_API_KEY</code>, <code>HEROKU_APP_NAME</code>.</p>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/deploy-heroku.yml
name: Deploy to Heroku

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Install Heroku CLI
        run: curl https://cli-assets.heroku.com/install.sh | sh
      - name: Login to Heroku
        env:
          HEROKU_API_KEY: ${{ secrets.HEROKU_API_KEY }}
        run: heroku auth:token
      - name: Deploy to Heroku
        env:
          HEROKU_API_KEY: ${{ secrets.HEROKU_API_KEY }}
        run: |
          heroku git:remote -a ${{ secrets.HEROKU_APP_NAME }}
          git push heroku main -f # BÄ…dÅº ostroÅ¼ny z -f (force push)
</code></pre>
<p>JeÅ›li wdraÅ¼asz obraz Docker na Heroku:</p>
<pre class="line-numbers"><code class="language-yaml"># ... (kroki budowania i logowania do Docker Hub/GHCR z poprzednich przykÅ‚adÃ³w) ...
# deploy:
#   name: Deploy to Heroku
#   needs: build # ZaleÅ¼y od zadania budowania obrazu
#   runs-on: ubuntu-latest
#   steps:
#     # ...
#     - name: Login to Heroku container registry
#       run: echo "${{ secrets.HEROKU_API_KEY }}" | docker login --username=_ --password-stdin registry.heroku.com
#     - name: Tag image for Heroku
#       # ZakÅ‚adajÄ…c, Å¼e obraz jest zbudowany jako ghcr.io/username/repo/myapp:latest
#       run: docker tag ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}/myapp:latest registry.heroku.com/${{ secrets.HEROKU_APP_NAME }}/web
#     - name: Push image to Heroku
#       run: docker push registry.heroku.com/${{ secrets.HEROKU_APP_NAME }}/web
#     - name: Release Heroku App
#       env:
#         HEROKU_API_KEY: ${{ secrets.HEROKU_API_KEY }}
#       run: heroku container:release web --app ${{ secrets.HEROKU_APP_NAME }}
</code></pre>
<h3>ğŸŸ¨ WdraÅ¼anie na AWS (np. pliki statyczne do S3)</h3>
<p><strong>ğŸ” Sekrety GitHub:</strong> `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`, `AWS_REGION`, `S3_BUCKET_NAME`.</p>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/deploy-aws-s3.yml
name: Deploy Static Site to AWS S3

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
      - name: Sync files to S3
        # ZastÄ…p ./public Å›cieÅ¼kÄ… do swoich plikÃ³w statycznych
        run: aws s3 sync ./public s3://${{ secrets.S3_BUCKET_NAME }} --delete
</code></pre>
<p>Do wdroÅ¼enia na **AWS Elastic Beanstalk** zazwyczaj uÅ¼ywa siÄ™ EB CLI, potok bÄ™dzie podobny, ale z poleceniami `eb deploy`.</p>
<h3>ğŸ”µ WdraÅ¼anie na Google Cloud Platform (GCP App Engine)</h3>
<p><strong>ğŸ” Sekrety GitHub:</strong> `GCP_CREDENTIALS` (klucz JSON konta serwisowego), `GCP_PROJECT_ID`.</p>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/deploy-gcp-app-engine.yml
name: Deploy to GCP App Engine

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ secrets.GCP_PROJECT_ID }}
          service_account_key: ${{ secrets.GCP_CREDENTIALS }}
          export_default_credentials: true
      - name: Deploy to App Engine
        # Upewnij siÄ™, Å¼e masz app.yaml w katalogu gÅ‚Ã³wnym projektu
        run: gcloud app deploy --quiet
</code></pre>
<h3>ğŸŸª WdraÅ¼anie na Render.com</h3>
<p>Render czÄ™sto automatycznie wdraÅ¼a po pushu do GitHub, jeÅ›li repozytorium jest podÅ‚Ä…czone. Ale dla rÄ™cznego wyzwalacza (lub jako czÄ™Å›Ä‡ bardziej zÅ‚oÅ¼onego potoku) moÅ¼na uÅ¼yÄ‡ Deploy Hook.<br>
<strong>ğŸ” Sekrety GitHub:</strong> `RENDER_DEPLOY_HOOK` (URL uzyskany z ustawieÅ„ usÅ‚ugi Render).</p>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/deploy-render.yml
name: Trigger Render Deploy

on:
  workflow_dispatch: # RÄ™czne wyzwalanie z UI GitHub

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Trigger Render Deploy Hook
        run: curl -X POST ${{ secrets.RENDER_DEPLOY_HOOK }}
</code></pre>
<h3>ğŸŒŸ Zaawansowane CI/CD: Budowanie Docker â†’ Wypychanie do GHCR â†’ Staging/Production na GCP Cloud Run</h3>
<p>A teraz wisienka na torcie! Zbudujmy zaawansowany potok:
1.  Budowanie obrazu Docker.
2.  Publikowanie obrazu w GitHub Container Registry (ghcr.io).
3.  Automatyczne wdroÅ¼enie do Å›rodowiska **staging** na GCP Cloud Run.
4.  WdroÅ¼enie do Å›rodowiska **production** na GCP Cloud Run **po rÄ™cznym potwierdzeniu**.
</p>
<p>Do tego potrzebne bÄ™dÄ… nam pliki workflow.</p>
<p><strong>Wymagane sekrety GitHub:</strong></p>
<ul>
<li>`GCP_PROJECT_ID`: ID Twojego projektu w GCP.</li>
<li>`GCP_CREDENTIALS`: Klucz JSON konta serwisowego GCP z uprawnieniami do wdraÅ¼ania w Cloud Run i dostÄ™pu do GHCR (jeÅ›li potrzebne). Zazwyczaj `GITHUB_TOKEN` wystarcza do dostÄ™pu do GHCR z Actions.</li>
<li>`GCP_REGION`: Region dla Cloud Run (np. `europe-west1`).</li>
</ul>
<h3>1. Budowanie i publikowanie obrazu Docker w GHCR</h3>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/build.yml
name: Build & Push to GHCR

on:
  push:
    branches: [main] # Uruchamiaj po pushu do main

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: read      # Do checkout
      packages: write     # Do pushu do GHCR

    steps:
      - uses: actions/checkout@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}/myapp:latest
          # MoÅ¼esz dodaÄ‡ tagowanie po SHA commita dla unikalnoÅ›ci:
          # tags: |
          #   ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}/myapp:latest
          #   ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}/myapp:${{ github.sha }}
</code></pre>
<ul>
<li>`github.repository_owner`: WÅ‚aÅ›ciciel repozytorium (Twoja nazwa uÅ¼ytkownika lub organizacji).</li>
<li>`github.event.repository.name`: Nazwa repozytorium.</li>
<li>`myapp`: Nazwa Twojej aplikacji/obrazu.</li>
</ul>
<h3>2. Automatyczne wdroÅ¼enie do Staging (GCP Cloud Run)</h3>
<p>Ten workflow zostanie uruchomiony automatycznie po pomyÅ›lnym zakoÅ„czeniu `build.yml`.</p>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/deploy-staging.yml
name: Deploy to GCP Cloud Run (Staging)

on:
  workflow_run:
    workflows: ["Build & Push to GHCR"]
    types:
      - completed

jobs:
  deploy-staging:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' }}

    environment:
      name: staging
      url: ${{ steps.deploy.outputs.url }}

    steps:
      - uses: actions/checkout@v3

      - id: 'auth'
        uses: 'google-github-actions/auth@v2'
        with:
          credentials_json: '${{ secrets.GCP_CREDENTIALS }}'

      - name: 'Deploy to Cloud Run (Staging)'
        id: deploy
        uses: 'google-github-actions/deploy-cloudrun@v2'
        with:
          service: 'myapp-staging'
          region: '${{ secrets.GCP_REGION }}'
          image: 'ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}/myapp:latest'
          project_id: '${{ secrets.GCP_PROJECT_ID }}'
          flags: '--allow-unauthenticated --platform=managed'
</code></pre>
<h3>3. WdroÅ¼enie do Production z rÄ™cznym potwierdzeniem (GCP Cloud Run)</h3>
<p>Ten workflow jest wyzwalany rÄ™cznie za poÅ›rednictwem interfejsu uÅ¼ytkownika GitHub Actions.</p>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/deploy-prod.yml
name: Deploy to GCP Cloud Run (Production)

on:
  workflow_dispatch: # Pozwala na rÄ™czne wyzwalanie

jobs:
  deploy-production:
    runs-on: ubuntu-latest

    environment:
      name: production
      url: ${{ steps.deploy.outputs.url }}

    steps:
      - uses: actions/checkout@v3

      - id: 'auth'
        uses: 'google-github-actions/auth@v2'
        with:
          credentials_json: '${{ secrets.GCP_CREDENTIALS }}'

      - name: 'Deploy to Cloud Run (Production)'
        id: deploy
        uses: 'google-github-actions/deploy-cloudrun@v2'
        with:
          service: 'myapp-production'
          region: '${{ secrets.GCP_REGION }}'
          image: 'ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}/myapp:latest'
          project_id: '${{ secrets.GCP_PROJECT_ID }}'
          flags: '--allow-unauthenticated --platform=managed'
          # Dla produkcji moÅ¼esz dodaÄ‡ --no-traffic, a nastÄ™pnie stopniowo przenosiÄ‡ ruch
          # traffic:
          #   latest: true
          #   percent: 100
</code></pre>
<p><strong>WaÅ¼ne punkty tego zaawansowanego potoku:</strong></p>
<ul>
<li>**GitHub Container Registry (ghcr.io):** UÅ¼ywamy go do przechowywania obrazÃ³w Docker. Jest to wygodne, poniewaÅ¼ jest Å›ciÅ›le zintegrowane z GitHub Actions.</li>
<li>**`workflow_run`:** Pozwala na uruchomienie jednego workflow (wdroÅ¼enie staging) po zakoÅ„czeniu drugiego (budowanie).</li>
<li>**`workflow_dispatch`:** Zapewnia moÅ¼liwoÅ›Ä‡ rÄ™cznego wyzwalania workflow (wdroÅ¼enie produkcyjne), co zapewnia kontrolÄ™.</li>
<li>**GitHub Environments:** PozwalajÄ… na konfiguracjÄ™ reguÅ‚ ochrony dla produkcji (np. wymaganie zatwierdzenia od okreÅ›lonych recenzentÃ³w) i przechowywanie sekretÃ³w specyficznych dla Å›rodowiska.</li>
<li>**GCP Cloud Run:** DoskonaÅ‚a opcja serverless do uruchamiania aplikacji skonteneryzowanych.</li>
</ul>
<h3>ğŸ” BezpieczeÅ„stwo â€“ to waÅ¼ne!</h3>
<ul>
<li>**UÅ¼ywaj sekretÃ³w GitHub:** Nigdy nie przechowuj tokenÃ³w, haseÅ‚, kluczy API bezpoÅ›rednio w plikach YAML. UÅ¼yj `Settings -> Secrets and variables -> Actions` w swoim repozytorium.</li>
<li>**Minimalne uprawnienia:** Dla kont serwisowych (np. GCP) przyznawaj tylko te uprawnienia, ktÃ³re sÄ… absolutnie niezbÄ™dne do wykonywania zadaÅ„ CI/CD.</li>
<li>**Izoluj Å›rodowiska:** Staging i produkcja powinny byÄ‡ jak najbardziej izolowane. RÃ³Å¼ne projekty/konta u dostawcÃ³w chmury to dobra praktyka.</li>
<li>**Ochrona gaÅ‚Ä™zi:** Skonfiguruj ochronÄ™ dla gaÅ‚Ä™zi `main` (lub `master`) aby wypychanie do niej byÅ‚o moÅ¼liwe tylko poprzez Pull Request z obowiÄ…zkowymi kontrolami CI.
