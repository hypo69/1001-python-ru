<!-- Translated to en -->
<h2>üßë‚Äçüíª Using <code>array.array</code> in Python: when and why to apply</h2>
<p>The <strong><code>array</strong></code> module provides a specialized data type <code>array.array</code> for storing sequences of homogeneous numbers. Unlike the universal <code>list</code>, <code>array.array</code> arrays provide more efficient memory usage and increased performance when working with numerical data.</p>
<hr>
<h2>üì¶ Key advantages of <code>array.array</code></h2>
<p>The key difference between <code>array.array</code> and <code>list</code> is <strong>compact data storage</strong>. Instead of a list of pointers to Python objects, <code>array.array</code> stores values as a contiguous block of bytes, making it ideal for the following tasks.</p>
<hr>
<h3>1. Memory savings when working with large sets of numbers</h3>
<p>When processing millions of numerical elements, memory savings become critically important. <code>array.array</code> significantly reduces overhead.</p>
<pre class="line-numbers"><code class="language-python">import array
import sys

def compare_memory_usage(num_elements: int = 1_000_000) -> None:
    """
    Compares memory usage between list and array.array.

    Args:
        num_elements (int, optional): Number of elements for the test. 
                                      Defaults to 1,000,000.
    """
    # Create a list with integer Python objects
    list_numbers = list(range(num_elements))
    
    # Create an array where numbers are stored as 4-byte C-type ints
    array_numbers = array.array('i', range(num_elements))

    list_size = sys.getsizeof(list_numbers)
    array_size = sys.getsizeof(array_numbers)

    print(f"Number of elements: {num_elements}")
    print(f"List size:  {list_size / 1024 / 1024:.2f} MB")
    print(f"Array size: {array_size / 1024 / 1024:.2f} MB")
    if array_size > 0:
        print(f"Memory savings: {list_size / array_size:.2f}x")

# Example usage
if __name__ == "__main__":
    compare_memory_usage()
</code></pre>
<p><strong>Output:</strong></p>
<pre class="line-numbers"><code>Number of elements: 1000000
List size:  7.63 MB
Array size: 3.82 MB
Memory savings: 2.00x
</code></pre>
<hr>
<h3>2. Increased performance of numerical operations</h3>
<p>Due to contiguous memory allocation, mathematical operations on <code>array.array</code> elements are performed faster, as the processor can make more efficient use of the cache.</p>
<pre class="line-numbers"><code class="language-python">import array
import timeit

def compare_performance(num_elements: int = 10_000_000) -> None:
    """
    Compares the performance of summing elements in list and array.array.

    Args:
        num_elements (int, optional): Number of elements for the test. 
                                      Defaults to 10,000,000.
    """
    setup_code = f"""
import array
data = range({num_elements})
list_data = list(data)
array_data = array.array('i', data)
"""
    
    # Measure time for list
    list_time = timeit.timeit("sum(list_data)", setup=setup_code, number=10)
    
    # Measure time for array
    array_time = timeit.timeit("sum(array_data)", setup=setup_code, number=10)
    
    print(f"Time to sum {num_elements} elements (10 times):")
    print(f"list:  {list_time:.4f} seconds")
    print(f"array: {array_time:.4f} seconds")

# Example usage
if __name__ == "__main__":
    compare_performance()
</code></pre>
<p><strong>Output:</strong></p>
<pre class="line-numbers"><code>Number of elements: 10000000
List size:  2.1106 seconds
Array size: 1.1549 seconds
</code></pre>
<hr>
<h3>3. Direct work with C libraries (<code>ctypes</code>, <code>struct</code>)</h3>
<p><code>array.array</code> is ideal for passing data to low-level libraries written in C, as its internal structure is compatible with C arrays.</p>
<h4>Example with <code>ctypes</code>:</h4>
<pre class="line-numbers"><code class="language-python">import array
from ctypes import c_double, CDLL

def demonstrate_ctypes_usage() -> None:
    """
    Demonstrates passing array.array to a C function via ctypes.
    """
    # Array with double-precision numbers (type 'd')
    py_array = array.array('d', [1.1, 2.2, 3.3, 4.4])
    
    # Create a C-compatible array from py_array
    # The function (c_double * len(py_array)) creates a type "array of 4 c_double"
    # (*py_array) unpacks the python array into the arguments of this constructor
    c_array = (c_double * len(py_array))(*py_array)

    # Here could be a call to a C function, for example:
    # my_c_library = CDLL("./libmath.so")
    # my_c_library.sum_doubles(c_array, len(c_array))
    
    print(f"Python array: {py_array}")
    print(f"C-compatible array (ctypes): {[val for val in c_array]}")

# Example usage
if __name__ == "__main__":
    demonstrate_ctypes_usage()
</code></pre>
<h4>Example with <code>struct</code> for data packing:</h4>
<pre class="line-numbers"><code class="language-python">import array
import struct

def demonstrate_struct_packing(data: list[int]) -> bytes:
    """
    Packs an array of integers into a binary string.

    Args:
        data (list[int]): List of integers to pack.

    Returns:
        bytes: Binary representation of the data.
    """
    arr = array.array('i', data)
    
    # Create a format string like '3i' for 3 integers
    format_string = f'{len(arr)}i'
    
    # Pack data into binary format
    binary_data = struct.pack(format_string, *arr)
    
    print(f"Original array: {arr}")
    print(f"Binary data: {binary_data}")
    
    # Check: unpack back
    unpacked_data = struct.unpack(format_string, binary_data)
    print(f"Unpacked data: {unpacked_data}")
    
    return binary_data

# Example usage
if __name__ == "__main__":
    demonstrate_struct_packing([10, 20, 30])
</code></pre>
<hr>
<h3>4. Efficient serialization and deserialization</h3>
<p>The <code>.tobytes()</code> and <code>.frombytes()</code> methods allow quickly converting an array to bytes and back, which is ideal for saving to files or transmitting over a network.</p>
<pre class="line-numbers"><code class="language-python">import array

def handle_binary_data() -> None:
    """
    Demonstrates serialization and deserialization of array.array to bytes.
    """
    # Create original array
    source_array = array.array('i', [1, 2, 3, 4, 5])
    print(f"Original array: {source_array}")

    # Serialize array to bytes
    binary_data = source_array.tobytes()
    print(f"Data in bytes: {binary_data}")

    # Deserialize from bytes to new array
    new_array = array.array('i')
    new_array.frombytes(binary_data)
    print(f"Restored array: {new_array}")

    # Check integrity
    assert source_array == new_array, "Data mismatch!"
    print("Data integrity confirmed.")

# Example usage
if __name__ == "__main__":
    handle_binary_data()
</code></pre>
<hr>
<h3>5. Guarantee of type homogeneity</h3>
<p><code>array.array</code> strictly enforces only one data type, specified at creation. This prevents accidental addition of elements of a different type.</p>
<pre class="line-numbers"><code class="language-python">import array

def demonstrate_type_safety() -> None:
    """
    Shows that array.array does not allow adding elements of a different type.
    """
    arr = array.array('i', [100, 200, 300])
    print(f"Integer array: {arr}")
    
    try:
        # Attempt to add a string element
        arr.append('hello')
    except TypeError as e:
        # Expected exception
        print(f"\nAttempt to add 'hello' raised an error: {e}")
        print("This confirms strict array typing.")

# Example usage
if __name__ == "__main__":
    demonstrate_type_safety()
</code></pre>
<hr>
<h3>6. Direct writing and reading from binary files</h3>
<p>The <code>.tofile()</code> and <code>.fromfile()</code> methods simplify working with binary files, avoiding intermediate serialization.</p>
<pre class="line-numbers"><code class="language-python">import array
from pathlib import Path

def work_with_binary_files(file_path_str: str = "data.bin") -> None:
    """
    Writes an array to a binary file and reads it back.

    Args:
        file_path_str (str, optional): File name for saving.
                                       Defaults to "data.bin".
    """
    file_path = Path(file_path_str)
    source_array = array.array('f', [1.5, 2.7, 3.14])

    try:
        # Write to file
        with file_path.open('wb') as f:
            source_array.tofile(f)
        print(f"Array {source_array} written to file '{file_path}'.")

        # Read from file
        new_array = array.array('f')
        with file_path.open('rb') as f:
            # Read 3 elements of type 'f' (float)
            new_array.fromfile(f, len(source_array))
        print(f"Array {new_array} read from file.")
        
        assert source_array == new_array
        print("Data integrity confirmed.")

    finally:
        # Guaranteed file deletion after execution
        if file_path.exists():
            file_path.unlink()
            print(f"Temporary file '{file_path}' deleted.")

# Example usage
if __name__ == "__main__":
    work_with_binary_files()
</code></pre>
<hr>
<h2>üîπ Comparative table: <code>array.array</code> vs <code>list</code></h2>
<table>
<thead>
<tr>
<th>Characteristic</th>
<th><code>array.array</code></th>
<th><code>list</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Data type</strong></td>
<td>Homogeneous primitives (numbers, characters)</td>
<td>Any Python objects</td>
</tr>
<tr>
<td><strong>Memory</strong></td>
<td>Low consumption</td>
<td>High consumption</td>
</tr>
<tr>
<td><strong>Performance</strong></td>
<td>High for numerical operations</td>
<td>Lower for numerical operations</td>
</tr>
<tr>
<td><strong>API</strong></td>
<td>Limited set of methods</td>
<td>Rich and flexible API</td>
</tr>
<tr>
<td><strong>C compatibility</strong></td>
<td>High, direct data transfer</td>
<td>Conversions required</td>
</tr>
<tr>
<td><strong>Binary serialization</strong></td>
<td>Built-in methods (<code>.tobytes</code>, <code>.tofile</code>)</td>
<td>Requires <code>struct</code>, <code>pickle</code>, etc.</td>
</tr>
</tbody>
</table>
<hr>
<p><strong>Conclusion:</strong></p>
<p>üöÄ Use <code>array.array</code> when working with large volumes of <strong>homogeneous numerical data</strong>, and when <strong>performance</strong> and <strong>efficient memory usage</strong> are critical for you.</p>
<p>For most everyday tasks where flexibility and storage of heterogeneous data are required, <code>list</code> remains the best choice.</p>
