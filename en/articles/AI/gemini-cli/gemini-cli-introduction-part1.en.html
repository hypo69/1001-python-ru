<h2>Gemini CLI: Introduction and First Steps.</h2>
<p><strong>Gemini CLI</strong> is a tool that works directly in your terminal, understands your codebase, and helps you fix bugs using natural language queries. It is Google's answer to Anthropic's Claude Code.
YouYou can use Gemini 2.5 Pro (when you reach the limit, the tool will switch to Gemini 2.5 Flash) and its 1 million token context window to make up to 60 queries per minute and 1000 queries per day, all for free.</p>
<h3>Table of Contents</h3>
<ul>
<li>Understanding and navigating large codebases</li>
<li>Detecting and fixing errors</li>
<li>Writing and testing code</li>
<li>Gemini CLI tools</li>
<li>Integrating Google CLI with MCP</li>
</ul>
<h3>Key Features of Gemini CLI:</h3>
<ul>
<li><strong>Editing and Refactoring:</strong> Automatically improves and simplifies your code under AI guidance.</li>
<li><strong>Error Detection and Correction:</strong> Finds bugs and suggests fixes.</li>
<li><strong>Code Understanding:</strong> Gemini CLI can summarize architecture, explain module roles, or build execution flow maps.</li>
<li><strong>Test Generation:</strong> Automatically creates test cases for <code>pytest</code></li>
<li><strong>Documentation Support:</strong> You can create structured markdown documents, changelogs, and responses to GitHub issues directly in the terminal.</li>
<li><strong>Command Execution:</strong> Gemini CLI can execute shell commands such as <code>git</code>, <code>npm</code>, <code>pip</code>, and others, allowing you to manage projects without leaving the CLI.</li>
</ul>
<hr>
<h3>Step 1: Prerequisites</h3>
<p>To get started, install Node.js (version 18 or higher). You can download the installer of your choice or run the following bash commands in your terminal:</p>
<pre class="line-numbers"><code class="language-bash"># Download and install nvm (Node Version Manager):
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.3/install.sh | bash

# Initialize nvm in the current terminal session
. "$HOME/.nvm/nvm.sh"

# Download and install Node.js (e.g., version 22):
nvm install 22

# Check the Node.js version:
node -v # Should output "v22.17.0" or similar

# Check the npm version:
npm -v # Should output "10.9.2" or similar
</code></pre>
<blockquote>
<p>‚ö†Ô∏è <strong>Important for Windows users:</strong>
The <code>nvm</code> command above is for <strong>Linux/macOS</strong> and <strong>will not work in PowerShell or cmd.exe</strong>.
For Windows, use <a href="https://github.com/coreybutler/nvm-windows">nvm-windows</a> by downloading <code>nvm-setup.exe</code> from the <a href="https://github.com/coreybutler/nvm-windows/releases">Releases</a> section.
Alternatively, you can install WSL (Windows Subsystem for Linux) and run the commands in Ubuntu or another Linux distribution.</p>
</blockquote>
<hr>
<h3>Step 2: Setting up Gemini CLI</h3>
<h4>Step 2.1: Installing Gemini CLI</h4>
<p>Once Node.js and npm are installed and verified, install Gemini CLI by running the following command in your terminal:</p>
<pre class="line-numbers"><code class="language-bash">npx https://github.com/google-gemini/gemini-cli
</code></pre>
<p>Or use <code>npm</code> for a global installation:</p>
<pre class="line-numbers"><code class="language-bash">npm install -g @google/gemini-cli
gemini
</code></pre>
<p>After installation, type <code>gemini</code> in the terminal to access the tool.</p>
<h4>Step 2.2: Authentication</h4>
<p>You can use your personal Google account for authentication. This will give you up to 60 queries per minute and 1000 queries per day when using Gemini.
<img src="assets/gemini_cli_1/auth.png" alt="First Run"></p>
<p>In this guide, I used <strong>Sign in with Google</strong>, but you can also use an <strong>API key</strong> (set as an environment variable or in a <code>.env</code> file) or authentication via <strong>Vertex AI</strong>.</p>
<p>To generate a new API key, sign in to <strong>AI Studio</strong> with your Google account and click "Create API key".</p>
<pre class="line-numbers"><code class="language-bash"># Set the key as an environment variable
export GEMINI_API_KEY="Your_API_Key"

# Or create a .env file
GEMINI_API_KEY="Your_API_Key"
</code></pre>
<p>You can use the <code>/auth</code> command in the text box to switch the authentication method as needed.</p>
<hr>
<h3>Step 3: Setting up a project in Gemini CLI</h3>
<p><img src="assets/gemini_cli_1/start.png" alt="Start"></p>
<p>Once the CLI is running, we can start interacting with Gemini from the terminal. There are two ways to work with a project.</p>
<h4>1. Start a new project</h4>
<p>To start a project from scratch, run the following commands:</p>
<pre class="line-numbers"><code class="language-bash">cd new-project/
gemini
</code></pre>
<p>Inside the CLI, use a prompt to solve the problem you are interested in, for example:</p>
<blockquote>
<p>Write the encoder code for a transformer from scratch.</p>
</blockquote>
<p><img src="assets/gemini_cli_1/example_1.png" alt="Example 1"></p>
<p>Give permission to write files:
<img src="assets/gemini_cli/file.png" alt="File"></p>
<h4>2. Work with an existing project</h4>
<p>If you already have a codebase, you can work with it by running the following commands:</p>
<pre class="line-numbers"><code class="language-bash">git clone https://github.com/AashiDutt/Google-Agent-Development-Kit-Demo
cd Google-Agent-Development-Kit-Demo
gemini
</code></pre>
<p>Inside the CLI, use a prompt, for example:</p>
<blockquote>
<p>Provide me with a summary of all changes made to the codebase in the last month.</p>
</blockquote>
<hr>
<h3>Step 4: Experimenting with Gemini CLI</h3>
<p>As an example, I will use the <strong><a href="https://github.com/AashiDutt/Google-Agent-Development-Kit-Demo">ADK-based üåçüõ´ travel planner</a></strong> project.
With Gemini CLI, I will show you how to:
1.  explore the codebase
2.  detect a bug or issue on GitHub or in a file
3.  refactor the code and generate unit tests
4.  create a markdown report of the changes made
5.  visualize the codebase by generating a flowchart</p>
<h4>Exploring and understanding the codebase</h4>
<p>Let's start by asking Gemini to explore and explain the codebase.</p>
<p><strong>Prompt:</strong> <code>Explore the current directory and describe the project architecture.</code></p>
<p>Gemini CLI will return a structured summary explaining the architecture:</p>
<ul>
<li><strong>User Interface:</strong> A Streamlit application (<code>travel_ui.py</code>) provides the interface for interaction.</li>
<li><strong>Orchestration:</strong> <code>host_agent</code> acts as a central coordinator.</li>
<li><strong>Specialized agents:</strong> <code>flight_agent</code>, <code>stay_agent</code>, <code>activities_agent</code> for searching for flights, hotels, and activities.</li>
<li><strong>Communication:</strong> Agents communicate with each other via a RESTful API on FastAPI.</li>
<li><strong>Shared components:</strong> <code>shared/schemas.py</code> defines shared data structures.</li>
</ul>
<p>This will help you get your bearings without reading each file manually.</p>
<h4>Analyzing and fixing a problem on GitHub</h4>
<p>Let's explore some open issues from the GitHub repository.</p>
<p><strong>Prompt:</strong> <code>Here is a GitHub issue: [@search https://github.com/AashiDutt/Google-Agent-Development-Kit-Demo/issues/1]. Analyze the codebase and propose a 3-step fix plan. Which files/functions should be changed?</code></p>
<p>Gemini CLI investigated the issue:</p>
<ul>
<li>Using the <code>@search</code> function, it retrieved data from GitHub.</li>
<li>Identified the root cause as a JSON serialization error (in this case, the asynchronous function <code>create_session()</code> was not called with <code>await</code>).</li>
<li>Suggested changes and response handling in several files.</li>
</ul>
<p>Next, the CLI waits for user input to evaluate the changes. If the user agrees, it will apply the suggested changes.</p>
<h4>Implementing and testing the fix</h4>
<p>Now let's implement and test the fixes suggested by Gemini.</p>
<p><strong>Prompt:</strong> <code>Write a unit test for this change in pytest in the test_shared.py file.</code></p>
<p>Gemini CLI:</p>
<ul>
<li>Inserted <code>json.dumps()</code> before sending the task payload.</li>
<li>Created <code>test_agents.py</code> to add unit tests.</li>
<li>Added a new test case to check the schema and the transfer of nested agent messages.</li>
</ul>
<h4>Generating documentation</h4>
<p>Now that the fixes have been made, let's summarize the changes and write them down in Markdown in a <code>.txt</code> file.</p>
<p><strong>Prompt:</strong> <code>Write a markdown summary of the bug, the fix, and the test coverage. Format it as a changelog entry under version "v0.2.0".</code></p>
<p>Then, to save the summary to a document, I used the following prompt:</p>
<p><strong>Prompt:</strong> <code>Save this summary to a .txt file and name it summary.txt</code></p>
<p>Gemini CLI uses the <code>WriteFile</code> tool to save the <code>summary.txt</code> file to the project directory.</p>
<h4>Generating a flowchart using MCP</h4>
<p>This section expands on the previous experiments, where I explore how Gemini CLI uses the <strong>Model Context Protocol (MCP)</strong> to maintain file-level summaries and task history between prompts. This gives Gemini a "working memory" within a session.</p>
<p><strong>Prompt:</strong> <code>Generate a flowchart that shows how agents communicate via A2A (agent-to-agent) and how main.py manages the system. Highlight where the problem occurred and how it was fixed.</code></p>
<p>This visualization was made possible by Gemini's persistent memory, which retained the full context of our previous bug fix and agent structure without having to reload the files.</p>
<h3>Available Gemini CLI tools</h3>
<p>Calling the <code>/tools</code> command in Gemini CLI will show a list of available tools that can be used to perform various tasks, such as editing code, generating tests, creating documentation, and much more.
<img src="assets/gemini_cli_1/tools.png" alt="Tools"></p>
<p><strong>ReadFolder (ls)</strong>
Lists files and folders in a directory ‚Äî analogous to the <code>ls</code> command in the command line.</p>
<p><strong>ReadFile (read-file)</strong>
Reads the full content of a single file, which is useful for creating summaries or analysis.</p>
<p><strong>ReadManyFiles (read-many-files)</strong>
Reads multiple files at once, usually by a pattern (e.g., all <code>.js</code> files).</p>
<p><strong>FindFiles (glob)</strong>
Searches for files by a pattern (e.g., find all <code>config.json</code> files in your project).</p>
<p><strong>SearchText (grep)</strong>
Searches for text within files, for example, to find all <code>TODO</code> comments.</p>
<p><strong>Edit (edit)</strong>
Applies changes to the code using <code>diff</code>. Gemini shows a preview of the edits and asks for confirmation before applying them.</p>
<p><strong>WriteFile (write-file)</strong>
Creates new files (e.g., <code>README.md</code>) with content provided by the user.</p>
<p><strong>Shell (shell)</strong>
Executes commands directly in the terminal if you prefix them with <code>!</code> (e.g., <code>!npm test</code>).</p>
<p><strong>WebFetch (web-fetch)</strong>
Downloads content from the web (HTML or JSON), allowing Gemini to analyze external data.</p>
<p><strong>GoogleSearch (web-search)</strong>
Performs a Google search to base answers on real-world information (e.g., to find an explanation for an error).</p>
<p><strong>Save Memory (memoryTool)</strong>
Saves facts or preferences during a session (e.g., "I prefer async/await") to improve the consistency and coherence of responses.</p>
<h3>Advanced Features</h3>
<p>You can add special instructions for the AI for a specific project,
by creating a <code>GEMINI.md</code> file in the root directory of your project.
Inside this file, you can define project rules,
code styles, and tools that the agent should use. This ensures that the generated code complies with your project's standards.</p>
<p><a href="https://github.com/hypo69/hypotez/blob/master/src/endpoints/hypo69/code_assistant/instructions/CODE_RULES.EN.MD">Example of a system instruction</a></p>
<h3>Integrating Google CLI with MCP</h3>
<p>For most everyday tasks, the built-in tools will suffice. But what if you want Gemini CLI to do something highly specialized, such as interacting with specific APIs or using a specialized model (say, an image generator or a security analysis tool)? This is where MCP (Model Context Protocol) comes in.</p>
<p>In essence, MCP is an open standard that allows developers to add new tools and capabilities to the AI by running a server that the CLI can interact with. In Gemini CLI, you can configure "MCP servers" in a JSON settings file, and the CLI will treat them as additional tools it can use.</p>
<h4>How to set up an MCP server in Google CLI</h4>
<p>As an example, I will show you how to set up an MCP server for GitHub in Gemini CLI.</p>
<p>Inside your project folder, create a folder using the command:</p>
<pre class="line-numbers"><code class="language-bash">mkdir -p .gemini &amp;&amp; touch .gemini/settings.json
</code></pre>
<p>Fill the file with this code:</p>
<pre class="line-numbers"><code class="language-json">{  
  "mcpServers": {  
    "github": {  
      "command": "npx",  
      "args": ["-y", "@modelcontextprotocol/server-github"],  
      "env": { "GITHUB_PERSONAL_ACCESS_TOKEN": "[YOUR-TOKEN]" }  
    }  
  }  
}
</code></pre>
<p><a href="https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens#creating-a-personal-access-token-classic">instructions on how to get a token</a>
After that, type <code>/quit</code> in Gemini CLI to exit, and then open it again.
YouYou will see that the GitHub MCP server is running and ready to use.
<img src="assets/gemini_cli_1/mcp.png" alt="MCP"></p>
<p>Type the <code>/mcp</code> command, and you will see a list of GitHub tools.
<img src="assets/gemini_cli_1/mcp_commands.png" alt="Mcp Commands"></p>