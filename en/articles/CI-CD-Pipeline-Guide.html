<p>üöÄ <strong>CI/CD: From Basics to Production on GCP with GitHub Actions ‚Äì A Complete Guide with Examples</strong> üöÄ</p>
<p>Hello, developers! In this article, I will discuss CI/CD ‚Äì the concept.</p>
<h3>What is a CI/CD pipeline in the context of programming?</h3>
<p><strong>A CI/CD pipeline (Continuous Integration / Continuous Delivery or Continuous Deployment)</strong> is an automated process that allows developers to quickly and reliably deliver code changes to a production environment.</p>
<p>Let's break down the key concepts:</p>
<p>üîß <strong>CI ‚Äî Continuous Integration</strong>
This is a practice where developers frequently integrate changes into a shared codebase. Each such change is automatically:</p>
<ul>
<li><strong>Built</strong></li>
<li><strong>Tested</strong> (unit tests, integration tests)</li>
<li><strong>Checked for compliance with standards</strong> (linting, static analysis)</li>
</ul>
<p>üëâ <strong>CI Goal:</strong> To identify errors at the earliest stage, before they break something important or reach release.</p>
<p>üöÄ <strong>CD ‚Äî Continuous Delivery or Continuous Deployment</strong>
There are two options here:</p>
<p>‚úÖ <strong>Continuous Delivery</strong>
After successfully passing the CI stage, changes automatically:</p>
<ul>
<li>Undergo additional tests (e.g., E2E ‚Äì end-to-end tests)</li>
<li>Are deployed to a staging (test) server</li>
</ul>
<p>üëâ <strong>However, deployment to production still requires manual approval.</strong> This gives the team control over <em>when</em> exactly users will see the changes.</p>
<p>ü§ñ <strong>Continuous Deployment</strong>
This is the next step after Continuous Delivery. Here, deployment to production happens <strong>fully automatically</strong> if all previous pipeline stages (build, all tests) are successful. This is the most advanced level of automation.</p>
<h3>üîÑ What does a CI/CD pipeline typically consist of?</h3>
<p>A typical pipeline includes the following stages:</p>
<ol>
<li><strong>Checkout</strong> ‚Äî Cloning the latest version of the code from the repository.</li>
<li><strong>Build</strong> ‚Äî Building the project (compilation, artifact assembly, Docker images).</li>
<li><strong>Test</strong> ‚Äî Running various types of tests (unit, integration, E2E).</li>
<li><strong>Lint/Code Quality</strong> ‚Äî Checking code for style compliance and potential errors using static analyzers.</li>
<li><strong>Deploy</strong> ‚Äî Deploying the application (to a staging or production server).</li>
<li><strong>Notify</strong> ‚Äî Sending pipeline status notifications to the team (e.g., Slack, Email).</li>
</ol>
<h3>üõ† Popular CI/CD Tools:</h3>
<ul>
<li><strong>GitHub Actions</strong> (our focus today!)</li>
<li>GitLab CI/CD</li>
<li>Jenkins</li>
<li>CircleCI</li>
<li>Bitbucket Pipelines</li>
<li>Azure DevOps</li>
<li>TeamCity</li>
</ul>
<h3>üß† Why do we need CI/CD at all?</h3>
<ul>
<li><strong>Reduces human error:</strong> Automation eliminates errors associated with manual operations.</li>
<li><strong>Fast bug detection:</strong> Errors are found earlier, making them easier and cheaper to fix.</li>
<li><strong>Automation of routine tasks:</strong> Developers spend less time on building and deploying, and more on coding.</li>
<li><strong>Improved code quality:</strong> Continuous checks and tests raise the overall quality bar.</li>
<li><strong>Faster feature delivery to users:</strong> New features reach the end-user more quickly and frequently.</li>
</ul>
<h3>üì¶ Simple CI/CD Examples with GitHub Actions</h3>
<p>Let's look at basic pipelines for popular technologies. All examples use GitHub Actions and are saved in the <code>.github/workflows/</code> directory of your project.</p>
<h4>üêç CI/CD for Python (with <code>pytest</code> and <code>flake8</code>)</h4>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/python-ci.yml
name: Python CI

on: [push, pull_request]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11' # Specify your version

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt # Make sure you have requirements.txt
          pip install flake8 pytest

      - name: Lint with flake8
        run: |
          # Check code in src and tests folders (adapt to your project)
          flake8 src tests

      - name: Run tests
        run: |
          pytest
</code></pre>
<h4>üåê CI/CD for Node.js (with <code>npm test</code> and <code>eslint</code>)</h4>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/node-ci.yml
name: Node.js CI

on: [push, pull_request]

jobs:
  build:
    runs-on: ubuntu-latest

    strategy:
      matrix:
        node-version: [18.x] # Specify your Node.js version

    steps:
      - uses: actions/checkout@v3

      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}

      - name: Install dependencies
        run: npm install # or npm ci for a more predictable installation

      - name: Lint with ESLint
        run: npx eslint . # Make sure ESLint is configured in the project

      - name: Run tests
        run: npm test
</code></pre>
<h4>üê≥ CI/CD for Docker (build and push to Docker Hub)</h4>
<p>For this example, you will need <code>DOCKER_USERNAME</code> and <code>DOCKER_PASSWORD</code> (or token) secrets in your GitHub repository settings (<code>Settings -> Secrets and variables -> Actions</code>).</p>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/docker-ci.yml
name: Docker CI/CD

on:
  push:
    branches: [ main ] # Run only for the main branch

jobs:
  docker:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Log in to Docker Hub
        run: echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin

      - name: Build Docker image
        # Replace myapp with your application name
        run: docker build -t ${{ secrets.DOCKER_USERNAME }}/myapp:latest .

      - name: Push Docker image
        run: docker push ${{ secrets.DOCKER_USERNAME }}/myapp:latest
</code></pre>
<h3>üöö Deploy to Popular Platforms</h3>
<p>Now that we have built and tested artifacts (e.g., a Docker image), let's see how they can be deployed.</p>
<h4>üü£ Deploy to Heroku</h4>
<p><strong>üîê GitHub Secrets:</strong> <code>HEROKU_API_KEY</code>, <code>HEROKU_APP_NAME</code>.</p>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/deploy-heroku.yml
name: Deploy to Heroku

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Install Heroku CLI
        run: curl https://cli-assets.heroku.com/install.sh | sh
      - name: Login to Heroku
        env:
          HEROKU_API_KEY: ${{ secrets.HEROKU_API_KEY }}
        run: heroku auth:token
      - name: Deploy to Heroku
        env:
          HEROKU_API_KEY: ${{ secrets.HEROKU_API_KEY }}
        run: |
          heroku git:remote -a ${{ secrets.HEROKU_APP_NAME }}
          git push heroku main -f # Be careful with -f (force push)
</code></pre>
<p>If you are deploying a Docker image to Heroku:</p>
<pre class="line-numbers"><code class="language-yaml"># ... (build and login to Docker Hub/GHCR steps from previous examples) ...
# deploy:
#   name: Deploy to Heroku
#   needs: build # Depends on the image build job
#   runs-on: ubuntu-latest
#   steps:
#     # ...
#     - name: Login to Heroku container registry
#       run: echo "${{ secrets.HEROKU_API_KEY }}" | docker login --username=_ --password-stdin registry.heroku.com
#     - name: Tag image for Heroku
#       # Assuming the image is built as ghcr.io/username/repo/myapp:latest
#       run: docker tag ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}/myapp:latest registry.heroku.com/${{ secrets.HEROKU_APP_NAME }}/web
#     - name: Push image to Heroku
#       run: docker push registry.heroku.com/${{ secrets.HEROKU_APP_NAME }}/web
#     - name: Release Heroku App
#       env:
#         HEROKU_API_KEY: ${{ secrets.HEROKU_API_KEY }}
#       run: heroku container:release web --app ${{ secrets.HEROKU_APP_NAME }}
</code></pre>
<h4>üü® Deploy to AWS (e.g., static files to S3)</h4>
<p><strong>üîê GitHub Secrets:</strong> <code>AWS_ACCESS_KEY_ID</code>, <code>AWS_SECRET_ACCESS_KEY</code>, <code>AWS_REGION</code>, <code>S3_BUCKET_NAME</code>.</p>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/deploy-aws-s3.yml
name: Deploy Static Site to AWS S3

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
      - name: Sync files to S3
        # Replace ./public with the path to your static files
        run: aws s3 sync ./public s3://${{ secrets.S3_BUCKET_NAME }} --delete
</code></pre>
<p>For deployment to <strong>AWS Elastic Beanstalk</strong>, EB CLI is usually used, the pipeline will be similar, but with <code>eb deploy</code> commands.</p>
<h4>üîµ Deploy to Google Cloud Platform (GCP App Engine)</h4>
<p><strong>üîê GitHub Secrets:</strong> <code>GCP_CREDENTIALS</code> (JSON key of the service account), <code>GCP_PROJECT_ID</code>.</p>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/deploy-gcp-app-engine.yml
name: Deploy to GCP App Engine

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ secrets.GCP_PROJECT_ID }}
          service_account_key: ${{ secrets.GCP_CREDENTIALS }}
          export_default_credentials: true
      - name: Deploy to App Engine
        # Make sure you have app.yaml in the project root
        run: gcloud app deploy --quiet
</code></pre>
<h4>üü™ Deploy to Render.com</h4>
<p>Render often automatically deploys on push to GitHub if the repository is connected. But for a manual trigger (or as part of a more complex pipeline), you can use a Deploy Hook.
<strong>üîê GitHub Secrets:</strong> <code>RENDER_DEPLOY_HOOK</code> (URL obtained from Render service settings).</p>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/deploy-render.yml
name: Trigger Render Deploy

on:
  workflow_dispatch: # Allows manual trigger

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Trigger Render Deploy Hook
        run: curl -X POST ${{ secrets.RENDER_DEPLOY_HOOK }}
</code></pre>
<h3>üåü Advanced CI/CD: Build Docker ‚Üí Push to GHCR ‚Üí Staging/Production on GCP Cloud Run</h3>
<p>And now, the cherry on top! Let's build an advanced pipeline:
1.  Build Docker image.
2.  Publish image to GitHub Container Registry (ghcr.io).
3.  Automatic deployment to <strong>staging</strong> environment on GCP Cloud Run.
4.  Deployment to <strong>production</strong> environment on GCP Cloud Run <strong>after manual approval</strong>.</p>
<p>For this, we will need several workflow files.</p>
<p><strong>Required GitHub Secrets:</strong></p>
<ul>
<li><code>GCP_PROJECT_ID</code>: Your GCP project ID.</li>
<li><code>GCP_CREDENTIALS</code>: JSON key of a GCP service account with permissions to deploy to Cloud Run and access GHCR (if needed). <code>GITHUB_TOKEN</code> is usually sufficient for GHCR access from Actions.</li>
<li><code>GCP_REGION</code>: Region for Cloud Run (e.g., <code>europe-west1</code>).</li>
</ul>
<h4>1. Build and Publish Docker Image to GHCR</h4>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/build.yml
name: Build &amp; Push to GHCR

on:
  push:
    branches: [main] # Run on push to main

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read      # For checkout
      packages: write     # For pushing to GHCR

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}/myapp:latest
          # You can add tagging by commit SHA for uniqueness:
          # tags: |
          #   ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}/myapp:latest
          #   ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}/myapp:${{ github.sha }}
</code></pre>
<ul>
<li><code>github.repository_owner</code>: Repository owner (your username or organization).</li>
<li><code>github.event.repository.name</code>: Repository name.</li>
<li><code>myapp</code>: Your application/image name.</li>
</ul>
<h4>2. Automatic Deployment to Staging (GCP Cloud Run)</h4>
<p>This workflow will run automatically after <code>build.yml</code> successfully completes.</p>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/deploy-staging.yml
name: Deploy to GCP Cloud Run (Staging)

on:
  workflow_run:
    workflows: ["Build &amp; Push to GHCR"] # Name of the build workflow
    types:
      - completed

jobs:
  deploy-staging:
    runs-on: ubuntu-latest
    # Run only if the build workflow completed successfully
    if: ${{ github.event.workflow_run.conclusion == 'success' }}

    # Use GitHub Environments for staging (optional, but good practice)
    environment:
      name: staging
      url: ${{ steps.deploy.outputs.url }} # URL will be available after deployment

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3 # Needed if you use configurations from the repository

      - id: 'auth'
        uses: 'google-github-actions/auth@v2'
        with:
          credentials_json: '${{ secrets.GCP_CREDENTIALS }}'

      - name: 'Deploy to Cloud Run (Staging)'
        id: deploy
        uses: 'google-github-actions/deploy-cloudrun@v2'
        with:
          service: 'myapp-staging' # Your staging service name in Cloud Run
          region: '${{ secrets.GCP_REGION }}'
          # Use the image that was pushed in build.yml
          image: 'ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}/myapp:latest'
          project_id: '${{ secrets.GCP_PROJECT_ID }}'
          flags: '--allow-unauthenticated --platform=managed' # Allow unauthenticated access for example
</code></pre>
<h4>3. Deploy to Production with Manual Approval (GCP Cloud Run)</h4>
<p>This workflow is triggered manually via the GitHub Actions UI.</p>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/deploy-prod.yml
name: Deploy to GCP Cloud Run (Production)

on:
  workflow_dispatch: # Allows manual trigger

jobs:
  deploy-production:
    runs-on: ubuntu-latest

    environment:
      name: production
      url: ${{ steps.deploy.outputs.url }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - id: 'auth'
        uses: 'google-github-actions/auth@v2'
        with:
          credentials_json: '${{ secrets.GCP_CREDENTIALS }}'

      - name: 'Deploy to Cloud Run (Production)'
        id: deploy
        uses: 'google-github-actions/deploy-cloudrun@v2'
        with:
          service: 'myapp-production' # Your production service name
          region: '${{ secrets.GCP_REGION }}'
          image: 'ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}/myapp:latest' # Use the same 'latest' image
          project_id: '${{ secrets.GCP_PROJECT_ID }}'
          flags: '--allow-unauthenticated --platform=managed'
          # For production, you can add --no-traffic and then gradually shift traffic
          # traffic:
          #   latest: true
          #   percent: 100
</code></pre>
<p><strong>Important aspects of this advanced pipeline:</strong></p>
<ul>
<li><strong>GitHub Container Registry (ghcr.io):</strong> We use it to store Docker images. It's tightly integrated with GitHub Actions.</li>
<li><strong><code>workflow_run</code>:</strong> Allows triggering one workflow (staging deployment) upon completion of another (build).</li>
<li><strong><code>workflow_dispatch</code>:</strong> Enables manual triggering of a workflow (production deployment), providing control.</li>
<li><strong>GitHub Environments:</strong> Allow configuring protection rules for production (e.g., requiring approval from specific reviewers) and storing environment-specific secrets.</li>
<li><strong>GCP Cloud Run:</strong> An excellent serverless option for running containerized applications.</li>
</ul>
<h3>üîê Security ‚Äì It's Important!</h3>
<ul>
<li><strong>Use GitHub Secrets:</strong> Never store tokens, passwords, or API keys directly in YAML files. Use <code>Settings -> Secrets and variables -> Actions</code> in your repository.</li>
<li><strong>Least Privilege:</strong> For service accounts (e.g., GCP), grant only the permissions strictly necessary for CI/CD tasks.</li>
<li><strong>Isolate Environments:</strong> Staging and Production should be as isolated as possible. Separate projects/accounts in cloud providers are a good practice.</li>
<li><strong>Branch Protection:</strong> Configure protection for the <code>main</code> (or <code>master</code>) branch to allow pushes only via Pull Requests with mandatory CI checks.</li>
</ul>