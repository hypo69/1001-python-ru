<p>🚀 <strong>CI/CD: Von den Grundlagen bis zur Produktion auf GCP mit GitHub Actions – Ein vollständiger Leitfaden mit Beispielen</strong> 🚀</p>
<p>Hallo, Entwickler! In diesem Artikel werde ich über CI/CD sprechen – ein Konzept.</p>
<h3>Was ist eine CI/CD-Pipeline im Kontext der Programmierung?</h3>
<p><strong>Eine CI/CD-Pipeline (Continuous Integration / Continuous Delivery oder Continuous Deployment)</strong> ist ein automatisierter Prozess, der es Entwicklern ermöglicht, Codeänderungen schnell und zuverlässig in eine Produktionsumgebung zu liefern.</p>
<p>Lassen Sie uns die Schlüsselkonzepte aufschlüsseln:</p>
<p>🔧 <strong>CI — Continuous Integration (Kontinuierliche Integration)</strong><br>
Dies ist eine Praxis, bei der Entwickler häufig Änderungen in eine gemeinsame Codebasis integrieren. Jede solche Änderung wird automatisch:
*   <strong>Gebaut</strong> (build)
*   <strong>Getestet</strong> (Unit-Tests, Integrationstests)
*   <strong>Auf Einhaltung von Standards überprüft</strong> (Linting, statische Analyse)
</p>
<p>👉 **Ziel von CI:** Fehler so früh wie möglich zu identifizieren, bevor sie etwas Wichtiges kaputt machen oder in ein Release gelangen.</p>
<p>🚀 **CD — Continuous Delivery (Kontinuierliche Bereitstellung) oder Continuous Deployment (Kontinuierliche Auslieferung)**<br>
Hier gibt es zwei Optionen:
</p>
<p>✅ **Continuous Delivery (Kontinuierliche Bereitstellung)**<br>
Nach erfolgreichem Abschluss der CI-Phase werden Änderungen automatisch:
*   Zusätzlichen Tests unterzogen (z. B. E2E – End-to-End-Tests)
*   Auf einem Staging-Server (Testserver) bereitgestellt
</p>
<p>👉 **Aber die Bereitstellung in die Produktion erfordert immer noch eine manuelle Bestätigung.** Dies gibt dem Team die Kontrolle darüber, *wann* genau die Benutzer die Änderungen sehen.</p>
<p>🤖 **Continuous Deployment (Kontinuierliche Auslieferung)**<br>
Dies ist der nächste Schritt nach Continuous Delivery. Hier erfolgt die Bereitstellung in die Produktion **vollautomatisch**, wenn alle vorherigen Phasen der Pipeline (Build, alle Tests) erfolgreich waren. Dies ist die fortschrittlichste Stufe der Automatisierung.</p>
<h3>🔄 Woraus besteht eine CI/CD-Pipeline normalerweise?</h3>
<p>Eine typische Pipeline umfasst die folgenden Phasen:</p>
<ol>
<li><strong>Checkout</strong> — Klonen der neuesten Codeversion aus dem Repository.</li>
<li><strong>Build</strong> — Erstellen des Projekts (Kompilierung, Erstellung von Artefakten, Docker-Images).</li>
<li><strong>Test</strong> — Ausführen verschiedener Arten von Tests (Unit-, Integrations-, E2E).</li>
<li><strong>Lint/Code Quality</strong> — Überprüfung des Codes auf Stilkonformität und potenzielle Fehler mithilfe statischer Analysetools.</li>
<li><strong>Deploy</strong> — Bereitstellen der Anwendung (auf einem Staging- oder Produktionsserver).</li>
<li><strong>Notify</strong> — Senden von Benachrichtigungen über den Pipeline-Status an das Team (z. B. in Slack, E-Mail).</li>
</ol>
<h3>🛠 Beliebte Tools für CI/CD:</h3>
<ul>
<li><strong>GitHub Actions</strong> (unser heutiger Fokus!)</li>
<li>GitLab CI/CD</li>
<li>Jenkins</li>
<li>CircleCI</li>
<li>Bitbucket Pipelines</li>
<li>Azure DevOps</li>
<li>TeamCity</li>
</ul>
<h3>🧠 Warum brauchen wir CI/CD überhaupt?</h3>
<ul>
<li><strong>Reduziert menschliche Fehler:</strong> Automatisierung eliminiert Fehler, die mit manuellen Operationen verbunden sind.</li>
<li><strong>Schnelle Fehlererkennung:</strong> Fehler werden früher gefunden, was ihre Behebung einfacher und kostengünstiger macht.</li>
<li><strong>Automatisierung von Routineaufgaben:</strong> Entwickler verbringen weniger Zeit mit dem Bauen und Bereitstellen und mehr Zeit mit dem Codieren.</li>
<li><strong>Verbesserung der Codequalität:</strong> Kontinuierliche Überprüfungen und Tests erhöhen den allgemeinen Qualitätsstandard.</li>
<li><strong>Schnelle Bereitstellung von Funktionen für Benutzer:</strong> Neue Funktionen erreichen den Endbenutzer schneller und häufiger.</li>
</ul>
<h3>📦 Einfache CI/CD-Beispiele mit GitHub Actions</h3>
<p>Schauen wir uns grundlegende Pipelines für beliebte Technologien an. Alle Beispiele verwenden GitHub Actions und werden im Verzeichnis <code>.github/workflows/</code> Ihres Projekts gespeichert.</p>
<h4>🐍 CI/CD für Python (mit <code>pytest</code> und <code>flake8</code>)</h4>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/python-ci.yml
name: Python CI

on: [push, pull_request]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11' # Geben Sie Ihre Version an

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt # Stellen Sie sicher, dass Sie requirements.txt haben
          pip install flake8 pytest

      - name: Lint with flake8
        run: |
          # Überprüfen Sie den Code in den Ordnern src und tests (passen Sie ihn an Ihr Projekt an)
          flake8 src tests

      - name: Run tests
        run: |
          pytest
</code></pre>
<h4>🌐 CI/CD für Node.js (mit <code>npm test</code> und <code>eslint</code>)</h4>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/node-ci.yml
name: Node.js CI

on: [push, pull_request]

jobs:
  build:
    runs-on: ubuntu-latest

    strategy:
      matrix:
        node-version: [18.x] # Geben Sie Ihre Node.js-Version an

    steps:
      - uses: actions/checkout@v3

      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}

      - name: Install dependencies
        run: npm install # oder npm ci für eine vorhersehbarere Installation

      - name: Lint with ESLint
        run: npx eslint . # Stellen Sie sicher, dass ESLint im Projekt konfiguriert ist

      - name: Run tests
        run: npm test
</code></pre>
<h4>🐳 CI/CD für Docker (Build und Push zu Docker Hub)</h4>
<p>Für dieses Beispiel benötigen Sie die Geheimnisse <code>DOCKER_USERNAME</code> und <code>DOCKER_PASSWORD</code> (oder ein Token) in den Einstellungen Ihres GitHub-Repositorys (<code>Settings -> Secrets and variables -> Actions</code>).</p>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/docker-ci.yml
name: Docker CI/CD

on:
  push:
    branches: [ main ] # Nur für den main-Branch ausführen

jobs:
  docker:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Log in to Docker Hub
        run: echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin

      - name: Build Docker image
        # Ersetzen Sie myapp durch den Namen Ihrer Anwendung
        run: docker build -t ${{ secrets.DOCKER_USERNAME }}/myapp:latest .

      - name: Push Docker image
        run: docker push ${{ secrets.DOCKER_USERNAME }}/myapp:latest
</code></pre>
<h3>🚚 Bereitstellung auf beliebten Plattformen</h3>
<p>Nachdem wir nun gebaute und getestete Artefakte (z. B. ein Docker-Image) haben, schauen wir uns an, wie sie bereitgestellt werden können.</p>
<h4>🟣 Bereitstellung auf Heroku</h4>
<p><strong>🔐 GitHub-Geheimnisse:</strong> <code>HEROKU_API_KEY</code>, <code>HEROKU_APP_NAME</code>.</p>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/deploy-heroku.yml
name: Deploy to Heroku

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Install Heroku CLI
        run: curl https://cli-assets.heroku.com/install.sh | sh
      - name: Login to Heroku
        env:
          HEROKU_API_KEY: ${{ secrets.HEROKU_API_KEY }}
        run: heroku auth:token
      - name: Deploy to Heroku
        env:
          HEROKU_API_KEY: ${{ secrets.HEROKU_API_KEY }}
        run: |
          heroku git:remote -a ${{ secrets.HEROKU_APP_NAME }}
          git push heroku main -f # Seien Sie vorsichtig mit -f (force push)
</code></pre>
<p>Wenn Sie ein Docker-Image auf Heroku bereitstellen:</p>
<pre class="line-numbers"><code class="language-yaml"># ... (Build- und Login-Schritte für Docker Hub/GHCR aus früheren Beispielen) ...
# deploy:
#   name: Deploy to Heroku
#   needs: build # Abhängig vom Build-Job des Images
#   runs-on: ubuntu-latest
#   steps:
#     # ...
#     - name: Login to Heroku container registry
#       run: echo "${{ secrets.HEROKU_API_KEY }}" | docker login --username=_ --password-stdin registry.heroku.com
#     - name: Tag image for Heroku
#       # Angenommen, das Image wird als ghcr.io/username/repo/myapp:latest gebaut
#       run: docker tag ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}/myapp:latest registry.heroku.com/${{ secrets.HEROKU_APP_NAME }}/web
#     - name: Push image to Heroku
#       run: docker push registry.heroku.com/${{ secrets.HEROKU_APP_NAME }}/web
#     - name: Release Heroku App
#       env:
#         HEROKU_API_KEY: ${{ secrets.HEROKU_API_KEY }}
#       run: heroku container:release web --app ${{ secrets.HEROKU_APP_NAME }}
</code></pre>
<h3>🟨 Bereitstellung auf AWS (z. B. statische Dateien in S3)</h3>
<p><strong>🔐 GitHub-Geheimnisse:</strong> <code>AWS_ACCESS_KEY_ID</code>, <code>AWS_SECRET_ACCESS_KEY</code>, <code>AWS_REGION</code>, <code>S3_BUCKET_NAME</code>.</p>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/deploy-aws-s3.yml
name: Deploy Static Site to AWS S3

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
      - name: Sync files to S3
        # Ersetzen Sie ./public durch den Pfad zu Ihren statischen Dateien
        run: aws s3 sync ./public s3://${{ secrets.S3_BUCKET_NAME }} --delete
</code></pre>
<p>Für die Bereitstellung auf **AWS Elastic Beanstalk** wird normalerweise die EB CLI verwendet, die Pipeline ist ähnlich, aber mit <code>eb deploy</code>-Befehlen.</p>
<h3>🔵 Bereitstellung auf Google Cloud Platform (GCP App Engine)</h3>
<p><strong>🔐 GitHub-Geheimnisse:</strong> <code>GCP_CREDENTIALS</code> (JSON-Schlüssel des Dienstkontos), <code>GCP_PROJECT_ID</code>.</p>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/deploy-gcp-app-engine.yml
name: Deploy to GCP App Engine

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ secrets.GCP_PROJECT_ID }}
          service_account_key: ${{ secrets.GCP_CREDENTIALS }}
          export_default_credentials: true
      - name: Deploy to App Engine
        # Stellen Sie sicher, dass Sie app.yaml im Stammverzeichnis des Projekts haben
        run: gcloud app deploy --quiet
</code></pre>
<h3>🟪 Bereitstellung auf Render.com</h3>
<p>Render stellt oft automatisch bei einem Push zu GitHub bereit, wenn das Repository verbunden ist. Aber für einen manuellen Trigger (oder als Teil einer komplexeren Pipeline) kann ein Deploy Hook verwendet werden.<br>
<strong>🔐 GitHub-Geheimnisse:</strong> <code>RENDER_DEPLOY_HOOK</code> (URL, die aus den Render-Diensteinstellungen abgerufen wird).</p>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/deploy-render.yml
name: Trigger Render Deploy

on:
  workflow_dispatch: # Manueller Start über die GitHub-UI

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Trigger Render Deploy Hook
        run: curl -X POST ${{ secrets.RENDER_DEPLOY_HOOK }}
</code></pre>
<h3>🌟 Fortgeschrittenes CI/CD: Docker bauen → Push zu GHCR → Staging/Production auf GCP Cloud Run</h3>
<p>Und jetzt das Sahnehäubchen! Lassen Sie uns eine fortgeschrittene Pipeline zusammenstellen:</p>
<ol>
<li>Build des Docker-Images.</li>
<li>Veröffentlichung des Images im GitHub Container Registry (ghcr.io).</li>
<li>Automatische Bereitstellung in die **Staging**-Umgebung auf GCP Cloud Run.</li>
<li>Bereitstellung in die **Produktions**-Umgebung auf GCP Cloud Run **nach manueller Bestätigung**.
</li>
</ol>
<p>Dafür benötigen wir mehrere Workflow-Dateien.</p>
<p><strong>Erforderliche GitHub-Geheimnisse:</strong></p>
<ul>
<li><code>GCP_PROJECT_ID</code>: ID Ihres GCP-Projekts.</li>
<li><code>GCP_CREDENTIALS</code>: JSON-Schlüssel des GCP-Dienstkontos mit Berechtigungen zur Bereitstellung in Cloud Run und Zugriff auf GHCR (falls erforderlich). Normalerweise reicht <code>GITHUB_TOKEN</code> für den Zugriff auf GHCR von Actions aus.</li>
<li><code>GCP_REGION</code>: Region für Cloud Run (z. B. <code>europe-west1</code>).</li>
</ul>
<h3>1. Build und Veröffentlichung des Docker-Images in GHCR</h3>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/build.yml
name: Build & Push to GHCR

on:
  push:
    branches: [main] # Bei Push zu main ausführen

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read      # Für Checkout
      packages: write     # Für Push zu GHCR

    steps:
      - uses: actions/checkout@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}/myapp:latest
          # Sie können eine Tagging nach Commit-SHA für Einzigartigkeit hinzufügen:
          # tags: |
          #   ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}/myapp:latest
          #   ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}/myapp:${{ github.sha }}
</code></pre>
<ul>
<li><code>github.repository_owner</code>: Besitzer des Repositorys (Ihr Benutzername oder Ihre Organisation).</li>
<li><code>github.event.repository.name</code>: Name des Repositorys.</li>
<li><code>myapp</code>: Name Ihrer Anwendung/Ihres Images.</li>
</ul>
<h3>2. Automatische Bereitstellung in Staging (GCP Cloud Run)</h3>
<p>Dieser Workflow wird automatisch nach erfolgreichem Abschluss von <code>build.yml</code> ausgeführt.</p>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/deploy-staging.yml
name: Deploy to GCP Cloud Run (Staging)

on:
  workflow_run:
    workflows: ["Build & Push to GHCR"]
    types:
      - completed

jobs:
  deploy-staging:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' }}

    environment:
      name: staging
      url: ${{ steps.deploy.outputs.url }}

    steps:
      - uses: actions/checkout@v3

      - id: 'auth'
        uses: 'google-github-actions/auth@v2'
        with:
          credentials_json: '${{ secrets.GCP_CREDENTIALS }}'

      - name: 'Deploy to Cloud Run (Staging)'
        id: deploy
        uses: 'google-github-actions/deploy-cloudrun@v2'
        with:
          service: 'myapp-staging'
          region: '${{ secrets.GCP_REGION }}'
          image: 'ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}/myapp:latest'
          project_id: '${{ secrets.GCP_PROJECT_ID }}'
          flags: '--allow-unauthenticated --platform=managed'
</code></pre>
<h3>3. Bereitstellung in Produktion mit manueller Bestätigung (GCP Cloud Run)</h3>
<p>Dieser Workflow wird manuell über die GitHub Actions-Benutzeroberfläche ausgelöst.</p>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/deploy-prod.yml
name: Deploy to GCP Cloud Run (Production)

on:
  workflow_dispatch: # Ermöglicht manuellen Start

jobs:
  deploy-production:
    runs-on: ubuntu-latest

    environment:
      name: production
      url: ${{ steps.deploy.outputs.url }}

    steps:
      - uses: actions/checkout@v3

      - id: 'auth'
        uses: 'google-github-actions/auth@v2'
        with:
          credentials_json: '${{ secrets.GCP_CREDENTIALS }}'

      - name: 'Deploy to Cloud Run (Production)'
        id: deploy
        uses: 'google-github-actions/deploy-cloudrun@v2'
        with:
          service: 'myapp-production'
          region: '${{ secrets.GCP_REGION }}'
          image: 'ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}/myapp:latest'
          project_id: '${{ secrets.GCP_PROJECT_ID }}'
          flags: '--allow-unauthenticated --platform=managed'
          # Für die Produktion können Sie --no-traffic hinzufügen und dann den Traffic schrittweise umschalten
          # traffic:
          #   latest: true
          #   percent: 100
</code></pre>
<h3>Wichtige Punkte dieser fortgeschrittenen Pipeline:</h3>
<ul>
<li><strong>GitHub Container Registry (ghcr.io):</strong> Wir verwenden es zum Speichern von Docker-Images. Dies ist praktisch, da es eng in GitHub Actions integriert ist.</li>
<li><strong><code>workflow_run</code>:</strong> Ermöglicht das Ausführen eines Workflows (Staging-Bereitstellung) nach Abschluss eines anderen (Build).</li>
<li><strong><code>workflow_dispatch</code>:</strong> Bietet die Möglichkeit, einen Workflow (Produktionsbereitstellung) manuell auszulösen, was die Kontrolle gewährleistet.</li>
<li><strong>GitHub Environments:</strong> Ermöglichen es Ihnen, Schutzregeln für die Produktion zu konfigurieren (z. B. die Genehmigung durch bestimmte Prüfer zu verlangen) und umgebungsspezifische Geheimnisse zu speichern.</li>
<li><strong>GCP Cloud Run:</strong> Eine ausgezeichnete Serverless-Option zum Ausführen von containerisierten Anwendungen.</li>
</ul>
<h3>🔐 Sicherheit – das ist wichtig!</h3>
<ul>
<li><strong>Verwenden Sie GitHub Secrets:</strong> Speichern Sie niemals Token, Passwörter, API-Schlüssel direkt in YAML-Dateien. Verwenden Sie <code>Settings -> Secrets and variables -> Actions</code> in Ihrem Repository.</li>
<li><strong>Minimale Berechtigungen:</strong> Gewähren Sie Dienstkonten (z. B. GCP) nur die Berechtigungen, die für die Ausführung von CI/CD-Aufgaben unbedingt erforderlich sind.</li>
<li><strong>Umgebungen isolieren:</strong> Staging und Produktion sollten so weit wie möglich isoliert sein. Unterschiedliche Projekte/Konten bei Cloud-Anbietern sind eine gute Praxis.</li>
<li><strong>Branch-Schutz:</strong> Konfigurieren Sie den Schutz für den <code>main</code>- (oder <code>master</code>)-Branch, sodass Pushs nur über Pull Requests mit obligatorischen CI-Prüfungen möglich sind.</li>
</ul>