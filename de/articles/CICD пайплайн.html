<p>üöÄ <strong>CI/CD: Von den Grundlagen bis zur Produktion auf GCP mit GitHub Actions ‚Äì Ein vollst√§ndiger Leitfaden mit Beispielen</strong> üöÄ</p>
<p>Hallo, Entwickler! In diesem Artikel werde ich √ºber CI/CD sprechen ‚Äì ein Konzept.</p>
<h3>Was ist eine CI/CD-Pipeline im Kontext der Programmierung?</h3>
<p><strong>Eine CI/CD-Pipeline (Continuous Integration / Continuous Delivery oder Continuous Deployment)</strong> ist ein automatisierter Prozess, der es Entwicklern erm√∂glicht, Code√§nderungen schnell und zuverl√§ssig in eine Produktionsumgebung zu liefern.</p>
<p>Lassen Sie uns die Schl√ºsselkonzepte aufschl√ºsseln:</p>
<p>üîß <strong>CI ‚Äî Continuous Integration (Kontinuierliche Integration)</strong><br>
Dies ist eine Praxis, bei der Entwickler h√§ufig √Ñnderungen in eine gemeinsame Codebasis integrieren. Jede solche √Ñnderung wird automatisch:
*   <strong>Gebaut</strong> (build)
*   <strong>Getestet</strong> (Unit-Tests, Integrationstests)
*   <strong>Auf Einhaltung von Standards √ºberpr√ºft</strong> (Linting, statische Analyse)
</p>
<p>üëâ **Ziel von CI:** Fehler so fr√ºh wie m√∂glich zu identifizieren, bevor sie etwas Wichtiges kaputt machen oder in ein Release gelangen.</p>
<p>üöÄ **CD ‚Äî Continuous Delivery (Kontinuierliche Bereitstellung) oder Continuous Deployment (Kontinuierliche Auslieferung)**<br>
Hier gibt es zwei Optionen:
</p>
<p>‚úÖ **Continuous Delivery (Kontinuierliche Bereitstellung)**<br>
Nach erfolgreichem Abschluss der CI-Phase werden √Ñnderungen automatisch:
*   Zus√§tzlichen Tests unterzogen (z. B. E2E ‚Äì End-to-End-Tests)
*   Auf einem Staging-Server (Testserver) bereitgestellt
</p>
<p>üëâ **Aber die Bereitstellung in die Produktion erfordert immer noch eine manuelle Best√§tigung.** Dies gibt dem Team die Kontrolle dar√ºber, *wann* genau die Benutzer die √Ñnderungen sehen.</p>
<p>ü§ñ **Continuous Deployment (Kontinuierliche Auslieferung)**<br>
Dies ist der n√§chste Schritt nach Continuous Delivery. Hier erfolgt die Bereitstellung in die Produktion **vollautomatisch**, wenn alle vorherigen Phasen der Pipeline (Build, alle Tests) erfolgreich waren. Dies ist die fortschrittlichste Stufe der Automatisierung.</p>
<h3>üîÑ Woraus besteht eine CI/CD-Pipeline normalerweise?</h3>
<p>Eine typische Pipeline umfasst die folgenden Phasen:</p>
<ol>
<li><strong>Checkout</strong> ‚Äî Klonen der neuesten Codeversion aus dem Repository.</li>
<li><strong>Build</strong> ‚Äî Erstellen des Projekts (Kompilierung, Erstellung von Artefakten, Docker-Images).</li>
<li><strong>Test</strong> ‚Äî Ausf√ºhren verschiedener Arten von Tests (Unit-, Integrations-, E2E).</li>
<li><strong>Lint/Code Quality</strong> ‚Äî √úberpr√ºfung des Codes auf Stilkonformit√§t und potenzielle Fehler mithilfe statischer Analysetools.</li>
<li><strong>Deploy</strong> ‚Äî Bereitstellen der Anwendung (auf einem Staging- oder Produktionsserver).</li>
<li><strong>Notify</strong> ‚Äî Senden von Benachrichtigungen √ºber den Pipeline-Status an das Team (z. B. in Slack, E-Mail).</li>
</ol>
<h3>üõ† Beliebte Tools f√ºr CI/CD:</h3>
<ul>
<li><strong>GitHub Actions</strong> (unser heutiger Fokus!)</li>
<li>GitLab CI/CD</li>
<li>Jenkins</li>
<li>CircleCI</li>
<li>Bitbucket Pipelines</li>
<li>Azure DevOps</li>
<li>TeamCity</li>
</ul>
<h3>üß† Warum brauchen wir CI/CD √ºberhaupt?</h3>
<ul>
<li><strong>Reduziert menschliche Fehler:</strong> Automatisierung eliminiert Fehler, die mit manuellen Operationen verbunden sind.</li>
<li><strong>Schnelle Fehlererkennung:</strong> Fehler werden fr√ºher gefunden, was ihre Behebung einfacher und kosteng√ºnstiger macht.</li>
<li><strong>Automatisierung von Routineaufgaben:</strong> Entwickler verbringen weniger Zeit mit dem Bauen und Bereitstellen und mehr Zeit mit dem Codieren.</li>
<li><strong>Verbesserung der Codequalit√§t:</strong> Kontinuierliche √úberpr√ºfungen und Tests erh√∂hen den allgemeinen Qualit√§tsstandard.</li>
<li><strong>Schnelle Bereitstellung von Funktionen f√ºr Benutzer:</strong> Neue Funktionen erreichen den Endbenutzer schneller und h√§ufiger.</li>
</ul>
<h3>üì¶ Einfache CI/CD-Beispiele mit GitHub Actions</h3>
<p>Schauen wir uns grundlegende Pipelines f√ºr beliebte Technologien an. Alle Beispiele verwenden GitHub Actions und werden im Verzeichnis <code>.github/workflows/</code> Ihres Projekts gespeichert.</p>
<h4>üêç CI/CD f√ºr Python (mit <code>pytest</code> und <code>flake8</code>)</h4>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/python-ci.yml
name: Python CI

on: [push, pull_request]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11' # Geben Sie Ihre Version an

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt # Stellen Sie sicher, dass Sie requirements.txt haben
          pip install flake8 pytest

      - name: Lint with flake8
        run: |
          # √úberpr√ºfen Sie den Code in den Ordnern src und tests (passen Sie ihn an Ihr Projekt an)
          flake8 src tests

      - name: Run tests
        run: |
          pytest
</code></pre>
<h4>üåê CI/CD f√ºr Node.js (mit <code>npm test</code> und <code>eslint</code>)</h4>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/node-ci.yml
name: Node.js CI

on: [push, pull_request]

jobs:
  build:
    runs-on: ubuntu-latest

    strategy:
      matrix:
        node-version: [18.x] # Geben Sie Ihre Node.js-Version an

    steps:
      - uses: actions/checkout@v3

      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}

      - name: Install dependencies
        run: npm install # oder npm ci f√ºr eine vorhersehbarere Installation

      - name: Lint with ESLint
        run: npx eslint . # Stellen Sie sicher, dass ESLint im Projekt konfiguriert ist

      - name: Run tests
        run: npm test
</code></pre>
<h4>üê≥ CI/CD f√ºr Docker (Build und Push zu Docker Hub)</h4>
<p>F√ºr dieses Beispiel ben√∂tigen Sie die Geheimnisse <code>DOCKER_USERNAME</code> und <code>DOCKER_PASSWORD</code> (oder ein Token) in den Einstellungen Ihres GitHub-Repositorys (<code>Settings -> Secrets and variables -> Actions</code>).</p>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/docker-ci.yml
name: Docker CI/CD

on:
  push:
    branches: [ main ] # Nur f√ºr den main-Branch ausf√ºhren

jobs:
  docker:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Log in to Docker Hub
        run: echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin

      - name: Build Docker image
        # Ersetzen Sie myapp durch den Namen Ihrer Anwendung
        run: docker build -t ${{ secrets.DOCKER_USERNAME }}/myapp:latest .

      - name: Push Docker image
        run: docker push ${{ secrets.DOCKER_USERNAME }}/myapp:latest
</code></pre>
<h3>üöö Bereitstellung auf beliebten Plattformen</h3>
<p>Nachdem wir nun gebaute und getestete Artefakte (z. B. ein Docker-Image) haben, schauen wir uns an, wie sie bereitgestellt werden k√∂nnen.</p>
<h4>üü£ Bereitstellung auf Heroku</h4>
<p><strong>üîê GitHub-Geheimnisse:</strong> <code>HEROKU_API_KEY</code>, <code>HEROKU_APP_NAME</code>.</p>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/deploy-heroku.yml
name: Deploy to Heroku

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Install Heroku CLI
        run: curl https://cli-assets.heroku.com/install.sh | sh
      - name: Login to Heroku
        env:
          HEROKU_API_KEY: ${{ secrets.HEROKU_API_KEY }}
        run: heroku auth:token
      - name: Deploy to Heroku
        env:
          HEROKU_API_KEY: ${{ secrets.HEROKU_API_KEY }}
        run: |
          heroku git:remote -a ${{ secrets.HEROKU_APP_NAME }}
          git push heroku main -f # Seien Sie vorsichtig mit -f (force push)
</code></pre>
<p>Wenn Sie ein Docker-Image auf Heroku bereitstellen:</p>
<pre class="line-numbers"><code class="language-yaml"># ... (Build- und Login-Schritte f√ºr Docker Hub/GHCR aus fr√ºheren Beispielen) ...
# deploy:
#   name: Deploy to Heroku
#   needs: build # Abh√§ngig vom Build-Job des Images
#   runs-on: ubuntu-latest
#   steps:
#     # ...
#     - name: Login to Heroku container registry
#       run: echo "${{ secrets.HEROKU_API_KEY }}" | docker login --username=_ --password-stdin registry.heroku.com
#     - name: Tag image for Heroku
#       # Angenommen, das Image wird als ghcr.io/username/repo/myapp:latest gebaut
#       run: docker tag ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}/myapp:latest registry.heroku.com/${{ secrets.HEROKU_APP_NAME }}/web
#     - name: Push image to Heroku
#       run: docker push registry.heroku.com/${{ secrets.HEROKU_APP_NAME }}/web
#     - name: Release Heroku App
#       env:
#         HEROKU_API_KEY: ${{ secrets.HEROKU_API_KEY }}
#       run: heroku container:release web --app ${{ secrets.HEROKU_APP_NAME }}
</code></pre>
<h3>üü® Bereitstellung auf AWS (z. B. statische Dateien in S3)</h3>
<p><strong>üîê GitHub-Geheimnisse:</strong> <code>AWS_ACCESS_KEY_ID</code>, <code>AWS_SECRET_ACCESS_KEY</code>, <code>AWS_REGION</code>, <code>S3_BUCKET_NAME</code>.</p>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/deploy-aws-s3.yml
name: Deploy Static Site to AWS S3

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
      - name: Sync files to S3
        # Ersetzen Sie ./public durch den Pfad zu Ihren statischen Dateien
        run: aws s3 sync ./public s3://${{ secrets.S3_BUCKET_NAME }} --delete
</code></pre>
<p>F√ºr die Bereitstellung auf **AWS Elastic Beanstalk** wird normalerweise die EB CLI verwendet, die Pipeline ist √§hnlich, aber mit <code>eb deploy</code>-Befehlen.</p>
<h3>üîµ Bereitstellung auf Google Cloud Platform (GCP App Engine)</h3>
<p><strong>üîê GitHub-Geheimnisse:</strong> <code>GCP_CREDENTIALS</code> (JSON-Schl√ºssel des Dienstkontos), <code>GCP_PROJECT_ID</code>.</p>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/deploy-gcp-app-engine.yml
name: Deploy to GCP App Engine

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ secrets.GCP_PROJECT_ID }}
          service_account_key: ${{ secrets.GCP_CREDENTIALS }}
          export_default_credentials: true
      - name: Deploy to App Engine
        # Stellen Sie sicher, dass Sie app.yaml im Stammverzeichnis des Projekts haben
        run: gcloud app deploy --quiet
</code></pre>
<h3>üü™ Bereitstellung auf Render.com</h3>
<p>Render stellt oft automatisch bei einem Push zu GitHub bereit, wenn das Repository verbunden ist. Aber f√ºr einen manuellen Trigger (oder als Teil einer komplexeren Pipeline) kann ein Deploy Hook verwendet werden.<br>
<strong>üîê GitHub-Geheimnisse:</strong> <code>RENDER_DEPLOY_HOOK</code> (URL, die aus den Render-Diensteinstellungen abgerufen wird).</p>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/deploy-render.yml
name: Trigger Render Deploy

on:
  workflow_dispatch: # Manueller Start √ºber die GitHub-UI

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Trigger Render Deploy Hook
        run: curl -X POST ${{ secrets.RENDER_DEPLOY_HOOK }}
</code></pre>
<h3>üåü Fortgeschrittenes CI/CD: Docker bauen ‚Üí Push zu GHCR ‚Üí Staging/Production auf GCP Cloud Run</h3>
<p>Und jetzt das Sahneh√§ubchen! Lassen Sie uns eine fortgeschrittene Pipeline zusammenstellen:</p>
<ol>
<li>Build des Docker-Images.</li>
<li>Ver√∂ffentlichung des Images im GitHub Container Registry (ghcr.io).</li>
<li>Automatische Bereitstellung in die **Staging**-Umgebung auf GCP Cloud Run.</li>
<li>Bereitstellung in die **Produktions**-Umgebung auf GCP Cloud Run **nach manueller Best√§tigung**.
</li>
</ol>
<p>Daf√ºr ben√∂tigen wir mehrere Workflow-Dateien.</p>
<p><strong>Erforderliche GitHub-Geheimnisse:</strong></p>
<ul>
<li><code>GCP_PROJECT_ID</code>: ID Ihres GCP-Projekts.</li>
<li><code>GCP_CREDENTIALS</code>: JSON-Schl√ºssel des GCP-Dienstkontos mit Berechtigungen zur Bereitstellung in Cloud Run und Zugriff auf GHCR (falls erforderlich). Normalerweise reicht <code>GITHUB_TOKEN</code> f√ºr den Zugriff auf GHCR von Actions aus.</li>
<li><code>GCP_REGION</code>: Region f√ºr Cloud Run (z. B. <code>europe-west1</code>).</li>
</ul>
<h3>1. Build und Ver√∂ffentlichung des Docker-Images in GHCR</h3>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/build.yml
name: Build & Push to GHCR

on:
  push:
    branches: [main] # Bei Push zu main ausf√ºhren

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read      # F√ºr Checkout
      packages: write     # F√ºr Push zu GHCR

    steps:
      - uses: actions/checkout@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}/myapp:latest
          # Sie k√∂nnen eine Tagging nach Commit-SHA f√ºr Einzigartigkeit hinzuf√ºgen:
          # tags: |
          #   ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}/myapp:latest
          #   ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}/myapp:${{ github.sha }}
</code></pre>
<ul>
<li><code>github.repository_owner</code>: Besitzer des Repositorys (Ihr Benutzername oder Ihre Organisation).</li>
<li><code>github.event.repository.name</code>: Name des Repositorys.</li>
<li><code>myapp</code>: Name Ihrer Anwendung/Ihres Images.</li>
</ul>
<h3>2. Automatische Bereitstellung in Staging (GCP Cloud Run)</h3>
<p>Dieser Workflow wird automatisch nach erfolgreichem Abschluss von <code>build.yml</code> ausgef√ºhrt.</p>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/deploy-staging.yml
name: Deploy to GCP Cloud Run (Staging)

on:
  workflow_run:
    workflows: ["Build & Push to GHCR"]
    types:
      - completed

jobs:
  deploy-staging:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' }}

    environment:
      name: staging
      url: ${{ steps.deploy.outputs.url }}

    steps:
      - uses: actions/checkout@v3

      - id: 'auth'
        uses: 'google-github-actions/auth@v2'
        with:
          credentials_json: '${{ secrets.GCP_CREDENTIALS }}'

      - name: 'Deploy to Cloud Run (Staging)'
        id: deploy
        uses: 'google-github-actions/deploy-cloudrun@v2'
        with:
          service: 'myapp-staging'
          region: '${{ secrets.GCP_REGION }}'
          image: 'ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}/myapp:latest'
          project_id: '${{ secrets.GCP_PROJECT_ID }}'
          flags: '--allow-unauthenticated --platform=managed'
</code></pre>
<h3>3. Bereitstellung in Produktion mit manueller Best√§tigung (GCP Cloud Run)</h3>
<p>Dieser Workflow wird manuell √ºber die GitHub Actions-Benutzeroberfl√§che ausgel√∂st.</p>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/deploy-prod.yml
name: Deploy to GCP Cloud Run (Production)

on:
  workflow_dispatch: # Erm√∂glicht manuellen Start

jobs:
  deploy-production:
    runs-on: ubuntu-latest

    environment:
      name: production
      url: ${{ steps.deploy.outputs.url }}

    steps:
      - uses: actions/checkout@v3

      - id: 'auth'
        uses: 'google-github-actions/auth@v2'
        with:
          credentials_json: '${{ secrets.GCP_CREDENTIALS }}'

      - name: 'Deploy to Cloud Run (Production)'
        id: deploy
        uses: 'google-github-actions/deploy-cloudrun@v2'
        with:
          service: 'myapp-production'
          region: '${{ secrets.GCP_REGION }}'
          image: 'ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}/myapp:latest'
          project_id: '${{ secrets.GCP_PROJECT_ID }}'
          flags: '--allow-unauthenticated --platform=managed'
          # F√ºr die Produktion k√∂nnen Sie --no-traffic hinzuf√ºgen und dann den Traffic schrittweise umschalten
          # traffic:
          #   latest: true
          #   percent: 100
</code></pre>
<h3>Wichtige Punkte dieser fortgeschrittenen Pipeline:</h3>
<ul>
<li><strong>GitHub Container Registry (ghcr.io):</strong> Wir verwenden es zum Speichern von Docker-Images. Dies ist praktisch, da es eng in GitHub Actions integriert ist.</li>
<li><strong><code>workflow_run</code>:</strong> Erm√∂glicht das Ausf√ºhren eines Workflows (Staging-Bereitstellung) nach Abschluss eines anderen (Build).</li>
<li><strong><code>workflow_dispatch</code>:</strong> Bietet die M√∂glichkeit, einen Workflow (Produktionsbereitstellung) manuell auszul√∂sen, was die Kontrolle gew√§hrleistet.</li>
<li><strong>GitHub Environments:</strong> Erm√∂glichen es Ihnen, Schutzregeln f√ºr die Produktion zu konfigurieren (z. B. die Genehmigung durch bestimmte Pr√ºfer zu verlangen) und umgebungsspezifische Geheimnisse zu speichern.</li>
<li><strong>GCP Cloud Run:</strong> Eine ausgezeichnete Serverless-Option zum Ausf√ºhren von containerisierten Anwendungen.</li>
</ul>
<h3>üîê Sicherheit ‚Äì das ist wichtig!</h3>
<ul>
<li><strong>Verwenden Sie GitHub Secrets:</strong> Speichern Sie niemals Token, Passw√∂rter, API-Schl√ºssel direkt in YAML-Dateien. Verwenden Sie <code>Settings -> Secrets and variables -> Actions</code> in Ihrem Repository.</li>
<li><strong>Minimale Berechtigungen:</strong> Gew√§hren Sie Dienstkonten (z. B. GCP) nur die Berechtigungen, die f√ºr die Ausf√ºhrung von CI/CD-Aufgaben unbedingt erforderlich sind.</li>
<li><strong>Umgebungen isolieren:</strong> Staging und Produktion sollten so weit wie m√∂glich isoliert sein. Unterschiedliche Projekte/Konten bei Cloud-Anbietern sind eine gute Praxis.</li>
<li><strong>Branch-Schutz:</strong> Konfigurieren Sie den Schutz f√ºr den <code>main</code>- (oder <code>master</code>)-Branch, sodass Pushs nur √ºber Pull Requests mit obligatorischen CI-Pr√ºfungen m√∂glich sind.</li>
</ul>