### Shadow DOM - «DOM всередині DOM»

DOM — це програмний інтерфейс (API) для коду сторінки, який представляє сторінку як деревоподібну структуру об'єктів.

Кожен HTML-елемент (наприклад, `<p>`, `<div>`, `<img>`), кожен атрибут і кожен фрагмент тексту є окремим «вузлом»
(node) у цьому дереві. За допомогою JavaScript ми можемо звертатися до цих вузлів, щоб динамічно змінювати сторінку: змінювати текст, додавати стилі, створювати нові елементи або видаляти існуючі. По суті, DOM — це «жива» модель документа, з якою взаємодіє код.

Але ця відкритість має і зворотний бік. Коли ми створюємо складний, багаторазово використовуваний компонент (наприклад, кастомний відеоплеєр або віджет календаря), його внутрішня структура та стилі стають вразливими. Стилі CSS з основної сторінки можуть випадково «просочитися» всередину компонента та зламати його зовнішній вигляд. Аналогічно, JavaScript-код сторінки може ненавмисно змінити внутрішні елементи компонента, порушивши його логіку.

Для вирішення цієї проблеми і існує **Shadow DOM (тіньовий DOM)**.

За своєю суттю, Shadow DOM — це **«DOM всередині DOM»**. Це приховане дерево елементів, яке прикріплюється до звичайного елемента на сторінці (називається «хостом»), але при цьому воно ізольоване від основного DOM. Воно дозволяє розробнику створити герметичну межу навколо внутрішньої структури компонента, захищаючи його від зовнішнього світу.

Тіньовий DOM дозволяє прикріплювати приховані DOM-дерева до елементів у звичайному DOM-дереві. Це тіньове дерево починається з **тіньового кореня** (shadow root), під який можна прикріплювати будь-які елементи так само, як і в звичайному DOM.

Існує кілька термінів, пов'язаних з тіньовим DOM, які слід знати:
![DOM](../../assets/shadow_dom/file.png)
*   **Тіньовий хост (Shadow host):** Звичайний вузол DOM, до якого прикріплений тіньовий DOM.
*   **Тіньове дерево (Shadow tree):** DOM-дерево всередині тіньового DOM.
*   **Тіньова межа (Shadow boundary):** Місце, де закінчується тіньовий DOM і починається звичайний DOM.
*   **Тіньовий корінь (Shadow root):** Кореневий вузол тіньового дерева.

Ви можете впливати на вузли в тіньовому DOM точно так само, як і на звичайні вузли. Різниця в тому, що жоден код всередині тіньового DOM не може вплинути на щось за його межами, що забезпечує надійну інкапсуляцію.

До того, як тіньовий DOM став доступний веб-розробникам, браузери вже використовували його для інкапсуляції внутрішньої структури стандартних елементів. Наприклад, елемент `<video>` з елементами керування. Все, що ви бачите в DOM, — це тег `<video>`, але він містить низку кнопок та інших елементів керування всередині свого тіньового DOM.

#### Створення тіньового DOM

Створювати тіньовий DOM можна двома способами: імперативно за допомогою JavaScript або декларативно прямо в HTML.

##### Імперативно за допомогою JavaScript

Цей спосіб чудово підходить для програм, що рендеряться на стороні клієнта. Ми вибираємо елемент-хост і викликаємо на ньому метод `attachShadow()`.

```html
<!-- HTML-розмітка -->
<div id="host"></div>
<span>Я не в тіньовому DOM</span>
```

```javascript
// Знаходимо хост і прикріплюємо до нього тіньовий DOM
const host = document.querySelector("#host");
const shadow = host.attachShadow({ mode: "open" });

// Створюємо та додаємо елементи в тіньове дерево
const span = document.createElement("span");
span.textContent = "Я знаходжуся в тіньовому DOM";
shadow.appendChild(span);
```

Результат на сторінці буде виглядати так:
> Я знаходжуся в тіньовому DOM
> Я не в тіньовому DOM

##### Декларативно за допомогою HTML

Для програм, де важливий рендеринг на стороні сервера, можна визначити тіньовий DOM декларативно, використовуючи елемент `<template>` з атрибутом `shadowrootmode`.



```html
<div id="host">
  <template shadowrootmode="open">
    <p>Цей параграф знаходиться всередині тіньового DOM.</p>
    <style>
      p { color: red; } /* Ці стилі будуть ізольовані */
    </style>
  </template>
</div>
```

Коли браузер обробить цей код, він автоматично створить тіньовий корінь для `<div>` і помістить у нього вміст тега `<template>`. Сам тег `<template>` при цьому зникне з основного DOM-дерева.

#### Інкапсуляція: захист від JavaScript та CSS

Головна перевага Shadow DOM — це ізоляція. Давайте подивимося, як вона працює.

##### Інкапсуляція від JavaScript

Додамо кнопку, яка намагатиметься змінити всі елементи `<span>` на сторінці.

```javascript
// ... код створення тіньового DOM ...

const upper = document.querySelector("#upper-button");
upper.addEventListener("click", () => {
  // Цей селектор шукає по всьому документу
  const spans = document.querySelectorAll("span");
  for (const span of spans) {
    span.textContent = span.textContent.toUpperCase();
  }
});
```

При натисканні на кнопку текст зміниться лише у `<span>`, який знаходиться в основному документі. Елемент всередині тіньового DOM залишиться недоторканим, тому що `document.querySelectorAll()` не може "зазирнути" за тіньову межу.

##### Доступ до тіньового DOM: властивість `shadowRoot` та робота з вкладеністю

Коли ми викликаємо `host.attachShadow({ mode: "open" })`, ми створюємо тіньовий DOM у "відкритому" режимі. Це означає, що ми можемо отримати доступ до його вмісту ззовні через властивість `host.shadowRoot`.

```javascript
// Знаходимо спани лише всередині тіньового дерева конкретного хоста
const spansInShadow = host.shadowRoot.querySelectorAll("span");
```

Якщо ж вказати `mode: "closed"`, властивість `host.shadowRoot` поверне `null`, і доступ до тіньового дерева ззовні буде закрито. Це не суворий механізм безпеки, а скоріше угода для розробників про те, що внутрішні частини компонента чіпати не слід.

**Робота з вкладеними тіньовими деревами**

У складних компонентних архітектурах один користувацький елемент може містити всередині себе інші користувацькі елементи, кожен з яких має свій власний Shadow DOM. Щоб дістатися до елемента в глибоко вкладеному тіньовому дереві, доведеться послідовно "проходити" через кожен `shadowRoot`.

Уявімо собі таку структуру:
*   Компонент `<nmbrs-form>` (основна форма).
*   Всередині нього знаходиться `<div>`, а в ньому — компонент `<nmbrs-button>` (кастомна кнопка).
*   Всередині `<nmbrs-button>` знаходиться справжня HTML-кнопка `<button>`.

Щоб отримати доступ до цієї кнопки з глобального контексту, шлях буде виглядати так:

```javascript
// 1. Знаходимо кореневий компонент в основному документі
const formComponent = document.querySelector('nmbrs-form');

// 2. "Входимо" в його тіньове дерево
const shadowRoot1 = formComponent.shadowRoot;

// 3. Знаходимо вкладений компонент-кнопку
const buttonComponent = shadowRoot1.querySelector('div div.btn-container nmbrs-button');

// 4. "Входимо" в тіньове дерево вже цього компонента
const shadowRoot2 = buttonComponent.shadowRoot;

// 5. І тільки тепер знаходимо кінцевий елемент
const finalButton = shadowRoot2.querySelector('button#button');
```

У вигляді одного ланцюжка викликів це виглядає так:

```javascript
const button = document.querySelector('nmbrs-form').shadowRoot
                      .querySelector('div div.btn-container nmbrs-button').shadowRoot
                      .querySelector('button#button');
```

Такий довгий ланцюжок наочно демонструє міць інкапсуляції: щоб дістатися до внутрішніх деталей, потрібно явно пройти через кожну "межу". Це робить код більш передбачуваним і захищає компоненти від випадкових змін.

##### Інкапсуляція від CSS

Стилі, визначені на основній сторінці, не впливають на елементи всередині тіньового DOM.

```css
/* Цей стиль застосується лише до спанів в основному документі */
span {
  color: blue;
  border: 1px solid black;
}
```

Елемент `<span>` всередині тіньового дерева не отримає ці стилі. Це вирішує величезну проблему випадкових перетинів та конфліктів CSS.

#### Застосування стилів всередині тіньового DOM

Стилі, визначені всередині тіньового дерева, у свою чергу, не впливають на основну сторінку. Є два основні способи їх додавання.

##### 1. Конструйовані таблиці стилів (Constructable Stylesheets)

Цей метод дозволяє створювати об'єкт `CSSStyleSheet` у JavaScript та застосовувати його до одного або кількох тіньових дерев. Це ефективно, якщо у вас є спільні стилі для багатьох компонентів.

```javascript
const sheet = new CSSStyleSheet();
sheet.replaceSync("span { color: red; border: 2px dotted black; }");

const shadow = host.attachShadow({ mode: "open" });
// Застосовуємо таблицю стилів до тіньового кореня
shadow.adoptedStyleSheets = [sheet];
```

##### 2. Додавання елемента `<style>`

Простий та декларативний спосіб — помістити тег `<style>` прямо всередину тіньового дерева (часто всередині `<template>`).

```html
<template id="my-element">
  <style>
    span {
      color: red;
      border: 2px dotted black;
    }
  </style>
  <span>Я в тіньовому DOM</span>
</template>
```

#### Shadow DOM та користувацькі елементи: ідеальне поєднання

Вся міць тіньового DOM розкривається при створенні **користувацьких елементів (Custom Elements)**. Без інкапсуляції вони були б неймовірно крихкими.

Користувацький елемент — це клас, що успадковує `HTMLElement`. Як правило, сам елемент виступає в ролі тіньового хоста, а вся його внутрішня структура створюється всередині тіньового дерева.

Ось приклад простого компонента `<filled-circle>`:

```javascript
class FilledCircle extends HTMLElement {
  connectedCallback() {
    const shadow = this.attachShadow({ mode: "open" });

    // Створюємо внутрішню реалізацію (наприклад, SVG-коло)
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    circle.setAttribute("r", "50");
    circle.setAttribute("cx", "50");
    circle.setAttribute("cy", "50");
    // Колір беремо з атрибута самого хоста
    circle.setAttribute("fill", this.getAttribute("color"));
    
    svg.appendChild(circle);
    shadow.appendChild(svg);
  }
}
customElements.define("filled-circle", FilledCircle);
```

Тепер ми можемо використовувати його в HTML як звичайний тег, не турбуючись про його внутрішній устрій:

```html
<filled-circle color="blue"></filled-circle>
<filled-circle color="green"></filled-circle>
```

Кожен з цих компонентів буде повністю інкапсульований та захищений від впливу зовнішньої сторінки.
