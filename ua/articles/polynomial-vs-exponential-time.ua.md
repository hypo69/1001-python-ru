### **Поліноміальний час**

**Поліноміальний час** — це термін, що використовується в теорії обчислювальної складності для опису часу виконання алгоритму, який зростає як поліном від розміру вхідних даних. Якщо час виконання алгоритму може бути виражений як $O(n^k)$, де $n$ — розмір вхідних даних, а $k$ — константа, то такий алгоритм працює за поліноміальний час.

#### **Приклади:**
1. **Сортування списку**: Алгоритми, такі як сортування злиттям або швидке сортування, працюють за $O(n \log n)$, що є поліноміальним часом.
2. **Пошук найкоротшого шляху в графі**: Алгоритм Дейкстри працює за $O(n^2)$ або $O(n \log n)$ залежно від реалізації, що також є поліноміальним.

#### **Особливості:**
- Алгоритми, що працюють за поліноміальний час, вважаються **ефективними** та **практично застосовними**.
- Задачі, які можна вирішити за поліноміальний час, належать до класу **P**.

---

### **Експоненціальний час**

**Експоненціальний час** — це час виконання алгоритму, який зростає експоненціально залежно від розміру вхідних даних. Якщо час виконання може бути виражений як $O(k^n)$, де $n$ — розмір вхідних даних, а $k$ — константа, то такий алгоритм працює за експоненціальний час.

#### **Приклади:**
1. **Задача комівояжера**: Розв'язання методом повного перебору всіх можливих маршрутів вимагає $O(n!)$ часу, що гірше, ніж експоненціальний.
2. **Перебір усіх підмножин**: Алгоритм, який перевіряє всі можливі підмножини множини з $n$ елементів, працює за $O(2^n)$.

#### **Особливості:**
- Алгоритми, що працюють за експоненціальний час, вважаються **неефективними** для великих вхідних даних, оскільки час виконання стає непрактично великим навіть для відносно малих $n$.
- Задачі, які можна вирішити лише за експоненціальний час, часто належать до класів **NP-складних** або **NP-повних**.

---

### **Порівняння поліноміального та експоненціального часу**

| **Характеристика** | **Поліноміальний час** | **Експоненціальний час** |
| ----------------------------- | -------------------------------------- | ---------------------------------------- |
| **Зростання часу виконання** | Повільне (наприклад, $n^2$, $n^3$) | Швидке (наприклад, $2^n$, $3^n$) |
| **Приклади задач** | Сортування, пошук найкоротшого шляху | Задача комівояжера, перебір підмножин |
| **Практична застосовність** | Ефективно для великих даних | Незастосовно для великих даних |
| **Клас складності** | P | NP-складні, NP-повні |

---

### **Чому це важливо?**

1. **Поліноміальний час**:
   - Алгоритми, що працюють за поліноміальний час, вважаються **практично застосовними**, оскільки вони можуть обробляти великі обсяги даних за розумний проміжок часу.
   - Задачі класу **P** (розв'язні за поліноміальний час) є основою для багатьох застосувань у комп'ютерних науках, таких як обробка даних, мережі, криптографія та штучний інтелект.

2. **Експоненціальний час**:
   - Алгоритми, що працюють за експоненціальний час, стають **непрактичними** навіть для відносно малих вхідних даних. Наприклад, для $n = 100$, $2^n$ вже перевищує кількість атомів у видимому Всесвіті.
   - Задачі, які можна вирішити лише за експоненціальний час, часто вимагають використання **методів апроксимації**, **евристик** або **паралельних обчислень**.

---

### **Приклад для розуміння**

Уявіть, що у вас є задача, і ви хочете вирішити її для $n = 10$ та $n = 100$:

- **Поліноміальний час ($n^2$)**:
  - Для $n = 10$: $10^2 = 100$ операцій.
  - Для $n = 100$: $100^2 = 10\,000$ операцій.

- **Експоненціальний час ($2^n$)**:
  - Для $n = 10$: $2^{10} = 1\,024$ операцій.
  - Для $n = 100$: $2^{100} \approx 1.26 \times 10^{30}$ операцій.

Як бачите, для $n = 100$ поліноміальний алгоритм виконає 10 000 операцій, що цілком реально, тоді як експоненціальний алгоритм вимагатиме $1.26 \times 10^{30}$ операцій, що практично неможливо.

Щоб створити графіки, що ілюструють різницю між поліноміальним та експоненціальним часом, можна використовувати різні математичні функції. Ось приклади функцій, які можна використовувати для візуалізації:

---

### **Поліноміальні функції**
1. **Лінійна функція**:  
   $ f(n) = n $  
   Приклад: час виконання алгоритму, який обробляє кожен елемент один раз.

2. **Квадратична функція**:  
   $ f(n) = n^2 $  
   Приклад: час виконання алгоритму з вкладеними циклами, наприклад, бульбашкове сортування.

3. **Кубічна функція**:  
   $ f(n) = n^3 $  
   Приклад: час виконання алгоритму, який обробляє тривимірні дані.

4. **Логарифмічна функція**:  
   $ f(n) = \log n $  
   Приклад: час виконання бінарного пошуку.

5. **Лінійно-логарифмічна функція**:  
   $ f(n) = n \log n $  
   Приклад: час виконання швидкого сортування або сортування злиттям.

---

### **Експоненціальні функції**
1. **Експоненціальна функція**:  
   $ f(n) = 2^n $  
   Приклад: час виконання алгоритму, який перебирає всі підмножини множини.

2. **Факторіальна функція**:  
   $ f(n) = n! $  
   Приклад: час виконання алгоритму, який перебирає всі перестановки (наприклад, задача комівояжера).

3. **Експоненціальна функція з іншою основою**:  
   $ f(n) = 3^n $  
   Приклад: час виконання алгоритму, який досліджує всі можливі комбінації.

---

### **Приклад коду для побудови графіків (Python, Matplotlib)**

```python
import matplotlib.pyplot as plt
import numpy as np
import math # Імпортуємо стандартний модуль math

# Діапазон значень n
n = np.linspace(1, 20, 100)

# Поліноміальні функції
linear = n
quadratic = n**2
cubic = n**3
logarithmic = np.log(n)
nlogn = n * np.log(n)

# Експоненціальні функції
exponential = 2**n
# Використовуємо math.factorial з імпортованого модуля math
factorial = [math.factorial(int(i)) for i in n]  # Факторіал визначений лише для цілих чисел

# Побудова графіків
plt.figure(figsize=(10, 6))

# Поліноміальні функції
plt.plot(n, linear, label='Лінійна: $f(n) = n$')
plt.plot(n, quadratic, label='Квадратична: $f(n) = n^2$')
plt.plot(n, cubic, label='Кубічна: $f(n) = n^3$')
plt.plot(n, logarithmic, label='Логарифмічна: $f(n) = \log n$')
plt.plot(n, nlogn, label='Лінійно-логарифмічна: $f(n) = n \log n$')

# Експоненціальні функції
plt.plot(n, exponential, label='Експоненціальна: $f(n) = 2^n$')
plt.plot(n, factorial, label='Факторіальна: $f(n) = n!$')

# Налаштування графіка
plt.yscale('log')  # Логарифмічна шкала для зручності
plt.xlabel('Розмір вхідних даних (n)')
plt.ylabel('Часова складність')
plt.title('Порівняння поліноміальної та експоненціальної часової складності')
plt.legend()
plt.grid(True)
plt.show()
```

---
![Exponetialy](../assets/exponetialy.png)

### **Що покаже графік?**
- **Поліноміальні функції** зростають повільно і залишаються внизу графіка.
- **Експоненціальні функції** зростають дуже швидко і піднімаються навіть для малих значень $n$.
- Використання **логарифмічної шкали** (на осі Y) допомагає візуалізувати різницю між поліноміальними та експоненціальними функціями, оскільки їхні значення відрізняються на порядки.

---