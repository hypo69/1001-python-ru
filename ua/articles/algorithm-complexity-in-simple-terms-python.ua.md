## Складність алгоритмів простими словами та приклади на Python

У програмуванні існує багато способів вирішення однієї й тієї ж задачі. Однак не всі рішення однаково ефективні. Одним із ключових аспектів, який слід враховувати при розробці алгоритмів, є їхня складність. Розуміння складності алгоритму дозволяє оцінити, наскільки швидко він працюватиме та скільки ресурсів (наприклад, пам'яті) йому знадобиться для виконання, особливо зі збільшенням обсягу вхідних даних. Розуміння складності алгоритмів є фундаментальною навичкою, яка дозволяє писати більш ефективний код.

### Що таке складність алгоритму?

Уявіть, що у вас є завдання: знайти певне ім'я в телефонній книзі.

*   **Простий спосіб (лінійний пошук):** Ви берете книгу і починаєте гортати сторінку за сторінкою, доки не знайдете потрібне ім'я. Якщо ім'я знаходиться в самому кінці книги, вам доведеться перегорнути всю книгу!
*   **Розумний спосіб (бінарний пошук):** Ви відкриваєте книгу посередині. Якщо ім'я, яке ви шукаєте, знаходиться перед ім'ям на цій сторінці, ви закриваєте другу половину книги і шукаєте в першій половині. Якщо ім'я знаходиться пізніше, ви шукаєте в другій половині. І так ви повторюєте, доки не знайдете потрібне ім'я. З кожним кроком ви відкидаєте половину книги!

**Складність алгоритму** — це спосіб описати, скільки "часу" (або ресурсів, таких як пам'ять) знадобиться алгоритму для виконання свого завдання, залежно від того, наскільки "великим" є це завдання.

*   **Лінійний пошук:** Якщо в книзі 10 сторінок, вам може знадобитися перегорнути 10 сторінок. Якщо в книзі 100 сторінок, вам може знадобитися перегорнути 100 сторінок. Обсяг роботи зростає *лінійно* з розміром завдання. Це називається **O(n)**, де 'n' — розмір завдання (кількість сторінок у книзі).

*   **Бінарний пошук:** Якщо в книзі 16 сторінок, вам знадобиться максимум 4 кроки, щоб знайти ім'я. Якщо в книзі 32 сторінки, вам знадобиться максимум 5 кроків. Обсяг роботи зростає набагато повільніше, ніж розмір завдання. Це називається **O(log n)** (читається "О від лог n").



*   Алгоритм **O(n)** стає повільнішим *прямо пропорційно* до збільшення розміру завдання.
*   Алгоритм **O(log n)** стає повільнішим *набагато повільніше*, ніж зростає розмір завдання.



Уявіть, що ви розробляєте пошукову систему. Якщо ви використовуєте алгоритм O(n) для пошуку в Інтернеті (який містить мільярди веб-сторінок), це займе неймовірно багато часу! А алгоритм O(log n) впорається з цим завданням набагато швидше.

### Основні типи складності алгоритмів

Ось деякі з найпоширеніших типів складності:

*   **O(1) – Постійна складність:** Час виконання завжди однаковий, незалежно від розміру завдання. Наприклад, отримання першого елемента зі списку.

    ```python
    def get_first_element(my_list):
        """O(1) - Отримання першого елемента списку."""
        return my_list[0]
    ```

*   **O(log n) – Логарифмічна складність:** Час виконання зростає дуже повільно зі збільшенням розміру завдання. Чудовим прикладом є бінарний пошук.

    ```python
    def binary_search(my_list, target):
        """O(log n) - Бінарний пошук у відсортованому списку."""
        low = 0
        high = len(my_list) - 1

        while low <= high:
            mid = (low + high) // 2
            if my_list[mid] == target:
                return mid
            elif my_list[mid] < target:
                low = mid + 1
            else:
                high = mid - 1
        return -1  # Елемент не знайдено
    ```

*   **O(n) – Лінійна складність:** Час виконання зростає прямо пропорційно до розміру завдання. Наприклад, ітерація по кожному елементу списку.

    ```python
    def linear_search(my_list, target):
        """O(n) - Лінійний пошук у списку."""
        for i in range(len(my_list)):
            if my_list[i] == target:
                return i
        return -1  # Елемент не знайдено
    ```

*   **O(n log n) – Лінійно-логарифмічна складність:**  Часто зустрічається в ефективних алгоритмах сортування, таких як сортування злиттям та швидке сортування.

    ```python
    def merge_sort(my_list):
        """O(n log n) - Сортування злиттям."""
        if len(my_list) <= 1:
            return my_list

        mid = len(my_list) // 2
        left = merge_sort(my_list[:mid])
        right = merge_sort(my_list[mid:])

        return merge(left, right)

    def merge(left, right):
        """Допоміжна функція для merge_sort."""
        merged = []
        i = j = 0

        while i < len(left) and j < len(right):
            if left[i] <= right[j]:
                merged.append(left[i])
                i += 1
            else:
                merged.append(right[j])
                j += 1

        merged.extend(left[i:])
        merged.extend(right[j:])
        return merged
    ```

*   **O(n^2) – Квадратична складність:** Час виконання зростає *квадратично* з розміром завдання. Наприклад, порівняння кожного елемента списку з кожним іншим елементом того ж списку.

    ```python
    def bubble_sort(my_list):
        """O(n^2) - Бульбашкове сортування."""
        n = len(my_list)
        for i in range(n):
            for j in range(0, n-i-1):
                if my_list[j] > my_list[j+1] :
                    my_list[j], my_list[j+1] = my_list[j+1], my_list[j]
    ```

*   **O(2^n) – Експоненціальна складність:** Час виконання зростає дуже швидко зі збільшенням розміру завдання.  Зазвичай зустрічається в алгоритмах, які використовують повний перебір.

    ```python
    def fibonacci_recursive(n):
      """O(2^n) - Рекурсивний розрахунок числа Фібоначчі."""
      if n <= 1:
          return n
      return fibonacci_recursive(n-1) + fibonacci_recursive(n-2)
    ```

*   **O(n!) – Факторіальна складність:** Найповільніший тип складності. Виникає при ітерації по всіх можливих перестановках елементів.

### Приклади задач та алгоритмів з різною складністю

Розглянемо кілька прикладів задач та різних алгоритмів для їх вирішення, щоб побачити,
як складність впливає на продуктивність.

**1. Сортування списку:**

*   **Задача:** Відсортувати список елементів у певному порядку (наприклад, за зростанням).
*   **Алгоритми:**
    *   **Бульбашкове сортування (Bubble Sort):**

        ```python
        def bubble_sort(my_list):
            n = len(my_list)
            for i in range(n):
                for j in range(0, n-i-1):
                    if my_list[j] > my_list[j+1] :
                        my_list[j], my_list[j+1] = my_list[j+1], my_list[j]
        # Приклад використання
        my_list = [64, 34, 25, 12, 22, 11, 90]
        bubble_sort(my_list)
        print("Відсортований масив:", my_list) # Вивід: [11, 12, 22, 25, 34, 64, 90]
        ```

    *   **Сортування злиттям (Merge Sort):**

        ```python
        def merge_sort(my_list):
            if len(my_list) <= 1:
                return my_list

            mid = len(my_list) // 2
            left = merge_sort(my_list[:mid])
            right = merge_sort(my_list[mid:])

            return merge(left, right)

        def merge(left, right):
            merged = []
            i = j = 0

            while i < len(left) and j < len(right):
                if left[i] <= right[j]:
                    merged.append(left[i])
                    i += 1
                else:
                    merged.append(right[j])
                    j += 1

            merged.extend(left[i:])
            merged.extend(right[j:])
            return merged

        # Приклад використання
        my_list = [64, 34, 25, 12, 22, 11, 90]
        sorted_list = merge_sort(my_list)
        print("Відсортований масив:", sorted_list) # Вивід: [11, 12, 22, 25, 34, 64, 90]
        ```
*   **Висновок:** Для великих списків елементів алгоритми з O(n log n) (сортування злиттям) є кращими, ніж алгоритми з O(n^2) (бульбашкове сортування).

**2. Пошук найкоротшого шляху в графі:**

*   **Задача:** Знайти найкоротший шлях між двома вершинами в графі (наприклад, між двома містами на карті).
*   **Алгоритми:**
    *   **Алгоритм Дейкстри:**

        ```python
        import heapq

        def dijkstra(graph, start):
            """Алгоритм Дейкстри для пошуку найкоротших шляхів."""
            distances = {node: float('inf') for node in graph}
            distances[start] = 0
            priority_queue = [(0, start)]  # (відстань, вузол)

            while priority_queue:
                distance, node = heapq.heappop(priority_queue)

                if distance > distances[node]:
                    continue

                for neighbor, weight in graph[node].items():
                    new_distance = distance + weight
                    if new_distance < distances[neighbor]:
                        distances[neighbor] = new_distance
                        heapq.heappush(priority_queue, (new_distance, neighbor))

            return distances

        # Приклад використання
        graph = {
            'A': {'B': 5, 'C': 1},
            'B': {'A': 5, 'C': 2, 'D': 1},
            'C': {'A': 1, 'B': 2, 'D': 4, 'E': 8},
            'D': {'B': 1, 'C': 4, 'E': 3, 'F': 6},
            'E': {'C': 8, 'D': 3},
            'F': {'D': 6}
        }
        start_node = 'A'
        shortest_paths = dijkstra(graph, start_node)
        print(f"Найкоротші шляхи від {start_node}: {shortest_paths}")
        ```

*   **Висновок:** Вибір алгоритму залежить від типу графа (зважений/незважений, наявність від'ємних ваг) та розміру графа. Алгоритм Дейкстри ефективний для графів з невід'ємними вагами.

**3. Пошук підрядка в рядку:**

*   **Задача:** Знайти всі входження певного підрядка у більшому рядку.
*   **Алгоритми:**
    *   **Наївний пошук рядка (Naive String Search):**

        ```python
        def naive_string_search(text, pattern):
            """Наївний алгоритм пошуку рядка."""
            occurrences = []
            for i in range(len(text) - len(pattern) + 1):
                if text[i:i+len(pattern)] == pattern:
                    occurrences.append(i)
            return occurrences

        # Приклад використання
        text = "Це простий приклад тексту."
        pattern = "приклад"
        occurrences = naive_string_search(text, pattern)
        print(f"Входження '{pattern}' у текст: {occurrences}")  # Вивід: [17]
        ```

*   **Висновок:** Для частих пошуків підрядків у великих рядках існують ефективніші алгоритми, такі як KMP.

**4. Задача про рюкзак (Knapsack Problem):**

*   **Задача:** У вас є рюкзак певної місткості та набір предметів з різними вагами та цінностями. Вам потрібно вибрати предмети, які максимізують загальну цінність, не перевищуючи місткості рюкзака.
*   **Алгоритми:**
    *   **Динамічне програмування (Dynamic Programming):**

        ```python
        def knapsack_dynamic_programming(capacity, weights, values, n):
            """Розв'язання задачі про рюкзак за допомогою динамічного програмування."""
            dp = [[0 for x in range(capacity + 1)] for x in range(n + 1)]

            for i in range(n + 1):
                for w in range(capacity + 1):
                    if i == 0 or w == 0:
                        dp[i][w] = 0
                    elif weights[i-1] <= w:
                        dp[i][w] = max(values[i-1] + dp[i-1][w-weights[i-1]],  dp[i-1][w])
                    else:
                        dp[i][w] = dp[i-1][w]

            return dp[n][capacity]

        # Приклад використання
        capacity = 50
        weights = [10, 20, 30]
        values = [60, 100, 120]
        n = len(values)
        max_value = knapsack_dynamic_programming(capacity, weights, values, n)
        print(f"Максимальне значення: {max_value}")  # Вивід: 220
        ```

*   **Вибір алгоритму залежить від розміру задачі та вимог до точності рішення.**

###  Нотація Big O: спрощення складності

Зазвичай складність описується за допомогою "великого О" (нотація O). Вона показує, наскільки швидко час виконання алгоритму зростає з розміром задачі, *асимптотично*, тобто для дуже великих значень `n`. Менші константи та деталі реалізації зазвичай ігноруються. Наприклад, алгоритм, який виконує `2n + 5` операцій, все ще вважається *O(n)*.

###  Найгірший випадок, середній випадок, найкращий випадок

Складність алгоритму може залежати від вхідних даних. Зазвичай ми говоримо про складність у *найгіршому випадку* — це максимальна кількість часу або ресурсів, які може знадобитися алгоритму. Іноді також аналізується складність у середньому та найкращому випадках.
