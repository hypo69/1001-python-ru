# Funciones en Python

Las funciones en el lenguaje Python son bloques de código con nombre que realizan una tarea específica. Permiten organizar el código, hacerlo más estructurado y fácil de reutilizar.

# Tabla de contenido

1. [Declaración de función](#declaración-de-función)
2. [Parámetros de función](#parámetros-de-función)
   - [Tipos de parámetros](#tipos-de-parámetros)
3. [Retorno de valor](#retorno-de-valor)
4. [Variables locales y globales](#variables-locales-y-globales)
5. [Funciones anidadas](#funciones-anidadas)
6. [Recursividad](#recursividad)
7. [Manejo de excepciones con `try` y `except`](#manejo-de-excepciones-con-try-y-except)
8. [Ejemplo de uso de funciones](#ejemplo-de-uso-de-funciones)

<h2>Declaración de función</h2>

<p>Una función se declara con la palabra clave <code>def</code>, seguida del nombre de la función, una lista de parámetros entre paréntesis y dos puntos. El cuerpo de la función se escribe con una sangría.</p>

<pre class="line-numbers"><code class="language-python">
def nombre_funcion(parámetros):
    # actions
    return resultado
</code></pre>

<h3>Ejemplo:</h3>
<pre class="line-numbers"><code class="language-python">
def sumar(a: int, b: int) -> int:
    """Returns the sum of two numbers."""
    return a + b
</code></pre>

<p>Aquí:
- <code>a: int</code> y <code>b: int</code> — parámetros de función con anotaciones de tipo.
- <code>-> int</code> — anotación de tipo del valor de retorno.</p>

<h2>Parámetros de función</h2>

<p>Las funciones pueden aceptar parámetros, que representan datos de entrada. Se especifican entre paréntesis después del nombre de la función.</p>

<p>Ejemplo con un parámetro:</p>
<pre class="line-numbers"><code class="language-python">
def saludar(nombre: str) -> str:
    """Greets the user by their name."""
    return f"¡Hola, {nombre}!"
</code></pre>

<h3>Tipos de parámetros:</h3>
<ol>
<li><strong>Parámetros obligatorios</strong> — deben pasarse al llamar a la función.</li>
<li><strong>Parámetros opcionales</strong> — pueden tener valores predeterminados.
<pre class="line-numbers"><code class="language-python">
   def saludar(nombre: str, edad: int = 18) -> str:
       return f"¡Hola, {nombre}! Tienes {edad} años."
</code></pre>
</li>
</ol>
<h2>Retorno de valor</h2>

<p>Una función puede devolver un valor usando la palabra clave <code>return</code>. Si no se usa <code>return</code>, la función devuelve <code>None</code> por defecto.</p>

<p>Ejemplo:</p>
<pre class="line-numbers"><code class="language-python">
def multiplicar(a: int, b: int) -> int:
    """Returns the product of two numbers."""
    return a * b
</code></pre>

<h2>Variables locales y globales</h2>

<ul>
<li><strong>Variable local</strong> — es una variable que existe solo dentro de una función. Se crea y se destruye con cada llamada a la función.</li>
<li><strong>Variable global</strong> — es una variable que es accesible en todo el código, incluidas las funciones.</li>
</ul>
<p>Ejemplo de uso de una variable global:</p>
<pre class="line-numbers"><code class="language-python">
x = 10  # Global variable

def mostrar_x() -> int:
    return x  # Access to the global variable
</code></pre>

<p>Si dentro de una función necesita cambiar una variable global, debe usar la palabra clave <code>global</code>:</p>
<pre class="line-numbers"><code class="language-python">
x = 10  # Global variable

def cambiar_x() -> None:
    global x
    x = 20
</code></pre>

<h2>Funciones anidadas</h2>

<p>En Python, las funciones pueden estar anidadas, lo que significa que una función puede definirse dentro de otra. Una función anidada puede acceder a las variables de la función externa.</p>

<p>Ejemplo:</p>
<pre class="line-numbers"><code class="language-python">
def exterior(a: int, b: int) -> int:
    """A function that uses a nested function to calculate the difference."""
    
    def anidada(x: int, y: int) -> int:
        """A nested function that returns the difference."""
        return x - y
    
    return anidada(a, b)
</code></pre>

<h2>Recursividad</h2>

<p>La recursividad es cuando una función se llama a sí misma. Esto es útil para tareas que se pueden dividir en tareas más pequeñas y similares (por ejemplo, factorial).</p>

<p>Ejemplo de recursividad:</p>
<pre class="line-numbers"><code class="language-python">
def factorial(n: int) -> int:
    """Calculates the factorial of a number using recursion."""
    if n == 0:
        return 1  # Base case
    return n * factorial(n - 1)  # Recursive call
</code></pre>

<h2>Manejo de excepciones con `try` y `except`</h2>

<p>Python proporciona un mecanismo de manejo de errores usando bloques <code>try</code> y <code>except</code>. El código que puede causar un error se coloca en el bloque <code>try</code>, y los errores se manejan en el bloque <code>except</code>.</p>

<p>Ejemplo de manejo de errores:</p>
<pre class="line-numbers"><code class="language-python">
def dividir(a: int, b: int) -> float:
    """Divides one number by another, handling possible errors."""
    try:
        result = a / b
    except ZeroDivisionError:
        return "Error: división por cero"
    except Exception as e:
        return f"Se produjo un error: {e}"
    return result
</code></pre>

<p>Aquí:
- El bloque <code>try</code> intenta realizar la operación de división.
- El bloque <code>except ZeroDivisionError</code> captura el error de división por cero.
- El bloque <code>except Exception as e</code> captura otras excepciones y muestra un mensaje de error.</p>

<h2>Ejemplo de uso de funciones</h2>

<pre class="line-numbers"><code class="language-python">
# Sum of two numbers
print(sumar(5, 3))  # 8

# Nested function
print(exterior(10, 4))  # 6

# Recursion for factorial calculation
print(factorial(5))  # 120

# Exception handling in division
print(dividir(10, 2))  # 5.0
print(dividir(10, 0))  # Error: división por cero
</code></pre>
<hr>
<p><a href="https://github.com/hypo69/101_python_computer_games_ru/blob/master/cheat_sheets#readme">Al índice</a></p>