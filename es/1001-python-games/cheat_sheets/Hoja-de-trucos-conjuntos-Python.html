# Conjuntos en Python

**1. IntroducciÃ³n: Â¿QuÃ© son los conjuntos?**

En informÃ¡tica y matemÃ¡ticas, los conjuntos son una forma de representar colecciones de elementos Ãºnicos. Es importante entender que:

<ul>
<li><strong>Unicidad:</strong> Cada elemento de un conjunto debe ser Ãºnico. No se permiten repeticiones.</li>
<li><strong>Sin orden:</strong> El orden de los elementos en un conjunto no importa.</li>
</ul>
<p><strong>2. Conjuntos y frutas</strong></p>
<p>Imaginemos que solo tenemos las frutas mismas:</p>
<ul>
<li>ğŸ (manzana)</li>
<li>ğŸ (pera)</li>
<li>ğŸ‰ (melÃ³n)</li>
<li>ğŸ§º (cesta)</li>
</ul>
<p>Es importante que:</p>
<ol>
<li><strong>No hay frutas idÃ©nticas en el conjunto:</strong> Si hay una manzana en el conjunto, no habrÃ¡ otra manzana igual. Cada fruta es Ãºnica en su conjunto.</li>
<li><strong>El orden de las frutas no importa:</strong> Si hay una manzana y una pera en el conjunto, es lo mismo que si hubiera una pera y una manzana. El orden no importa.</li>
</ol>
<p>Por ejemplo, <code>{ğŸ, ğŸ, ğŸ‰}</code> es un conjunto que contiene una manzana, una pera y un melÃ³n.</p>
<p><strong>3. Â¿Por quÃ© los conjuntos requieren elementos Ãºnicos?</strong></p>
<ul>
<li>Los conjuntos estÃ¡n diseÃ±ados para rastrear la <em>presencia</em> de elementos, no su <em>cantidad</em>.</li>
<li>La unicidad de los elementos simplifica la ejecuciÃ³n de las operaciones de conjunto.</li>
<li>Los conjuntos se utilizan para eliminar la redundancia de datos.</li>
</ul>
<p><strong>4. Operaciones de conjunto (conjuntos de frutas):</strong></p>
<ol>
<li><strong>UniÃ³n: "Reunir todas las frutas en un solo conjunto"</strong>
<ul>
<li>Combinar dos conjuntos de frutas, reuniendo todas las frutas en un nuevo conjunto. Si hay frutas idÃ©nticas en dos conjuntos, el nuevo conjunto solo contendrÃ¡ una de esas frutas.</li>
<li>Si el conjunto A contiene {ğŸ, ğŸ}, y el conjunto B contiene {ğŸ, ğŸ‰}, entonces el conjunto A âˆª B contendrÃ¡ {ğŸ, ğŸ, ğŸ‰}.</li>
</ul>
</li>
<li><strong>IntersecciÃ³n: "Encontrar frutas comunes"</strong>
<ul>
<li>Encontrar <em>solo</em> aquellas frutas que estÃ¡n presentes tanto en el conjunto A como en el conjunto B.</li>
<li>Si el conjunto A contiene {ğŸ, ğŸ}, y el conjunto B contiene {ğŸ, ğŸ‰}, entonces el conjunto A âˆ© B solo contendrÃ¡ {ğŸ}.</li>
</ul>
</li>
<li><strong>Diferencia: "Frutas que estÃ¡n en un conjunto pero no en otro"</strong>
<ul>
<li>Encontrar <em>solo</em> aquellas frutas que estÃ¡n presentes en el conjunto A pero no en el conjunto B.</li>
<li>Si el conjunto A contiene {ğŸ, ğŸ}, y el conjunto B contiene {ğŸ, ğŸ‰}, entonces el conjunto A - B contendrÃ¡ {ğŸ}, y el conjunto B - A contendrÃ¡ {ğŸ‰}.</li>
</ul>
</li>
<li><strong>Diferencia simÃ©trica: "Frutas que solo estÃ¡n en uno de los conjuntos"</strong>
<ul>
<li>Encontrar <em>todas</em> las frutas que estÃ¡n presentes en el conjunto A o en el conjunto B, pero no en ambos simultÃ¡neamente.</li>
<li>Si el conjunto A contiene {ğŸ, ğŸ}, y el conjunto B contiene {ğŸ, ğŸ‰}, entonces el conjunto A ^ B contendrÃ¡ {ğŸ, ğŸ‰}.</li>
</ul>
</li>
<li><strong>Subconjunto: "Â¿EstÃ¡n todas las frutas de un conjunto presentes en otro?"</strong>
<ul>
<li>Verificar si el conjunto A es un subconjunto del conjunto B. Esto significa que todas las frutas del conjunto A tambiÃ©n estÃ¡n presentes en el conjunto B.</li>
<li><strong>Ejemplo:</strong> Si el conjunto A contiene {ğŸ, ğŸ}, y el conjunto B contiene {ğŸ, ğŸ, ğŸ‰}, entonces A <= B.</li>
</ul>
</li>
<li><strong>Superconjunto: "Â¿Un conjunto contiene todas las frutas de otro?"</strong>
<ul>
<li>Verificar si el conjunto A es un superconjunto del conjunto B. Esto significa que todas las frutas del conjunto B tambiÃ©n estÃ¡n presentes en el conjunto A.</li>
<li>Si el conjunto A contiene {ğŸ, ğŸ, ğŸ‰}, y el conjunto B contiene {ğŸ, ğŸ}, entonces A >= B.</li>
</ul>
</li>
</ol>
<pre class="line-numbers"><code class="language-python">
from typing import Set

def create_fruit_set(fruit_string: str) -> Set[str]:
    """
    Creates a set of fruits from a string.

    Args:
        fruit_string: String of fruits (ğŸ, ğŸ, ğŸ‰, ğŸ§º).

    Returns:
        Set of unique fruits.
    """
    if not all(fruit in ["ğŸ", "ğŸ", "ğŸ‰", "ğŸ§º"] for fruit in fruit_string):
        raise ValueError("La cadena solo puede contener los sÃ­mbolos ğŸ, ğŸ, ğŸ‰, ğŸ§º")
    return set(fruit_string)  # Use set() to create a set

def display_set(fruit_set: Set[str]) -> str:
  """
  Converts a set of fruits into a string for display.

    Args:
        fruit_set: Set of fruits.

    Returns:
        String to display.
  """
  return "{" + ", ".join(fruit_set) + "}"


# Create fruit sets
fruits_set_A = create_fruit_set("ğŸğŸ")  # Set A: {ğŸ, ğŸ}
fruits_set_B = create_fruit_set("ğŸğŸ‰")  # Set B: {ğŸ, ğŸ‰}
fruits_set_C = create_fruit_set("ğŸğŸğŸ‰")  # Set C: {ğŸ, ğŸ, ğŸ‰}
fruits_set_D = create_fruit_set("ğŸ§º")  # Set D: {ğŸ§º}

# Print sets
print(f"Conjunto A: {display_set(fruits_set_A)}")
print(f"Conjunto B: {display_set(fruits_set_B)}")
print(f"Conjunto C: {display_set(fruits_set_C)}")
print(f"Conjunto D: {display_set(fruits_set_D)}")

# Set union
union_result = fruits_set_A | fruits_set_B
print(f"A âˆª B: {display_set(union_result)}")  # Result: {ğŸ, ğŸ, ğŸ‰}

# Set intersection
intersection_result = fruits_set_A & fruits_set_B
print(f"A âˆ© B: {display_set(intersection_result)}")  # Result: {ğŸ}

# Set difference
difference_result_AB = fruits_set_A - fruits_set_B
print(f"A - B: {display_set(difference_result_AB)}")  # Result: {ğŸ}
difference_result_BA = fruits_set_B - fruits_set_A
print(f"B - A: {display_set(difference_result_BA)}")  # Result: {ğŸ‰}

# Symmetric difference of sets
symmetric_difference_result = fruits_set_A ^ fruits_set_B
print(f"A ^ B: {display_set(symmetric_difference_result)}")  # Result: {ğŸ, ğŸ‰}

# Subset
subset_result1 = fruits_set_A <= fruits_set_C
print(f"A <= C: {subset_result1}")  # Result: True (A is a subset of C)
subset_result2 = fruits_set_A <= fruits_set_B
print(f"A <= B: {subset_result2}") # Result: False (A is not a subset of B)

# Superset
superset_result1 = fruits_set_C >= fruits_set_A
print(f"C >= A: {superset_result1}")  # Result: True (C is a superset of A)
superset_result2 = fruits_set_B >= fruits_set_A
print(f"B >= A: {superset_result2}")  # Result: False (B is not a superset of A)

# Check for element presence
print(f"ğŸ en A: {'ğŸ' in fruits_set_A}")  # Result: True
print(f"ğŸ‰ en A: {'ğŸ‰' in fruits_set_A}")  # Result: False
</code></pre>
<ul>
<li><strong><code>create_fruit_set(fruit_string)</code>:</strong> Esta funciÃ³n crea un conjunto a partir de una cadena de frutas.
<ul>
<li><code>set(fruit_string)</code> convierte la cadena en un conjunto, eliminando duplicados y haciendo que el orden de los elementos sea irrelevante.</li>
<li>Verificamos que la cadena contenga solo caracteres Unicode permitidos.</li>
</ul>
</li>
<li><strong><code>display_set(fruit_set)</code>:</strong> Esta funciÃ³n se utiliza para convertir un conjunto en una cadena legible para la salida.</li>
<li><strong>Ejemplos:</strong> Creamos varios conjuntos y aplicamos varias operaciones a ellos. Los resultados de cada operaciÃ³n se imprimen en la pantalla.</li>
</ul>
<p><strong>5. Tareas de prÃ¡ctica:</strong></p>
<ol>
<li>Cree sus propios conjuntos de frutas y pruebe todas las operaciones en ellos.</li>
<li>Implemente la funciÃ³n <code>is_disjoint(set1, set2)</code>, que verificarÃ¡ si dos conjuntos son disjuntos (la intersecciÃ³n = conjunto vacÃ­o).</li>
<li>Implemente la funciÃ³n <code>power_set(fruit_set)</code>, que devolverÃ¡ el conjunto de todos los subconjuntos de un conjunto dado.</li>
<li>Intente aplicar conjuntos para resolver un problema real. Por ejemplo, tiene dos listas de invitados para una fiesta, encuentre los invitados que estÃ¡n en ambas listas, los invitados que solo estÃ¡n en la primera lista, etc.</li>
</ol>