# Algoritmos de ordenaciÃ³n

En la vida cotidiana y en la programaciÃ³n, nos encontramos con la necesidad de ordenar datos.
Esto puede ser cualquier cosa: una lista de compras, libros en un estante o resultados de bÃºsqueda.
Los algoritmos de ordenaciÃ³n son un conjunto de instrucciones que nos ayudan a organizar los elementos en un orden determinado, ya sea ascendente,
descendente o segÃºn algÃºn otro criterio.

Por ejemplo, utilizo frutas de diferentes tamaÃ±os.

<strong>RepresentaciÃ³n de frutas con tamaÃ±os:</strong>

Asociaremos las frutas con los tamaÃ±os. Usaremos tuplas, donde:

<ul>
<li>El primer elemento es el tamaÃ±o de la fruta:
<ul>
<li>ğŸ (pequeÃ±a) â€“ manzana</li>
<li>ğŸ (mediana) â€“ pera</li>
<li>ğŸ‰ (grande) â€“ melÃ³n</li>
<li>ğŸ§º (muy grande) â€“ cesta</li>
</ul>
</li>
<li>El segundo elemento es un identificador Ãºnico, para el funcionamiento del programa.</li>
</ul>
<p>Ejemplo: <code>(ğŸ, 1)</code> â€“ es una manzana pequeÃ±a con identificador 1.</p>
<pre class="line-numbers"><code class="language-python">
from typing import List, Tuple

def compare_fruits(fruit1: Tuple[str, int], fruit2: Tuple[str, int]) -> int:
    """
    Compares two fruits by size.

    Args:
        fruit1: Tuple (size, identifier).
        fruit2: Tuple (size, identifier).

    Returns:
        -1 if fruit1 is less than fruit2, 1 if fruit1 is greater than fruit2, 0 if they are equal.
    """
    order = {"ğŸ": 0, "ğŸ": 1, "ğŸ‰": 2, "ğŸ§º": 3}  # Define the order of fruits by size
    size1 = order.get(fruit1[0]) # Get the size of the first fruit
    size2 = order.get(fruit2[0]) # Get the size of the second fruit
    if size1 < size2: # If the size of the first fruit is smaller, return -1
        return -1
    elif size1 > size2: # If the size of the first fruit is larger, return 1
        return 1
    else: # If the sizes are equal, return 0
      return 0
</code></pre>

<p><strong>Algoritmos de ordenaciÃ³n (comparaciÃ³n por tamaÃ±o de fruta):</strong></p>
<ol>
<li><strong>OrdenaciÃ³n de burbuja (Bubble Sort):</strong> (Las burbujas mÃ¡s ligeras suben antes)
<ul>
<li>El algoritmo compara frutas adyacentes por tamaÃ±o. Si una fruta es mÃ¡s grande que la adyacente, intercambia posiciones con ella.</li>
<li>Este proceso se repite hasta que toda la lista de frutas estÃ© ordenada de menor a mayor.</li>
<li>AnalogÃ­a: Imagine que tiene un acuario con burbujas de aire de diferentes tamaÃ±os. Las burbujas mÃ¡s ligeras (correspondientes a frutas mÃ¡s pequeÃ±as) subirÃ¡n a la superficie antes que las mÃ¡s pesadas (correspondientes a frutas mÃ¡s grandes). AsÃ­, las frutas mÃ¡s ligeras "flotan" a la parte superior de la lista, y las mÃ¡s pesadas se hunden hasta el fondo.</li>
</ul>
<pre class="line-numbers"><code class="language-mermaid">
graph TD
    A[Start] --> B{Are there unsorted fruits?};
    B -- SÃ­ --> C[Compare two adjacent fruits];
    C -- La primera es mÃ¡s grande --> D[Swap positions];
    D --> E[Go to next pair];
    C -- La primera no es mÃ¡s grande --> E;
    E --> F{Reached end of list?};
    F -- No --> C;
    F -- SÃ­ --> G{Was there a swap?};
    G -- SÃ­ --> B;
    G -- No --> H[End];
    B -- No --> H;
    H[End]
</code></pre>
<pre class="line-numbers"><code class="language-python">
def bubble_sort(fruits: List[Tuple[str, int]]) -> List[Tuple[str, int]]:
    """
    Sorts a list of fruits by size, using the "bubble sort" algorithm.

    Args:
        fruits: List of tuples (size, identifier).

    Returns:
        Sorted list of tuples.
    """
    n = len(fruits)  # Get the number of fruits
    for i in range(n):  # Iterate through the list n times
        for j in range(0, n - i - 1):  # Iterate through the unsorted part of the list
            if compare_fruits(fruits[j], fruits[j + 1]) == 1:  # If the fruit on the left is larger than the one on the right
                fruits[j], fruits[j + 1] = fruits[j + 1], fruits[j]  # Swap positions
        return fruits

</code></pre>
</li>
<li><strong>OrdenaciÃ³n por inserciÃ³n (Insertion Sort):</strong>
<ul>
<li>El algoritmo construye una lista ordenada, agregando frutas una por una. Una nueva fruta se inserta en la posiciÃ³n correcta para mantener el orden por tamaÃ±o.</li>
<li>La ordenaciÃ³n por inserciÃ³n es buena para listas pequeÃ±as o para aquellas donde los datos ya estÃ¡n casi ordenados.</li>
</ul>
</li>
<li><strong>OrdenaciÃ³n por selecciÃ³n (Selection Sort):</strong>
<ul>
<li>El algoritmo encuentra la fruta mÃ¡s pequeÃ±a en la parte sin ordenar de la lista. Luego coloca esta fruta en la primera posiciÃ³n de la parte sin ordenar de la lista.</li>
<li>Este proceso se repite hasta que todas las frutas estÃ©n ordenadas.</li>
<li>La ordenaciÃ³n por selecciÃ³n es simple pero ineficiente para listas grandes.</li>
</ul>
</li>
</ol>
<pre class="line-numbers"><code class="language-python">
def insertion_sort(fruits: List[Tuple[str, int]]) -> List[Tuple[str, int]]:
    """
    Sorts a list of fruits by size, using the "insertion sort" algorithm.

    Args:
        fruits: List of tuples (size, identifier).

    Returns:
        Sorted list of tuples.
    """
    for i in range(1, len(fruits)): # Start from the second fruit (the first is considered sorted)
        key = fruits[i] # Take the next fruit
        j = i - 1 # Index of the previous fruit
        while j >= 0 and compare_fruits(fruits[j], key) == 1: # Find the position in the sorted part where to insert the fruit
            fruits[j + 1] = fruits[j] # Shift fruits to make space for the new one
            j -= 1
        fruits[j + 1] = key # Insert the fruit in the correct position
    return fruits

def selection_sort(fruits: List[Tuple[str, int]]) -> List[Tuple[str, int]]:
    """
    Sorts a list of fruits by size, using the "selection sort" algorithm.

    Args:
        fruits: List of tuples (size, identifier).

    Returns:
        Sorted list of tuples.
    """
    n = len(fruits) # Get the number of fruits in the list
    for i in range(n): # Iterate through all fruits in the list
        min_index = i # Index of the smallest fruit
        for j in range(i + 1, n): # Find the smallest fruit in the unsorted part
            if compare_fruits(fruits[j], fruits[min_index]) == -1: # If a fruit smaller than the current minimum is found
                min_index = j # Remember the index of the new minimum
        fruits[i], fruits[min_index] = fruits[min_index], fruits[i] # Swap the current fruit with the smallest in the unsorted part
    return fruits

def display_fruits(fruits: List[Tuple[str, int]]) -> str:
    """
    Converts a list of fruits into a string for display.

    Args:
        fruits: List of tuples (size, identifier).

    Returns:
        String to display the list of fruits.
    """
    return ", ".join(f"{fruit[0]}{fruit[1]}" for fruit in fruits)  # Build string for output


# Create a list of fruits to sort
fruits = [
    ("ğŸ‰", 1), ("ğŸ", 2), ("ğŸ", 3), ("ğŸ§º", 4), ("ğŸ", 5), ("ğŸ‰", 6), ("ğŸ", 7),
    ("ğŸ", 8), ("ğŸ§º", 9), ("ğŸ‰", 10), ("ğŸ", 11), ("ğŸ", 12)
]

print("Lista original de frutas: " + display_fruits(fruits))  # Print the original list
print("Ejemplos: Manzana (ğŸ) < Peras (ğŸ) < MelÃ³n (ğŸ‰) < Cestas (ğŸ§º)")  # Display the order of the fruits

# Bubble sort
sorted_fruits_bubble = bubble_sort(fruits.copy()) # Sort a copy of the list
print("OrdenaciÃ³n de burbuja: " + display_fruits(sorted_fruits_bubble)) # Print the result

# Insertion sort
sorted_fruits_insertion = insertion_sort(fruits.copy()) # Sort a copy of the list
print("OrdenaciÃ³n por inserciÃ³n: " + display_fruits(sorted_fruits_insertion)) # Print the result

# Selection sort
sorted_fruits_selection = selection_sort(fruits.copy()) # Sort a copy of the list
print("OrdenaciÃ³n por selecciÃ³n: " + display_fruits(sorted_fruits_selection)) # Print the result
</code></pre>

<p><strong>ExplicaciÃ³n del cÃ³digo:</strong></p>
<ol>
<li><strong><code>compare_fruits(fruit1, fruit2)</code>:</strong> Esta funciÃ³n compara dos frutas por tamaÃ±o y devuelve -1 si la primera fruta es mÃ¡s pequeÃ±a, 1 si es mÃ¡s grande y 0 si son iguales. Utilizo el diccionario <code>order</code> para definir el orden de los tamaÃ±os de las frutas.</li>
<li><strong><code>bubble_sort(fruits)</code>:</strong> Implemento el algoritmo de ordenaciÃ³n de burbuja, donde las frutas adyacentes se comparan y se intercambian si estÃ¡n en el orden incorrecto.</li>
<li><strong><code>insertion_sort(fruits)</code>:</strong> Implemento el algoritmo de ordenaciÃ³n por inserciÃ³n, donde cada nueva fruta se inserta en la posiciÃ³n correcta en la parte ya ordenada de la lista.</li>
<li><strong><code>selection_sort(fruits)</code>:</strong> Implemento el algoritmo de ordenaciÃ³n por selecciÃ³n, donde en cada pasada encuentro la fruta mÃ¡s pequeÃ±a y la coloco en la posiciÃ³n correcta.</li>
<li><strong><code>display_fruits(fruits)</code>:</strong> Esta funciÃ³n convierte una lista de frutas en una cadena para una salida conveniente.</li>
<li><strong>Ejemplos:</strong> Al final, creo una lista de frutas y aplico los tres algoritmos de ordenaciÃ³n, imprimiendo los resultados de cada uno. TambiÃ©n le muestro el orden en que se ordenan las frutas.</li>
</ol>