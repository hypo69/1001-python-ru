<h2>Dataclasses: Cuando Python se encuentra con datos estructurados (con nuevos ejemplos con nombre)</h2>
<p>En Python, cuando necesitas una clase para almacenar datos, normalmente tienes que escribir código repetitivo para <code>__init__</code>, <code>__repr__</code>, <code>__eq__</code> y otros métodos mágicos. El módulo <code>dataclasses</code>, introducido en Python 3.7, tiene como objetivo resolver este problema proporcionando un decorador <code>@dataclass</code> que genera automáticamente estos métodos por ti.</p>
<h3>¿Qué es una Dataclass?</h3>
<p>Una <code>dataclass</code> es una clase que, como su nombre indica, está destinada principalmente a almacenar datos. Proporciona los siguientes beneficios clave:</p>
<ul>
<li><strong>Menos código repetitivo:</strong> Genera automáticamente <code>__init__</code>, <code>__repr__</code>, <code>__eq__</code>, <code>__hash__</code> (bajo ciertas condiciones) y otros métodos basados en las anotaciones de tipo de tus campos.</li>
<li><strong>Legibilidad:</strong> El código se vuelve más conciso y centrado en definir la estructura de datos.</li>
<li><strong>Introspección:</strong> Los campos de Dataclass son fáciles de introspeccionar (verificar) usando funciones del mismo módulo <code>dataclasses</code>.</li>
<li><strong>Rendimiento (con <code>slots=True</code>):</strong> Puede consumir menos memoria y ser más rápido en el acceso a los atributos.</li>
</ul>
<h3>Uso básico</h3>
<p>Empecemos con un ejemplo sencillo. Supongamos que necesitamos una clase para representar un punto en el espacio 2D.</p>
<pre class="line-numbers"><code class="language-python">from dataclasses import dataclass

@dataclass
class Point:
    x: int
    y: int

# Creando una instancia
p1 = Point(10, 20)
print(p1) # Point(x=10, y=20) - __repr__ generado automáticamente

# Comparando instancias - __eq__ generado automáticamente
p2 = Point(10, 20)
p3 = Point(30, 40)
print(p1 == p2) # True
print(p1 == p3) # False
</code></pre>
<p>Como puedes ver, no tuvimos que escribir <code>__init__</code> o <code>__repr__</code>. Todo funcionó "listo para usar".</p>
<h3>Parámetros del decorador <code>@dataclass</code></h3>
<p>El decorador <code>@dataclass</code> acepta varios parámetros que te permiten personalizar el comportamiento generado.</p>
<pre class="line-numbers"><code class="language-python">@dataclass(
    init=True,         # Generar __init__ (predeterminado True)
    repr=True,         # Generar __repr__ (predeterminado True)
    eq=True,           # Generar __eq__ (predeterminado True)
    order=False,       # Generar __lt__, __le__, __gt__, __ge__ (predeterminado False)
    unsafe_hash=False, # Generar __hash__ (predeterminado False)
    frozen=False,      # Hacer las instancias inmutables (predeterminado False)
    match_args=True,   # Incluir la clase en el mecanismo de coincidencia de patrones estructurales (Python 3.10+, predeterminado True)
    kw_only=False,     # Hacer que todos los campos sean argumentos de solo palabras clave en __init__ (Python 3.10+, predeterminado False)
    slots=False        # Usar __slots__ para ahorrar memoria (Python 3.10+, predeterminado False)
)
class MyDataClass:
    # ...
</code></pre>
<p>Consideremos los más importantes, incluidos los que estaban en tu solicitud:</p>
<h4><code>init=True</code> (predeterminado)</h4>
<p>Si es <code>True</code>, entonces <code>dataclass</code> generará el método <code>__init__</code>. Si tienes tu propio <code>__init__</code> y dejas <code>init=True</code>, se llamará a tu <code>__init__</code>, pero los campos definidos en la clase de datos no se inicializarán a través de él automáticamente. Por lo general, si escribes tu propio <code>__init__</code>, estableces <code>init=False</code> para evitar conflictos y tener un control total sobre la inicialización.</p>
<pre class="line-numbers"><code class="language-python">@dataclass(init=False)
class CustomPersonInit:
    name: str
    age: int

    def __init__(self, name: str, age: int, welcome_message: str = "¡Hola!"):
        self.name = name
        self.age = age
        print(welcome_message)

alice = CustomPersonInit("Alice", 30) # Imprime "¡Hola!"
print(alice) # CustomPersonInit(name='Alice', age=30) - repr sigue funcionando
</code></pre>
<h4><code>repr=True</code> (predeterminado)</h4>
<p>Si es <code>True</code>, generará un método <code>__repr__</code> que proporciona una representación de cadena conveniente del objeto, útil para la depuración.</p>
<h4><code>eq=True</code> (predeterminado)</h4>
<p>Si es <code>True</code>, generará un método <code>__eq__</code> que te permite comparar dos instancias de una clase en busca de igualdad al verificar la igualdad de todos sus campos.</p>
<h4><code>order=False</code></h4>
<p>Si es <code>True</code>, entonces <code>dataclass</code> generará los métodos <code>__lt__</code>, <code>__le__</code>, <code>__gt__</code>, <code>__ge__</code>. Esto te permite comparar instancias por "menor que", "mayor que", etc. La comparación se realiza en el orden en que se declaran los campos. Para que <code>order=True</code> funcione, <code>eq=True</code> también debe establecerse.</p>
<pre class="line-numbers"><code class="language-python">@dataclass(order=True)
class Person:
    name: str
    age: int

alice = Person("Alice", 30)
boris = Person("Boris", 25)
victor = Person("Victor", 35) # Agreguemos a Victor
galina = Person("Galina", 30)
alice_older = Person("Alice", 35)


print(f"Alice ({alice.age}) > Boris ({boris.age})? {alice > boris}") # False (ya que 'Alice' < 'Boris' por nombre) -> la comparación se realiza lexicográficamente en la tupla (nombre, edad). ('Alice', 30) < ('Boris', 25) es True. Entonces `>` será False.
# Explicación: ('Alice', 30) > ('Boris', 25) -> False, porque 'Alice' < 'Boris'.
print(f"Alice ({alice.age}) < Alice_older ({alice_older.age})? {alice < alice_older}") # True (porque el nombre es el mismo, pero la edad 30 < 35)
print(f"Galina ({galina.age}) == Alice ({alice.age})? {galina == alice}") # False (nombres diferentes)
</code></pre>
<p><strong>Nota importante:</strong> El orden de los campos es importante para <code>order=True</code>.</p>
<h4><code>unsafe_hash=False</code></h4>
<p>Si es <code>True</code>, generará un método <code>__hash__</code>. Las clases de datos no son hashables por defecto si son mutables (<code>frozen=False</code>), porque los objetos hashables deben ser inmutables. Si estás seguro de que tu clase de datos mutable solo se usará en contextos donde su hash no cambiará (¡lo cual es arriesgado!), puedes establecer <code>unsafe_hash=True</code>.
Mucho más a menudo, <code>__hash__</code> se genera automáticamente si:</p>
<ol>
<li><code>frozen=True</code>.</li>
<li><code>frozen=False</code>, pero <code>eq=True</code> y todos los campos también son hashables.</li>
</ol>
<pre class="line-numbers"><code class="language-python">@dataclass(frozen=True) # Las clases de datos congeladas son hashables
class ImmutablePoint:
    x: int
    y: int

p = ImmutablePoint(1, 2)
print(hash(p)) # Funciona

@dataclass(unsafe_hash=True) # Arriesgado si el objeto es mutable
class MutableButHashable:
    value: int

m = MutableButHashable(5)
print(hash(m))
m.value = 10
print(hash(m)) # El hash ha cambiado, lo que puede provocar problemas cuando se usa en un set/dict
</code></pre>
<h4><code>frozen=False</code></h4>
<p>Si es <code>True</code>, las instancias de la clase se vuelven inmutables. Después de crear un objeto, no podrás cambiar los valores de sus campos. Esto es útil para crear objetos inmutables que son más fáciles de usar en aplicaciones multiproceso o como claves de diccionario (si son hashables).</p>
<pre class="line-numbers"><code class="language-python">@dataclass(frozen=True)
class Coordinate:
    lat: float
    lon: float

c = Coordinate(10.0, 20.0)
# c.lat = 15.0 # AttributeError: cannot assign to field 'lat'
</code></pre>
<h4><code>kw_only=False</code> (Python 3.10+)</h4>
<p>Si es <code>True</code>, <strong>todos</strong> los campos en <code>__init__</code> se convierten en argumentos de <strong>solo palabra clave</strong>. Esto significa que debes pasar los valores de los campos por nombre, no por posición. Esto mejora la legibilidad y evita errores, especialmente cuando la clase tiene muchos campos o pueden tener los mismos tipos.</p>
<pre class="line-numbers"><code class="language-python">@dataclass(kw_only=True)
class UserConfig:
    username: str
    email: str
    is_active: bool = True
    theme: str = "dark"

# user1 = UserConfig("alice_ivanova", "alice@example.com") # TypeError: __init__() takes 0 positional arguments but 3 were given
user1 = UserConfig(username="alice_ivanova", email="alice@example.com")
print(user1)

# Puedes anular este comportamiento para un campo específico usando field(kw_only=False)
@dataclass(kw_only=True)
class MixedConfig:
    # Obligatorio solo posicional (no estilo dataclass)
    # El campo `id` no será kw_only, aunque la clase se especifica como kw_only=True
    id: int = field(kw_only=False)
    name: str = field(kw_only=False)

    # Los campos restantes son kw_only
    email: str
    age: int = 0

# Ten en cuenta que id y name se pasan posicionalmente, y el correo electrónico se pasa por nombre
mixed_config = MixedConfig(123, "Boris", email="boris@example.com")
print(mixed_config)
# mixed_config_fail = MixedConfig(id=123, name="Victor", email="viktor@example.com") # Error, id y name serían posicionales
# Este escenario es menos típico, kw_only generalmente se aplica a toda la clase
</code></pre>
<p><strong>Nota:</strong> <code>field(kw_only=False)</code> en un campo anula <code>kw_only=True</code> a nivel de clase, lo que hace que ese campo específico sea posicional. Sin embargo, la mayoría de las veces, <code>kw_only=True</code> se usa para toda la clase. El uso principal de <code>field(kw_only=True)</code> es cuando tienes una clase de datos normal (<code>kw_only=False</code> por defecto), pero quieres que <em>algunos</em> campos sean de solo palabra clave.</p>
<h4><code>slots=False</code> (Python 3.10+)</h4>
<p>Si es <code>True</code>, <code>dataclass</code> generará <code>__slots__</code> para tu clase. <code>__slots__</code> es un atributo especial que permite a Python asignar una cantidad fija de memoria para las instancias de clase, en lugar de usar un <code>__dict__</code> dinámico para almacenar atributos.</p>
<p><strong>Ventajas de <code>slots=True</code>:</strong></p>
<ul>
<li><strong>Ahorro de memoria:</strong> Reduce significativamente la cantidad de memoria consumida por cada instancia. Esto es especialmente importante para las aplicaciones que crean millones de objetos.</li>
<li><strong>Acceso más rápido a los atributos:</strong> El acceso a los atributos a través de <code>__slots__</code> puede ser un poco más rápido, ya que Python no necesita buscarlos en un diccionario.</li>
</ul>
<p><strong>Desventajas de <code>slots=True</code>:</strong></p>
<ul>
<li><strong>No se pueden agregar nuevos atributos "sobre la marcha":</strong> No podrás asignar un atributo que no se haya declarado en la clase de datos (o en los <code>__slots__</code> de una clase principal).</li>
<li><strong>Dificultades con la herencia múltiple:</strong> Puede ser difícil usar <code>__slots__</code> con herencia múltiple, especialmente si algunas clases principales no usan <code>__slots__</code> o los usan de manera diferente.</li>
<li><strong>No tiene <code>__dict__</code>:</strong> Las instancias no tendrán un atributo <code>__dict__</code> a menos que se haya agregado explícitamente a <code>__slots__</code> o a una clase principal.</li>
</ul>
<pre class="line-numbers"><code class="language-python">import sys

@dataclass
class RegularPoint:
    x: int
    y: int

@dataclass(slots=True)
class SlottedPoint:
    x: int
    y: int

rp = RegularPoint(1, 2)
sp = SlottedPoint(1, 2)

print(f"Tamaño de RegularPoint: {sys.getsizeof(rp)} bytes")
# Aproximadamente 56 bytes en Python 3.10+ (puede variar)
# print(rp.__dict__) # {'x': 1, 'y': 2} - tiene __dict__

print(f"Tamaño de SlottedPoint: {sys.getsizeof(sp)} bytes")
# Aproximadamente 32 bytes en Python 3.10+ (puede variar) - significativamente más pequeño
# print(sp.__dict__) # AttributeError: 'SlottedPoint' object has no attribute '__dict__'

# Intento de agregar un nuevo atributo a una clase de datos con ranuras
try:
    sp.z = 30
except AttributeError as e:
    print(f"Error al agregar un nuevo atributo: {e}")
</code></pre>
<p><strong>¿Cuándo usar <code>slots=True</code>?</strong>
Cuando estás creando una gran cantidad de instancias de la misma clase y el ahorro de memoria es una prioridad. Esta es una gran optimización, pero tiene sus compensaciones.</p>
<h3>La función <code>field()</code>: Configuración detallada de campos</h3>
<p>Además de los parámetros a nivel de clase, puedes configurar cada campo individualmente usando la función <code>field()</code> del módulo <code>dataclasses</code>. Esto es especialmente útil cuando necesitas una lógica más compleja para los campos que una simple anotación de tipo.</p>
<pre class="line-numbers"><code class="language-python">from dataclasses import dataclass, field
from typing import List, Dict, Any
import uuid # Para generar ID

@dataclass
class Product:
    id: str = field(default_factory=lambda: "prod-" + str(uuid.uuid4())[:8], init=False) # No inicializado a través de __init__, generado automáticamente
    name: str
    price: float = field(compare=False, metadata={'unit': 'USD', 'min_value': 0.0}) # No participa en la comparación, tiene metadatos
    tags: List[str] = field(default_factory=list, repr=False) # Usa una fábrica para una lista, no se muestra en repr
    description: str = field(default="No description available") # Valor predeterminado regular
    details: Dict[str, Any] = field(default_factory=dict, hash=False) # No participa en el hash

p = Product(name="Laptop", price=1200.0, tags=["electronics", "tech"])
print(p)
# Product(id='prod-...', name='Laptop', price=1200.0, description='No description available', details={})
# Ten en cuenta que 'tags' no está en la repr, y 'id' se generó automáticamente.

p2 = Product(name="Laptop", price=1500.0, tags=["electronics", "tech"])
print(f"p == p2? {p == p2}") # True, porque el precio no participa en la comparación (compare=False)

# p3 = Product(name="Desktop PC", price=1000.0, details={"cpu": "Intel"})
# print(hash(p3)) # TypeError: unhashable type: 'dict' (debido a details: hash=False)
# Si frozen=True, y los detalles no fueran hash=False, entonces el dict debería ser inmutable.
</code></pre>
<p>Consideremos los parámetros de <code>field()</code>:</p>
<ul>
<li><strong><code>default</code></strong>: Un valor predeterminado regular para el campo.
<pre class="line-numbers"><code class="language-python">value: int = field(default=0)
</code></pre>
</li>
<li><strong><code>default_factory</code></strong>: Una función sin argumentos que se llamará para obtener el valor predeterminado para el campo. <strong>¡Asegúrate de usar <code>default_factory</code> para valores predeterminados mutables (listas, diccionarios, objetos) para evitar problemas con el estado compartido entre instancias!</strong>
<pre class="line-numbers"><code class="language-python">items: List[str] = field(default_factory=list)
</code></pre>
</li>
<li><strong><code>init</code></strong>: Si es <code>True</code> (predeterminado), el campo se incluirá en el método <code>__init__</code> generado. Si es <code>False</code>, el campo no será un argumento en el constructor, y debes proporcionar un <code>default</code> / <code>default_factory</code> para él, o inicializarlo en <code>__post_init__</code>.
<pre class="line-numbers"><code class="language-python">import time
timestamp: float = field(init=False, default_factory=time.time)
</code></pre>
</li>
<li><strong><code>repr</code></strong>: Si es <code>True</code> (predeterminado), el campo se incluirá en el método <code>__repr__</code> generado. Útil para ocultar datos grandes o confidenciales.
<pre class="line-numbers"><code class="language-python">password: str = field(repr=False)
</code></pre>
</li>
<li><strong><code>compare</code></strong>: Si es <code>True</code> (predeterminado), el campo se incluirá en los métodos <code>__eq__</code> y <code>__order__</code> generados. Si es <code>False</code>, no afectará la comparación de objetos.
<pre class="line-numbers"><code class="language-python">version: str = field(compare=False)
</code></pre>
</li>
<li><strong><code>hash</code></strong>: Si es <code>True</code> (predeterminado), el campo se incluirá en el método <code>__hash__</code> generado. Si es <code>False</code>, no afectará el hash del objeto. Si la clase es <code>frozen=True</code>, pero algún campo tiene <code>hash=False</code>, entonces la clase no podrá generar su <code>__hash__</code> y se volverá no hashable.
<pre class="line-numbers"><code class="language-python">config: Dict[str, Any] = field(hash=False, default_factory=dict)
</code></pre>
</li>
<li><strong><code>metadata</code></strong>: Un diccionario para almacenar datos arbitrarios asociados con el campo. <code>dataclasses</code> ignora estos datos, pero pueden ser utilizados por herramientas externas (por ejemplo, para validación, serialización, generación de documentación).
<pre class="line-numbers"><code class="language-python">user_id: int = field(metadata={'help': 'Identificador de usuario único', 'validator': 'positive_int'})
</code></pre>
</li>
<li><strong><code>kw_only</code></strong>: (Python 3.10+) Si es <code>True</code>, este campo específico se convierte en un argumento de solo palabra clave en <code>__init__</code>. Si es <code>False</code>, se vuelve posicional. Esto te permite mezclar argumentos posicionales y de solo palabra clave cuando el <code>kw_only</code> de la clase es <code>False</code> por defecto.
<pre class="line-numbers"><code class="language-python">@dataclass
class FlexibleParams:
    mandatory_pos: str # Posicional
    optional_kw: int = field(default=0, kw_only=True) # Solo palabra clave

fp1 = FlexibleParams("mandatory", optional_kw=100)
# fp2 = FlexibleParams("mandatory", 200) # TypeError: __init__() takes 1 positional argument but 2 were given (optional_kw)
</code></pre>
</li>
</ul>
<h3>La función <code>fields()</code>: Introspección de Dataclass</h3>
<p>La función <code>fields()</code> del módulo <code>dataclasses</code> te permite obtener información sobre los campos de una clase de datos o su instancia. Devuelve una tupla de objetos <code>Field</code>.</p>
<pre class="line-numbers"><code class="language-python">from dataclasses import dataclass, field, fields
from typing import List

@dataclass
class Book:
    title: str
    author: str = field(metadata={'display_name': 'Autor', 'max_length': 100})
    pages: int = field(default=0, metadata={'min_value': 1})
    tags: List[str] = field(default_factory=list, repr=False)

# Obtener información sobre los campos de la clase Book
book_fields = fields(Book)

for f in book_fields:
    print(f"Nombre del campo: {f.name}")
    print(f"Tipo de campo: {f.type}")
    print(f"Valor predeterminado: {f.default}")
    print(f"Usa default_factory: {f.default_factory is not None}")
    print(f"Incluido en init: {f.init}")
    print(f"Incluido en repr: {f.repr}")
    print(f"Incluido en compare: {f.compare}")
    print(f"Incluido en hash: {f.hash}")
    print(f"Metadatos: {f.metadata}")
    print(f"Solo palabra clave: {f.kw_only}") # Para Python 3.10+
    print("-" * 20)

# Acceder a los metadatos de un campo específico:
author_field_info = next(f for f in book_fields if f.name == 'author')
print(f"Nombre para mostrar del autor: {author_field_info.metadata.get('display_name')}")
</code></pre>
<p>El objeto <code>Field</code> tiene los siguientes atributos: <code>name</code>, <code>type</code>, <code>default</code>, <code>default_factory</code>, <code>init</code>, <code>repr</code>, <code>hash</code>, <code>compare</code>, <code>metadata</code>, <code>kw_only</code>.</p>
<h3>El método <code>__post_init__</code></h3>
<p>A veces necesitas lógica adicional después de que el <code>__init__</code> automático de una clase de datos haya terminado de inicializar los campos. Para esto, puedes definir un método <code>__post_init__</code>. Se llamará inmediatamente después de <code>__init__</code>.</p>
<p>Esto es útil para:</p>
<ul>
<li>Validación de datos.</li>
<li>Calcular campos derivados basados en los ya inicializados.</li>
<li>Ejecutar cualquier otra lógica que dependa de campos completamente inicializados.</li>
</ul>
<pre class="line-numbers"><code class="language-python">import datetime

@dataclass
class User:
    first_name: str
    last_name: str
    email: str = field(init=False) # Este campo no se incluirá en los parámetros __init__
    created_at: datetime.datetime = field(default_factory=datetime.datetime.now, init=False)

    def __post_init__(self):
        print(f"--- __post_init__ iniciado para {self.first_name} {self.last_name} ---")
        # Validación
        if not self.first_name or not self.last_name:
            raise ValueError("El nombre y el apellido no pueden estar vacíos.")
        # Cálculo de un campo derivado
        self.email = f"{self.first_name.lower()}.{self.last_name.lower()}@example.com"
        print(f"Usuario {self.first_name} {self.last_name} creado con el correo electrónico: {self.email}")
        print(f"Hora de creación: {self.created_at}")
        print(f"--- __post_init__ finalizado ---")

alice_ivanova = User("Alice", "Ivanova")
print("
Objeto creado:")
print(alice_ivanova)

print("
")

try:
    victor_no_last_name = User("Victor", "")
except ValueError as e:
    print(f"Error al crear el usuario: {e}")
</code></pre>
<h3>Herencia de Dataclass</h3>
<p>Las clases de datos admiten la herencia. Los campos de las clases base se incluyen en las clases secundarias.</p>
<pre class="line-numbers"><code class="language-python">@dataclass
class Vehicle:
    make: str
    model: str

@dataclass
class Car(Vehicle):
    num_doors: int
    is_electric: bool = False

@dataclass
class ElectricCar(Car):
    battery_kwh: float

alices_car = Car("Toyota", "Camry", 4)
print(alices_car) # Car(make='Toyota', model='Camry', num_doors=4, is_electric=False)

boris_car = ElectricCar("Tesla", "Model 3", 4, True, 75.0)
print(boris_car) # ElectricCar(make='Tesla', model='Model 3', num_doors=4, is_electric=True, battery_kwh=75.0)
</code></pre>
<p><strong>Características de la herencia con <code>slots=True</code>:</strong></p>
<ul>
<li>Si la clase principal usa <code>__slots__</code>, la clase secundaria también debe usar <code>__slots__</code> para obtener el ahorro de memoria.</li>
<li>La clase secundaria debe definir sus propios <code>__slots__</code> para sus nuevos campos.</li>
<li>Si la clase secundaria no define <code>__slots__</code>, tendrá un <code>__dict__</code> además de las ranuras del padre.</li>
</ul>
<h3>¿Cuándo usar Dataclasses?</h3>
<ul>
<li><strong>Clases de contenedor de datos:</strong> Cuando el propósito principal de la clase es almacenar datos y necesitas <code>__init__</code>, <code>__repr__</code>, <code>__eq__</code> automáticos.</li>
<li><strong>Objetos inmutables:</strong> Cuando necesitas objetos cuyo estado no debe cambiar después de la creación (<code>frozen=True</code>).</li>
<li><strong>Configuraciones:</strong> Para definir la estructura de los parámetros de configuración.</li>
<li><strong>Objetos de transferencia de datos (DTO):</strong> Para transferir datos estructurados entre partes de una aplicación.</li>
<li><strong>Lógica de negocio simple:</strong> Cuando los métodos de la clase operan principalmente sobre los datos de la propia clase, no tienen un estado interno complejo ni efectos secundarios.</li>
</ul>
<h3>¿Cuándo NO usar Dataclasses?</h3>
<ul>
<li><strong>Clases con un comportamiento rico:</strong> Cuando una clase tiene una lógica de negocio compleja, muchos métodos que interactúan con sistemas externos o un estado interno complejo, es mejor usar una clase normal.</li>
<li><strong>Modelos de mapeo OR (ORM):</strong> Aunque las clases de datos pueden ser parte de un ORM, no reemplazan los modelos ORM completos, que a menudo requieren métodos específicos para trabajar con una base de datos, carga diferida, etc.</li>
<li><strong>Polimorfismo y jerarquía de herencia profunda:</strong> Si tienes una jerarquía de clases compleja con polimorfismo profundo y anulación de comportamiento, las clases normales pueden ser más flexibles.</li>
</ul>
<h3>Conclusión</h3>
<p>Las <code>dataclasses</code> son una adición potente y conveniente a Python que simplifica enormemente la creación de clases orientadas a datos. Ayudan a escribir código más limpio, legible y mantenible, y opciones como <code>slots=True</code> y <code>kw_only=True</code> brindan oportunidades adicionales para la optimización del rendimiento y la mejora de la ergonomía de la API de tu código. ¡No te olvides de <code>field()</code> para la configuración detallada de cada campo y <code>fields()</code> para la introspección!</p>