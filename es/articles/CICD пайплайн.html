<p>üöÄ <strong>CI/CD: De lo b√°sico a la producci√≥n en GCP con GitHub Actions ‚Äì Gu√≠a completa con ejemplos</strong> üöÄ</p>
<p>¬°Hola, desarrolladores! En este art√≠culo, hablar√© sobre CI/CD, un concepto.</p>
<h2>¬øQu√© es un pipeline de CI/CD en el contexto de la programaci√≥n?</h2>
<p><strong>El pipeline de CI/CD (Integraci√≥n Continua / Entrega Continua o Despliegue Continuo)</strong> es un proceso automatizado que permite a los desarrolladores entregar cambios de c√≥digo de forma r√°pida y fiable a un entorno de producci√≥n.</p>
<p>Desglosemos los conceptos clave:</p>
<p>üîß <strong>CI ‚Äî Integraci√≥n Continua</strong><br>
Esta es una pr√°ctica en la que los desarrolladores integran con frecuencia cambios en una base de c√≥digo compartida. Cada cambio de este tipo es autom√°ticamente:</p>
<ul>
<li><strong>Construido</strong> (build)</li>
<li><strong>Probado</strong> (pruebas unitarias, pruebas de integraci√≥n)</li>
<li><strong>Verificado para el cumplimiento de est√°ndares</strong> (linting, an√°lisis est√°tico)</li>
</ul>
<p>üëâ <strong>Objetivo de CI:</strong> Identificar errores en la etapa m√°s temprana, antes de que rompan algo importante o lleguen a una versi√≥n.</p>
<p>üöÄ <strong>CD ‚Äî Entrega Continua o Despliegue Continuo</strong><br>
Aqu√≠ hay dos opciones:</p>
<p>‚úÖ <strong>Entrega Continua</strong><br>
Despu√©s de pasar con √©xito la etapa de CI, los cambios autom√°ticamente:</p>
<ul>
<li>Se someten a pruebas adicionales (por ejemplo, pruebas E2E ‚Äì de extremo a extremo)</li>
<li>Se despliegan en un servidor de staging (prueba)</li>
</ul>
<p>üëâ <strong>Pero el despliegue a producci√≥n todav√≠a requiere confirmaci√≥n manual.</strong> Esto le da al equipo control sobre <em>cu√°ndo</em> exactamente los usuarios ver√°n los cambios.</p>
<p>ü§ñ <strong>Despliegue Continuo</strong><br>
Este es el siguiente paso despu√©s de la Entrega Continua. Aqu√≠, el despliegue a producci√≥n ocurre <strong>completamente autom√°ticamente</strong> si todas las etapas anteriores del pipeline (construcci√≥n, todas las pruebas) han pasado con √©xito. Este es el nivel m√°s avanzado de automatizaci√≥n.</p>
<h2>üîÑ ¬øDe qu√© suele constar un pipeline de CI/CD?</h2>
<p>Un pipeline t√≠pico incluye las siguientes etapas:</p>
<ol>
<li><strong>Checkout</strong> ‚Äî Clonaci√≥n de la √∫ltima versi√≥n del c√≥digo del repositorio.</li>
<li><strong>Build</strong> ‚Äî Construcci√≥n del proyecto (compilaci√≥n, ensamblaje de artefactos, im√°genes Docker).</li>
<li><strong>Test</strong> ‚Äî Ejecuci√≥n de varios tipos de pruebas (unitarias, de integraci√≥n, E2E).</li>
<li><strong>Lint/Code Quality</strong> ‚Äî Verificaci√≥n del c√≥digo para el cumplimiento del estilo y posibles errores utilizando analizadores est√°ticos.</li>
<li><strong>Deploy</strong> ‚Äî Despliegue de la aplicaci√≥n (a un servidor de staging o producci√≥n).</li>
<li><strong>Notify</strong> ‚Äî Env√≠o de notificaciones sobre el estado del pipeline al equipo (por ejemplo, Slack, correo electr√≥nico).</li>
</ol>
<h2>üõ† Herramientas populares de CI/CD:</h2>
<ul>
<li><strong>GitHub Actions</strong> (¬°nuestro enfoque hoy!)</li>
<li>GitLab CI/CD</li>
<li>Jenkins</li>
<li>CircleCI</li>
<li>Bitbucket Pipelines</li>
<li>Azure DevOps</li>
<li>TeamCity</li>
</ul>
<h2>üß† ¬øPor qu√© necesitamos CI/CD?</h2>
<ul>
<li><strong>Reduce el error humano:</strong> La automatizaci√≥n elimina los errores asociados con las operaciones manuales.</li>
<li><strong>Detecci√≥n r√°pida de errores:</strong> Los errores se encuentran antes, lo que los hace m√°s f√°ciles y econ√≥micos de corregir.</li>
<li><strong>Automatizaci√≥n de tareas rutinarias:</strong> Los desarrolladores dedican menos tiempo a la construcci√≥n y el despliegue, y m√°s a la codificaci√≥n.</li>
<li><strong>Mejora de la calidad del c√≥digo:</strong> Las comprobaciones y pruebas continuas elevan el nivel general de calidad.</li>
<li><strong>Entrega r√°pida de caracter√≠sticas a los usuarios:</strong> Las nuevas funcionalidades llegan al usuario final m√°s r√°pido y con mayor frecuencia.</li>
</ul>
<h2>üì¶ Ejemplos sencillos de CI/CD con GitHub Actions</h2>
<p>Veamos pipelines b√°sicos para tecnolog√≠as populares. Todos los ejemplos utilizan GitHub Actions y se guardan en el directorio <code>.github/workflows/</code> de su proyecto.</p>
<h3>üêç CI/CD para Python (con <code>pytest</code> y <code>flake8</code>)</h3>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/python-ci.yml
name: Python CI

on: [push, pull_request]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11' # Especifique su versi√≥n

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt # Aseg√∫rese de tener requirements.txt
          pip install flake8 pytest

      - name: Lint with flake8
        run: |
          # Comprobar c√≥digo en las carpetas src y tests (adaptar a su proyecto)
          flake8 src tests

      - name: Run tests
        run: |
          pytest
</code></pre>
<h3>üåê CI/CD para Node.js (con <code>npm test</code> y <code>eslint</code>)</h3>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/node-ci.yml
name: Node.js CI

on: [push, pull_request]

jobs:
  build:
    runs-on: ubuntu-latest

    strategy:
      matrix:
        node-version: [18.x] # Especifique su versi√≥n de Node.js

    steps:
      - uses: actions/checkout@v3

      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}

      - name: Install dependencies
        run: npm install # o npm ci para una instalaci√≥n m√°s predecible

      - name: Lint with ESLint
        run: npx eslint . # Aseg√∫rese de que ESLint est√© configurado en el proyecto

      - name: Run tests
        run: npm test
</code></pre>
<h3>üê≥ CI/CD para Docker (construcci√≥n y push a Docker Hub)</h3>
<p>Para este ejemplo, necesitar√° los secretos <code>DOCKER_USERNAME</code> y <code>DOCKER_PASSWORD</code> (o token) en la configuraci√≥n de su repositorio de GitHub (<code>Settings -> Secrets and variables -> Actions</code>).</p>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/docker-ci.yml
name: Docker CI/CD

on:
  push:
    branches: [ main ] # Ejecutar solo para la rama main

jobs:
  docker:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Log in to Docker Hub
        run: echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin

      - name: Build Docker image
        # Reemplace myapp con el nombre de su aplicaci√≥n
        run: docker build -t ${{ secrets.DOCKER_USERNAME }}/myapp:latest .

      - name: Push Docker image
        run: docker push ${{ secrets.DOCKER_USERNAME }}/myapp:latest
</code></pre>
<h2>üöö Despliegue en plataformas populares</h2>
<p>Ahora que tenemos artefactos construidos y probados (por ejemplo, una imagen Docker), veamos c√≥mo se pueden desplegar.</p>
<h3>üü£ Despliegue en Heroku</h3>
<p><strong>üîê Secretos de GitHub:</strong> <code>HEROKU_API_KEY</code>, <code>HEROKU_APP_NAME</code>.</p>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/deploy-heroku.yml
name: Deploy to Heroku

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Install Heroku CLI
        run: curl https://cli-assets.heroku.com/install.sh | sh
      - name: Login to Heroku
        env:
          HEROKU_API_KEY: ${{ secrets.HEROKU_API_KEY }}
        run: heroku auth:token
      - name: Deploy to Heroku
        env:
          HEROKU_API_KEY: ${{ secrets.HEROKU_API_KEY }}
        run: |
          heroku git:remote -a ${{ secrets.HEROKU_APP_NAME }}
          git push heroku main -f # Tenga cuidado con -f (force push)
</code></pre>
<p>Si est√° desplegando una imagen Docker en Heroku:</p>
<pre class="line-numbers"><code class="language-yaml"># ... (pasos de construcci√≥n y login en Docker Hub/GHCR de ejemplos anteriores) ...
# deploy:
#   name: Deploy to Heroku
#   needs: build # Depende del trabajo de construcci√≥n de la imagen
#   runs-on: ubuntu-latest
#   steps:
#     # ...
#     - name: Login to Heroku container registry
#       run: echo "${{ secrets.HEROKU_API_KEY }}" | docker login --username=_ --password-stdin registry.heroku.com
#     - name: Tag image for Heroku
#       # Suponiendo que la imagen se construye como ghcr.io/username/repo/myapp:latest
#       run: docker tag ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}/myapp:latest registry.heroku.com/${{ secrets.HEROKU_APP_NAME }}/web
#     - name: Push image to Heroku
#       run: docker push registry.heroku.com/${{ secrets.HEROKU_APP_NAME }}/web
#     - name: Release Heroku App
#       env:
#         HEROKU_API_KEY: ${{ secrets.HEROKU_API_KEY }}
#       run: heroku container:release web --app ${{ secrets.HEROKU_APP_NAME }}
</code></pre>
<h3>üü® Despliegue en AWS (por ejemplo, archivos est√°ticos en S3)</h3>
<p><strong>üîê Secretos de GitHub:</strong> <code>AWS_ACCESS_KEY_ID</code>, <code>AWS_SECRET_ACCESS_KEY</code>, <code>AWS_REGION</code>, <code>S3_BUCKET_NAME</code>.</p>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/deploy-aws-s3.yml
name: Deploy Static Site to AWS S3

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
      - name: Sync files to S3
        # Reemplace ./public con la ruta a sus archivos est√°ticos
        run: aws s3 sync ./public s3://${{ secrets.S3_BUCKET_NAME }} --delete
</code></pre>
<p>Para el despliegue en <strong>AWS Elastic Beanstalk</strong>, normalmente se utiliza la CLI de EB, el pipeline ser√° similar, pero con comandos <code>eb deploy</code>.</p>
<h3>üîµ Despliegue en Google Cloud Platform (GCP App Engine)</h3>
<p><strong>üîê Secretos de GitHub:</strong> <code>GCP_CREDENTIALS</code> (clave JSON de la cuenta de servicio), <code>GCP_PROJECT_ID</code>.</p>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/deploy-gcp-app-engine.yml
name: Deploy to GCP App Engine

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ secrets.GCP_PROJECT_ID }}
          service_account_key: ${{ secrets.GCP_CREDENTIALS }}
          export_default_credentials: true
      - name: Deploy to App Engine
        # Aseg√∫rese de tener app.yaml en la ra√≠z del proyecto
        run: gcloud app deploy --quiet
</code></pre>
<h3>üü™ Despliegue en Render.com</h3>
<p>Render a menudo despliega autom√°ticamente al hacer push a GitHub si el repositorio est√° conectado. Pero para un disparador manual (o como parte de un pipeline m√°s complejo), puede usar un Hook de Despliegue.<br>
<strong>üîê Secretos de GitHub:</strong> <code>RENDER_DEPLOY_HOOK</code> (URL obtenida de la configuraci√≥n del servicio de Render).</p>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/deploy-render.yml
name: Trigger Render Deploy

on:
  workflow_dispatch: # Disparador manual desde la UI de GitHub

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Trigger Render Deploy Hook
        run: curl -X POST ${{ secrets.RENDER_DEPLOY_HOOK }}
</code></pre>
<h2>üåü CI/CD Avanzado: Construir Docker ‚Üí Push a GHCR ‚Üí Staging/Producci√≥n en GCP Cloud Run</h2>
<p>¬°Y ahora la guinda del pastel! Construyamos un pipeline avanzado:</p>
<ol>
<li>Construir imagen Docker.</li>
<li>Publicar imagen en GitHub Container Registry (ghcr.io).</li>
<li>Despliegue autom√°tico en el entorno de <strong>staging</strong> en GCP Cloud Run.</li>
<li>Despliegue en el entorno de <strong>producci√≥n</strong> en GCP Cloud Run <strong>despu√©s de la confirmaci√≥n manual</strong>.</li>
</ol>
<p>Para esto, necesitaremos varios archivos de flujo de trabajo.</p>
<p><strong>Secretos de GitHub requeridos:</strong></p>
<ul>
<li><code>GCP_PROJECT_ID</code>: ID de su proyecto de GCP.</li>
<li><code>GCP_CREDENTIALS</code>: Clave JSON de la cuenta de servicio de GCP con permisos para desplegar en Cloud Run y acceder a GHCR (si es necesario). Normalmente <code>GITHUB_TOKEN</code> es suficiente para el acceso a GHCR desde Actions.</li>
<li><code>GCP_REGION</code>: Regi√≥n para Cloud Run (por ejemplo, <code>europe-west1</code>).</li>
</ul>
<h3>1. Construir y publicar imagen Docker en GHCR</h3>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/build.yml
name: Build & Push to GHCR

on:
  push:
    branches: [main] # Ejecutar en push a main

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read      # Para checkout
      packages: write     # Para push a GHCR

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}/myapp:latest
          # Puede agregar etiquetado por SHA de commit para unicidad:
          # tags: |
          #   ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}/myapp:latest
          #   ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}/myapp:${{ github.sha }}
</code></pre>
<ul>
<li><code>github.repository_owner</code>: Propietario del repositorio (su nombre de usuario u organizaci√≥n).</li>
<li><code>github.event.repository.name</code>: Nombre del repositorio.</li>
<li><code>myapp</code>: Nombre de su aplicaci√≥n/imagen.</li>
</ul>
<h3>2. Despliegue autom√°tico en Staging (GCP Cloud Run)</h3>
<p>Este flujo de trabajo se ejecutar√° autom√°ticamente despu√©s de que `build.yml` se complete con √©xito.</p>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/deploy-staging.yml
name: Deploy to GCP Cloud Run (Staging)

on:
  workflow_run:
    workflows: ["Build & Push to GHCR"] # Nombre del flujo de trabajo de construcci√≥n
    types:
      - completed

jobs:
  deploy-staging:
    runs-on: ubuntu-latest
    # Ejecutar solo si el flujo de trabajo de construcci√≥n se complet√≥ con √©xito
    if: ${{ github.event.workflow_run.conclusion == 'success' }}

    # Usar entornos de GitHub para staging (opcional, pero buena pr√°ctica)
    environment:
      name: staging
      url: ${{ steps.deploy.outputs.url }} # La URL estar√° disponible despu√©s del despliegue

    steps:
      - uses: actions/checkout@v3 # Necesario si usa configuraciones del repositorio

      - id: 'auth'
        uses: 'google-github-actions/auth@v2'
        with:
          credentials_json: '${{ secrets.GCP_CREDENTIALS }}'

      - name: 'Deploy to Cloud Run (Staging)'
        id: deploy
        uses: 'google-github-actions/deploy-cloudrun@v2'
        with:
          service: 'myapp-staging' # Nombre de su servicio de staging de Cloud Run
          region: '${{ secrets.GCP_REGION }}'
          # Usar la imagen que se subi√≥ en build.yml
          image: 'ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}/myapp:latest'
          project_id: '${{ secrets.GCP_PROJECT_ID }}'
          flags: '--allow-unauthenticated --platform=managed' # Permitir acceso no autenticado para el ejemplo
</code></pre>
<h3>3. Despliegue en Producci√≥n con confirmaci√≥n manual (GCP Cloud Run)</h3>
<p>Este flujo de trabajo se activa manualmente a trav√©s de la UI de GitHub Actions.</p>
<pre class="line-numbers"><code class="language-yaml"># .github/workflows/deploy-prod.yml
name: Deploy to GCP Cloud Run (Production)

on:
  workflow_dispatch: # Permite el disparador manual

jobs:
  deploy-production:
    runs-on: ubuntu-latest

    environment:
      name: production
      url: ${{ steps.deploy.outputs.url }}

    steps:
      - uses: actions/checkout@v3

      - id: 'auth'
        uses: 'google-github-actions/auth@v2'
        with:
          credentials_json: '${{ secrets.GCP_CREDENTIALS }}'

      - name: 'Deploy to Cloud Run (Production)'
        id: deploy
        uses: 'google-github-actions/deploy-cloudrun@v2'
        with:
          service: 'myapp-production' # Nombre de su servicio de producci√≥n
          region: '${{ secrets.GCP_REGION }}'
          image: 'ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}/myapp:latest' # Usar la misma imagen 'latest'
          project_id: '${{ secrets.GCP_PROJECT_ID }}'
          flags: '--allow-unauthenticated --platform=managed'
          # Para producci√≥n, puede agregar --no-traffic y luego cambiar el tr√°fico gradualmente
          # traffic:
          #   latest: true
          #   percent: 100
</code></pre>
<p><strong>Puntos importantes de este pipeline avanzado:</strong></p>
<ul>
<li><strong>GitHub Container Registry (ghcr.io):</strong> Lo usamos para almacenar im√°genes Docker. Esto es conveniente ya que est√° estrechamente integrado con GitHub Actions.</li>
<li><strong><code>workflow_run</code>:</strong> Permite que un flujo de trabajo (despliegue de staging) se active al finalizar otro (construcci√≥n).</li>
<li><strong><code>workflow_dispatch</code>:</strong> Proporciona la capacidad de activar manualmente un flujo de trabajo (despliegue de producci√≥n), lo que garantiza el control.</li>
<li><strong>GitHub Environments:</strong> Le permiten configurar reglas de protecci√≥n para producci√≥n (por ejemplo, requerir la aprobaci√≥n de revisores espec√≠ficos) y almacenar secretos espec√≠ficos del entorno.</li>
<li><strong>GCP Cloud Run:</strong> Una excelente opci√≥n sin servidor para ejecutar aplicaciones en contenedores.</li>
</ul>
<h3>üîê Seguridad ‚Äì ¬°es importante!</h3>
<ul>
<li><strong>Use Secretos de GitHub:</strong> Nunca almacene tokens, contrase√±as, claves API directamente en archivos YAML. Use `Settings -> Secrets and variables -> Actions` en su repositorio.</li>
<li><strong>Privilegios m√≠nimos:</strong> Para las cuentas de servicio (por ejemplo, GCP), otorgue solo los permisos estrictamente necesarios para realizar tareas de CI/CD.</li>
<li><strong>Aislar entornos:</strong> Staging y Producci√≥n deben estar lo m√°s aislados posible. Diferentes proyectos/cuentas en proveedores de la nube son una buena pr√°ctica.</li>
<li><strong>Protecci√≥n de ramas:</strong> Configure la protecci√≥n para la rama `main` (o `master`) para que los pushes a ella solo sean posibles a trav√©s de Pull Requests con comprobaciones de CI obligatorias.
