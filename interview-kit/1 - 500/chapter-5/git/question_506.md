### `question_506.md`

**Вопрос 506.** Вы отправили важный коммит в общий удаленный репозиторий (`git push`), но позже обнаружили в нем ошибку. Какой командой следует "отменить" изменения этого коммита, сохранив при этом историю безопасной и понятной для всей команды?

A. Использовать команду `git revert <commit_hash>`, которая создаст новый коммит, отменяющий изменения указанного коммита, и при этом не изменяет существующую историю.
B. Использовать `git reset --hard HEAD~1`, чтобы удалить ошибочный коммит, а затем принудительно отправить изменения с помощью `git push --force`.
C. Использовать `git commit --amend`, чтобы исправить ошибку и перезаписать последний коммит, после чего отправить его с помощью `git push --force`.
D. Использовать команду `git delete commit <commit_hash>`, которая безопасно удаляет коммит из истории как локально, так и удаленно.

**Правильный ответ: A**

**Объяснение:**

Когда "плохой" коммит уже попал в общий репозиторий, перезапись истории (которую делают `git reset` и `git commit --amend`) становится очень опасной, так как это может привести к серьезным проблемам у других членов команды, которые уже могли получить этот коммит. Для безопасной отмены изменений в таких случаях предназначена команда `git revert`.

*   **`git revert <commit_hash>`**: Эта команда не удаляет и не изменяет существующую историю. Вместо этого она анализирует указанный коммит и создает **новый коммит**, который является его точной противоположностью. Если старый коммит добавлял строку, `revert`-коммит ее удалит. Если удалял — добавит обратно.
*   **Безопасность и прозрачность:** Так как `revert` просто добавляет новый коммит, история проекта остается целостной и понятной. Все видят, что был сделан ошибочный коммит, а затем был сделан коммит, который его исправляет.

**Разбор вариантов:**
*   **A.** Верно. `git revert` — это стандартный и безопасный способ отмены изменений в общих ветках.
*   **B.** Неверно. Это **крайне опасная практика** для общих веток. `git reset --hard` и `git push --force` переписывают историю, что может сломать репозитории у ваших коллег и привести к потере данных.
*   **C.** Неверно. `git commit --amend` также переписывает историю и применим только к самому последнему коммиту. Использовать его для уже опубликованных коммитов так же опасно, как и `reset`.
*   **D.** Неверно. Команды `git delete commit` не существует в Git. Это вымышленный вариант.

*   **Ключевой аспект 1: Сохранение истории vs. Перезапись истории:** `git revert` добавляет новые коммиты (сохраняет историю), в то время как `git reset` и `git commit --amend` удаляют или изменяют существующие (перезаписывают историю).
*   **Ключевой аспект 2: Публичная vs. Локальная история:** Правило гласит: безопасно перезаписывать только ту историю, которая еще не была опубликована (не была отправлена через `push`). Для опубликованной истории следует использовать `git revert`.

**Пример:**

```bash
# Допустим, история коммитов выглядит так:
# c1a2b3d - (HEAD -> main, origin/main) Fix a critical bug
# e4f5g6h - Add new feature (этот коммит с ошибкой)
# a9b8c7d - Initial commit

# Мы хотим отменить коммит e4f5g6h.
git revert e4f5g6h

# Git создаст новый коммит. Откроется редактор для ввода сообщения, по умолчанию "Revert 'Add new feature'".
# После сохранения сообщения история будет выглядеть так:
# 9h8g7f6 - (HEAD -> main) Revert "Add new feature"
# c1a2b3d - Fix a critical bug
# e4f5g6h - Add new feature (остался в истории)
# a9b8c7d - Initial commit

# Теперь можно безопасно отправить изменения
git push origin main
```

**В результате:**

`git revert` является стандартным и безопасным способом отмены изменений в общем репозитории, так как он создает новый коммит, обратный ошибочному, не нарушая уже существующую историю коммитов.

Таким образом, вариант A является правильным.