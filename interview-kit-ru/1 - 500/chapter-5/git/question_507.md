### `question_507.md`

**Вопрос 507.** Для чего предназначена команда `git cherry-pick` и в каком сценарии ее использование будет наиболее оправданным?

A. Она применяет один или несколько выбранных коммитов из одной ветки в другую. Это особенно полезно для переноса конкретных исправлений (hotfix) без необходимости слияния всей ветки.
B. Она переносит все коммиты из текущей ветки поверх другой, создавая линейную и чистую историю коммитов.
C. Она создает специальный "коммит слияния", который включает в себя изменения только из одного указанного коммита другой ветки.
D. Она используется для сравнения содержимого одного конкретного коммита с файлами в текущем рабочем каталоге.

**Правильный ответ: A**

**Объяснение:**

Команда `git cherry-pick` (в переводе "срывать вишенку") — это мощный инструмент, который позволяет точечно применять изменения из конкретных коммитов. Она берет указанный коммит из любой ветки и применяет его в виде **нового коммита** поверх текущей ветки, в которой вы находитесь.

*   **Основное предназначение:** Вместо того чтобы сливать целую ветку со всеми ее коммитами, `cherry-pick` позволяет вам выбрать только те "вишенки" (коммиты), которые вам нужны.

*   **Типичный сценарий использования:**
    1.  **Hotfix:** Разработчик находит и исправляет баг в своей `feature`-ветке. Этот фикс нужен в основной ветке `main` немедленно, но вся остальная `feature`-ветка еще не готова к слиянию. С помощью `git cherry-pick` можно взять только коммит с исправлением бага и применить его к `main`.
    2.  **Перенос небольшой функциональности:** В одной ветке была реализована полезная утилитарная функция. Другой ветке нужна эта же функция, но не все остальные изменения из первой ветки. Коммит с этой функцией можно "перенести" с помощью `cherry-pick`.

**Разбор вариантов:**
*   **A.** Верно. Это точное описание работы и основного предназначения команды.
*   **B.** Неверно. Это описание команды `git rebase`.
*   **C.** Неверно. `cherry-pick` не создает коммитов слияния; он создает обычный, новый коммит, который является копией выбранного.
*   **D.** Неверно. Для сравнения коммита с рабочим каталогом используется команда `git diff <commit_hash>`.

*   **Ключевой аспект 1: Точечное применение:** В отличие от `merge` или `rebase`, которые работают с целыми ветками, `cherry-pick` работает с отдельными коммитами.
*   **Ключевой аспект 2: Создание нового коммита:** Важно понимать, что `cherry-pick` не "перемещает" коммит, а создает его копию. У нового коммита будет новый хеш, но тот же автор, дата и сообщение (если не указано иное).

**Пример:**

```bash
# Представим, что история выглядит так:
# a1b2c3d - (feature) Add documentation
# e4f5g6h - (feature) Fix critical bug # <- Этот коммит нам нужен
# c7d8e9f - (feature) Start new feature
# |
# 9h8g7f6 - (HEAD -> main, origin/main) Last stable commit

# Нам нужно перенести коммит e4f5g6h в ветку main.

# 1. Убедимся, что мы в ветке main
git checkout main

# 2. Применяем нужный коммит по его хешу
git cherry-pick e4f5g6h

# 3. История main теперь будет выглядеть так:
# f9e8d7c - (HEAD -> main) Fix critical bug # <- Новый коммит с теми же изменениями
# 9h8g7f6 - (origin/main) Last stable commit
```

**В результате:**

`git cherry-pick` позволяет выборочно применять коммиты из других веток, что идеально подходит для переноса срочных исправлений или небольших изолированных частей функциональности.

Таким образом, вариант A является правильным.