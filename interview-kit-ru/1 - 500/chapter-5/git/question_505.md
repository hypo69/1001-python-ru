### `question_505.md`

**Вопрос 505.** Вы работаете над задачей в своей ветке, и у вас есть несколько измененных, но еще не готовых к коммиту файлов. Внезапно вас просят срочно исправить критический баг в ветке `main`. Какой из следующих подходов является наиболее правильным и стандартным для временного сохранения вашей текущей работы, переключения на другую ветку и последующего возвращения к своим изменениям?

A. Использовать команду `git stash`, чтобы временно сохранить все отслеживаемые измененные файлы, переключиться на ветку `main`, а после исправления бага вернуться в свою ветку и применить изменения командой `git stash pop`.
B. Создать временный коммит с сообщением "WIP" (Work In Progress), переключиться на `main`, а по возвращении отменить этот коммит командой `git reset --soft HEAD~1`, чтобы вернуть изменения в рабочий каталог.
C. Использовать команду `git checkout -f main` для принудительного переключения на ветку `main`, что автоматически сохранит ваши изменения для последующего восстановления.
D. Скопировать измененные файлы в другую папку на компьютере, отменить все локальные изменения командой `git reset --hard`, а после исправления бага скопировать файлы обратно.

**Правильный ответ: A**

**Объяснение:**

Для решения именно такой задачи в Git существует специальный механизм — `git stash` (в переводе "спрятать" или "заначка"). Он позволяет временно сохранить все изменения в отслеживаемых файлах, которые еще не были закоммичены, возвращая ваш рабочий каталог в "чистое" состояние (соответствующее последнему коммиту `HEAD`).

*   **`git stash`**: Эта команда берет ваши измененные отслеживаемые файлы и незавершенные проиндексированные изменения и сохраняет их в специальном стеке. После этого ваш рабочий каталог становится чистым.
*   **`git stash pop`**: После того как вы закончили срочную работу и вернулись в свою ветку, эта команда берет последние сохраненные изменения из стека `stash` и применяет их к вашему рабочему каталогу, одновременно удаляя их из стека.

**Разбор вариантов:**
*   **A.** Верно. Это стандартный, безопасный и наиболее эффективный способ решения данной проблемы, для которого и был создан `git stash`.
*   **B.** Неверно. Хотя этот подход технически возможен, он считается плохой практикой. Он создает "грязные", неполноценные коммиты в истории, которые потом приходится удалять, что усложняет историю проекта.
*   **C.** Неверно. Этот вариант очень опасен. Флаг `-f` (или `--force`) при переключении веток **отбросит все ваши локальные изменения безвозвратно**. Они не будут сохранены.
*   **D.** Неверно. Это "ручной" и крайне неэффективный способ, который полностью игнорирует встроенные возможности Git. Он подвержен ошибкам (можно забыть скопировать файл) и не является версионируемым.

*   **Ключевой аспект 1: Чистый рабочий каталог:** Git не позволяет переключаться между ветками, если у вас есть незакоммиченные изменения, которые могут конфликтовать с веткой назначения. `git stash` решает эту проблему, временно "очищая" ваш каталог.
*   **Ключевой аспект 2: Стек изменений:** `git stash` может хранить несколько наборов изменений в виде стека. Вы можете просмотреть их с помощью `git stash list` и применить не только последний, но и любой другой.

**Пример:**

```bash
# Вы находитесь в ветке feature и изменили файл
# git status покажет "Changes not staged for commit: modified: my_file.txt"

# 1. Прячем изменения
git stash
# Вывод: Saved working directory and index state WIP on feature: ...

# Теперь рабочий каталог чист, можно переключаться
# 2. Переключаемся на main, исправляем баг, делаем коммит
git checkout main
# ... (работа с багом)
git commit -am "Fix critical bug"

# 3. Возвращаемся в нашу ветку
git checkout feature

# 4. Восстанавливаем нашу работу
git stash pop
# Ваши изменения из my_file.txt снова в рабочем каталоге.
```

**В результате:**

`git stash` является идиоматичным и безопасным инструментом в Git для временного сохранения незавершенной работы при необходимости срочного переключения контекста.

Таким образом, вариант A является правильным.