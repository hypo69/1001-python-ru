### `question_003.md`

**שאלה 3.** מהן ההשלכות של שימוש בארגומנטים ברירת מחדל משתנים (mutable) בהגדרות פונקציה בפייתון, במיוחד בהקשר של שימור אובייקט הפונקציה על פני קריאות מרובות?

- A. ארגומנטים ברירת מחדל משתנים הם יתרון מכיוון שהם מאפשרים לעדכן ולשמור את ערכי ברירת המחדל של הפונקציה על פני קריאות מרובות, ובכך לשקף את השינויים האחרונים.
- B. שימוש בארגומנטים ברירת מחדל משתנים עלול להוביל להתנהגות בלתי צפויה או לשגיאות, מכיוון ששינויים בארגומנטים אלה נשמרים בקריאות עוקבות לפונקציה אם לא אופסו במפורש.
- C. ארגומנטים ברירת מחדל שאינם משתנים (immutable), בניגוד למשתנים, מאטים משמעותית את ביצוע הפונקציה, ומאלצים את פייתון ליצור מחדש את ערך ברירת המחדל בכל קריאה לפונקציה.
- D. ארגומנטים ברירת מחדל משתנים מונעים דליפות זיכרון על ידי איפוס אוטומטי של מצב הפונקציה לאחר כל קריאה, ובכך מבטיחים שלא יישמרו נתונים שיוריים.

**תשובה נכונה: B**

**הסבר:**

שימוש באובייקטים משתנים (כגון רשימות או מילונים) כערכי ברירת מחדל לפרמטרים של פונקציות בפייתון עלול להוביל להתנהגות לא אינטואיטיבית. הבעיה נעוצה בכך שערכי ברירת המחדל מחושבים רק *פעם אחת*, בעת הגדרת הפונקציה, ולא בכל פעם שהיא נקראת. כתוצאה מכך, אותו אובייקט משתנה משמש כברירת מחדל בכל הקריאות, מה שעלול להוביל לתוצאות בלתי צפויות כאשר הפונקציה משנה את ערך ברירת המחדל הזה.

*   **אפשרות A** אינה נכונה: שינויים בערכי ברירת מחדל משתנים נשמרים בין קריאות, ולא מתעדכנים. זו הסיבה לבעיות, לא יתרון.
*   **אפשרות B** נכונה: זהו תיאור מדויק של הבעיה: שינויים בערכי ברירת המחדל נשמרים בקריאות עתידיות לפונקציה, מה שעלול להוביל לשגיאות.
*   **אפשרות C** אינה נכונה: ערכי ברירת מחדל שאינם משתנים (כגון מספרים, מחרוזות, טאפלים) אינם גורמים לבעיות של שימור מצב.
*   **אפשרות D** אינה נכונה: ערכי ברירת מחדל משתנים הם דווקא אלה שעלולים להוביל לדליפות זיכרון.

**דוגמה:**

```python
def append_to_list(item: int, my_list: list[int] = []):
    """מוסיף פריט לרשימה, תוך שימוש בארגומנט ברירת מחדל משתנה."""
    my_list.append(item)
    print(my_list)


append_to_list(1)       # פלט: [1]
append_to_list(2)       # פלט: [1, 2] (באופן לא צפוי!)
append_to_list(3, [])   # פלט: [3] (תקין, רשימה חדשה הועברה במפורש)
append_to_list(4)       # פלט: [1, 2, 4] (באופן לא צפוי!)
```

**כתוצאה מכך:**

*   בקריאה הראשונה לפונקציה `append_to_list(1)`, נוצרת רשימה `[]`, והמספר `1` מתווסף אליה, והפלט הוא `[1]`.
*   בקריאה השנייה `append_to_list(2)`, **נעשה שימוש באותה הרשימה שנוצרה קודם לכן**, ולכן `2` מתווסף אליה, והפלט הוא `[1, 2]`.
*   בקריאה `append_to_list(3, [])`, מועברת לפונקציה רשימה חדשה, ואין שימוש בערך ברירת המחדל, והפלט הוא `[3]`.
*   בקריאה האחרונה, שוב נעשה שימוש ברשימה הישנה מהקריאות הראשונות, ויתווסף אליה המספר 4.

כדי להימנע מבעיה זו, נהוג להשתמש בערך `None` כברירת מחדל ולבצע בדיקה ל-`None` בתוך הפונקציה:
```python
def append_to_list_correct(item: int, my_list: list[int] | None = None):
    """מוסיף פריט לרשימה, תוך שימוש ב-None כארגומנט ברירת מחדל."""
    if my_list is None:
        my_list = []
    my_list.append(item)
    print(my_list)
append_to_list_correct(1)
append_to_list_correct(2)
append_to_list_correct(3,[])
append_to_list_correct(4)
# פלט:
# [1]
# [2]
# [3]
# [4]
```

לפיכך, **אפשרות B** היא הנכונה, מכיוון שהיא מתארת במדויק את הבעיה ואת השלכותיה.