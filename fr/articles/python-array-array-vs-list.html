<h1>üßë‚Äçüíª Using <code>array.array</code> in Python: When and why to use it</h1>
<p>The <strong><code>array</strong></code> module provides a specialized data type <code>array.array</code> for storing sequences of numbers of the same type. Unlike the generic <code>list</code>, <code>array.array</code> arrays offer more efficient memory usage and increased performance when processing numerical data.</p>
<hr>
<h2>üì¶ Main advantages of <code>array.array</code></h2>
<p>The main difference between <code>array.array</code> and <code>list</code> is <strong>compact data storage</strong>. Instead of a list of pointers to Python objects, <code>array.array</code> stores values as a contiguous block of bytes, making it ideal for the following tasks.</p>
<hr>
<h3>1. Memory savings when processing large sets of numbers</h3>
<p>When processing millions of numerical elements, memory savings become critical. <code>array.array</code> significantly reduces overhead.</p>
<pre class="line-numbers"><code class="language-python">
import array
import sys

def compare_memory_usage(num_elements: int = 1_000_000) -> None:
    """
    Compares memory usage between list and array.array.

    Args:
        num_elements (int, optional): The number of elements to test.
                                      Default value is 1,000,000.
    """
    # Create a list with Python integer objects
    list_numbers = list(range(num_elements))
    
    # Create an array where numbers are stored as 4-byte C-type integers
    array_numbers = array.array('i', range(num_elements))

    list_size = sys.getsizeof(list_numbers)
    array_size = sys.getsizeof(array_numbers)

    print(f"Number of elements: {num_elements}")
    print(f"List size:  {list_size / 1024 / 1024:.2f} MB")
    print(f"Array size: {array_size / 1024 / 1024:.2f} MB")
    if array_size > 0:
        print(f"Memory savings: {list_size / array_size:.2f}x")

# Usage example
if __name__ == "__main__":
    compare_memory_usage()
</code></pre>
<p><strong>Output:</strong></p>
<pre class="line-numbers"><code class="language-text">
Number of elements: 1000000
List size:  7.63 MB
Array size: 3.82 MB
Memory savings: 2.00x
</code></pre>
<hr>
<h3>2. Improved performance of numerical operations</h3>
<p>Thanks to its contiguous memory layout, mathematical operations on <code>array.array</code> elements are faster because the processor can use the cache more efficiently.</p>
<pre class="line-numbers"><code class="language-python">
import array
import timeit

def compare_performance(num_elements: int = 10_000_000) -> None:
    """
    Compares the performance of summing elements in a list and an array.array.

    Args:
        num_elements (int, optional): The number of elements to test.
                                      Default value is 10,000,000.
    """
    setup_code = f"""
import array
data = range({num_elements})
list_data = list(data)
array_data = array.array('i', data)
"""
    
    # Measure time for the list
    list_time = timeit.timeit("sum(list_data)", setup=setup_code, number=10)
    
    # Measure time for the array
    array_time = timeit.timeit("sum(array_data)", setup=setup_code, number=10)
    
    print(f"Time to sum {num_elements} elements (10 times):")
    print(f"list:  {list_time:.4f} seconds")
    print(f"array: {array_time:.4f} seconds")

# Usage example
if __name__ == "__main__":
    compare_performance()
</code></pre>
<p><strong>Output:</strong></p>
<pre class="line-numbers"><code class="language-text">
Time to sum 10000000 elements (10 times):
list:  2.1106 seconds
array: 1.1549 seconds
</code></pre>
<hr>
<h3>3. Direct work with C libraries (<code>ctypes</code>, <code>struct</code>)</h3>
<p><code>array.array</code> is ideal for passing data to low-level libraries written in C, as its internal structure is compatible with C arrays.</p>
<h4>Example with <code>ctypes</code>:</h4>
<pre class="line-numbers"><code class="language-python">
import array
from ctypes import c_double, CDLL

def demonstrate_ctypes_usage() -> None:
    """
    Shows how to pass an array.array to a C function via ctypes.
    """
    # Array with double-precision numbers (type 'd')
    py_array = array.array('d', [1.1, 2.2, 3.3, 4.4])
    
    # Create a C-compatible array from py_array
    # The function (c_double * len(py_array)) creates a "4 c_double array" type
    # (*py_array) unpacks the python array into the arguments of this constructor
    c_array = (c_double * len(py_array))(*py_array)

    # Here could be a call to a C function, for example:
    # my_c_library = CDLL("./libmath.so")
    # my_c_library.sum_doubles(c_array, len(c_array))
    
    print(f"Python array: {py_array}")
    print(f"C-compatible array (ctypes): {[val for val in c_array]}")

# Usage example
if __name__ == "__main__":
    demonstrate_ctypes_usage()
</code></pre>
<h4>Example with <code>struct</code> for data packing:</h4>
<pre class="line-numbers"><code class="language-python">
import array
import struct

def demonstrate_struct_packing(data: list[int]) -> bytes:
    """
    Packs an array of integers into a binary string.

    Args:
        data (list[int]): A list of integers to pack.

    Returns:
        bytes: The binary representation of the data.
    """
    arr = array.array('i', data)
    
    # Create a format string like '3i' for 3 integers
    format_string = f'{len(arr)}i'
    
    # Pack the data into a binary format
    binary_data = struct.pack(format_string, *arr)
    
    print(f"Original array: {arr}")
    print(f"Binary data: {binary_data}")
    
    # Verification: unpacking
    unpacked_data = struct.unpack(format_string, binary_data)
    print(f"Unpacked data: {unpacked_data}")
    
    return binary_data

# Usage example
if __name__ == "__main__":
    demonstrate_struct_packing([10, 20, 30])
</code></pre>
<hr>
<h3>4. Efficient serialization and deserialization</h3>
<p>The <code>.tobytes()</code> and <code>.frombytes()</code> methods allow you to quickly convert an array to bytes and vice versa, which is ideal for saving to files or sending over a network.</p>
<pre class="line-numbers"><code class="language-python">
import array

def handle_binary_data() -> None:
    """
    Shows serialization and deserialization of an array.array to bytes.
    """
    # Create the source array
    source_array = array.array('i', [1, 2, 3, 4, 5])
    print(f"Source array: {source_array}")

    # Serialize the array to bytes
    binary_data = source_array.tobytes()
    print(f"Data in bytes: {binary_data}")

    # Deserialize bytes to a new array
    new_array = array.array('i')
    new_array.frombytes(binary_data)
    print(f"Restored array: {new_array}")

    # Check integrity
    assert source_array == new_array, "Data does not match!"
    print("Data integrity confirmed.")

# Usage example
if __name__ == "__main__":
    handle_binary_data()
</code></pre>
<hr>
<h3>5. Ensuring type homogeneity</h3>
<p><code>array.array</code> enforces that only one data type, specified at creation, is stored. This protects against accidental addition of elements of a different type.</p>
<pre class="line-numbers"><code class="language-python">
import array

def demonstrate_type_safety() -> None:
    """
    Shows that array.array does not allow adding elements of a different type.
    """
    arr = array.array('i', [100, 200, 300])
    print(f"Integer array: {arr}")
    
    try:
        # Attempt to add a string element
        arr.append('hello')
    except TypeError as e:
        # Expected exception
        print(f"\nAttempt to add 'hello' caused an error: {e}")
        print("This confirms the array's strict typing.")

# Usage example
if __name__ == "__main__":
    demonstrate_type_safety()
</code></pre>
<hr>
<h3>6. Direct writing and reading to binary files</h3>
<p>The <code>.tofile()</code> and <code>.fromfile()</code> methods simplify working with binary files, allowing you to avoid intermediate serialization.</p>
<pre class="line-numbers"><code class="language-python">
import array
from pathlib import Path

def work_with_binary_files(file_path_str: str = "data.bin") -> None:
    """
    Writes an array to a binary file and reads it back.

    Args:
        file_path_str (str, optional): The name of the file to save.
                                       Default value is "data.bin".
    """
    file_path = Path(file_path_str)
    source_array = array.array('f', [1.5, 2.7, 3.14])

    try:
        # Write to file
        with file_path.open('wb') as f:
            source_array.tofile(f)
        print(f"Array {source_array} written to file '{file_path}'.")

        # Read from file
        new_array = array.array('f')
        with file_path.open('rb') as f:
            # Read 3 elements of type 'f' (float)
            new_array.fromfile(f, len(source_array))
        print(f"Array {new_array} read from file.")
        
        assert source_array == new_array

    finally:
        # Guaranteed deletion of the file after execution
        if file_path.exists():
            file_path.unlink()
            print(f"Temporary file '{file_path}' deleted.")

# Usage example
if __name__ == "__main__":
    work_with_binary_files()
</code></pre>
<hr>
<h2>üîπ Comparative table: <code>array.array</code> vs <code>list</code></h2>
<table>
<thead>
<tr>
<th>Characteristic</th>
<th><code>array.array</code></th>
<th><code>list</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Data type</strong></td>
<td>Homogeneous primitives (numbers, characters)</td>
<td>All Python objects</td>
</tr>
<tr>
<td><strong>Memory</strong></td>
<td>Low consumption</td>
<td>High consumption</td>
</tr>
<tr>
<td><strong>Performance</strong></td>
<td>High for numerical operations</td>
<td>Lower for numerical operations</td>
</tr>
<tr>
<td><strong>API</strong></td>
<td>Limited set of methods</td>
<td>Rich and flexible API</td>
</tr>
<tr>
<td><strong>C compatibility</strong></td>
<td>High, direct data passing</td>
<td>Requires conversions</td>
</tr>
<tr>
<td><strong>Binary serialization</strong></td>
<td>Built-in methods (<code>.tobytes</code>, <code>.tofile</code>)</td>
<td>Requires <code>struct</code>, <code>pickle</code>, etc.</td>
</tr>
</tbody>
</table>
<hr>
<p><strong>Conclusion:</strong></p>
<p>üöÄ Use <code>array.array</code> when working with large volumes of <strong>homogeneous numerical data</strong>, and when <strong>performance</strong> and <strong>efficient memory usage</strong> are essential for you.</p>
<p>For most daily tasks where flexibility and heterogeneous data storage are needed, <code>list</code> remains the best choice.</p>
