<h1>Singleton (design pattern) in <code>Python</code></h1>
<p>In <code>Python</code>, the singleton is a design pattern that ensures a class will have only one instance and provides a global access point to that instance. This means that when you try to create a new object of that class, you will always get the same object.</p>
<p>Singletons are useful when you need to limit the number of instances of a class, for example:</p>
<ul>
<li>To manage the connection to a database (so as not to open many connections).</li>
<li>To store the global configuration of the application (so that all parts of the application use the same configuration).</li>
<li>For logging (so that all messages go to a single file).</li>
</ul>
<p>Several ways to implement a singleton in <code>Python</code>.</p>
<hr>
<p><strong>Singleton implementation methods:</strong></p>
<ol>
<li>
<p><strong>By redefining the <code>__new__</code> method</strong></p>
<ul>
<li>The <code>__new__</code> method is responsible for creating a class instance. By redefining it, I can control this process.</li>
<li>In this example, I will store the unique instance of the class in the <code>_instance</code> variable.</li>
<li>If the instance does not yet exist, I will create it, otherwise I will return the already existing instance.</li>
<li><strong><code>Python</code> code:</strong></li>
</ul>
<pre class="line-numbers"><code class="language-python">
        class Singleton:
            _instance = None  # Stores the unique instance

            def __new__(cls, *args, **kwargs):
                """
                Redefines the __new__ method to control instance creation.

                Args:
                    cls: The class for which the instance is created.
                    *args: Positional arguments for the constructor.
                    **kwargs: Keyword arguments for the constructor.

                Returns:
                    The unique instance of the class.
                """
                if not cls._instance: # If the instance has not yet been created
                    cls._instance = super().__new__(cls, *args, **kwargs) # Creates a new instance
                return cls._instance # Returns the existing instance

        # Usage example
        s1 = Singleton()
        s2 = Singleton()

        print(s1 is s2)  # Will print True, because it's the same object
        </code></pre>
</li>
</ol>
<hr>
<p>2.  <strong>Via a decorator</strong></p>
<ul>
<li>A decorator is a function that modifies a class.</li>
<li>In this example, I create a decorator function <code>singleton</code> that takes a class and returns its wrapped version.</li>
<li>Inside the decorator, I store the class instances in the <code>instances</code> dictionary.</li>
<li>If the class instance has not yet been created, I will create it and store it in the dictionary, otherwise I will return the existing instance.</li>
<li><strong><code>Python</code> code:</strong></li>
</ul>
<pre class="line-numbers"><code class="language-python">
        def singleton(cls):
            """
            Decorator to create a singleton.

            Args:
                cls: The class to transform into a singleton.

            Returns:
                The modified class, which is a singleton.
            """
            instances = {} # Stores the instances

            def wrapper(*args, **kwargs):
                """
                Wrapper function that returns the unique instance of the class.

                Args:
                   *args: Positional arguments for the constructor.
                   **kwargs: Keyword arguments for the constructor.

                Returns:
                    The unique instance of the class.
                """
                if cls not in instances: # If the instance has not yet been created
                    instances[cls] = cls(*args, **kwargs) # Creates an instance and registers it
                return instances[cls] # Returns the existing instance
            return wrapper

        @singleton # Applies the decorator to the class
        class MyClass:
            pass

        # Usage example
        obj1 = MyClass()
        obj2 = MyClass()

        print(obj1 is obj2)  # Will print True, because it's the same object
        </code></pre>
<hr>
<p>3.  <strong>Via a metaclass</strong></p>
<ul>
<li>A metaclass allows you to control the creation of classes.</li>
<li>In this example, I will create a <code>SingletonMeta</code> metaclass that will monitor instance creation.</li>
<li>The metaclass stores the class instances in the <code>_instances</code> dictionary.</li>
<li>When creating a new instance, I check if it is already in the dictionary; if not, I create it; otherwise, I return the existing instance.</li>
<li><strong><code>Python</code> code:</strong></li>
</ul>
<pre class="line-numbers"><code class="language-python">
        class SingletonMeta(type):
            """
            Metaclass to create a singleton.
            """
            _instances = {} # Stores the instances

            def __call__(cls, *args, **kwargs):
                """
                Redefines the __call__ method to control instance creation.

                Args:
                    cls: The class for which the instance is created.
                    *args: Positional arguments for the constructor.
                    **kwargs: Keyword arguments for the constructor.

                Returns:
                    The unique instance of the class.
                """
                if cls not in cls._instances: # If the instance has not yet been created
                    cls._instances[cls] = super().__call__(*args, **kwargs) # Creates a new instance
                return cls._instances[cls] # Returns the existing instance

        class Singleton(metaclass=SingletonMeta):
            """
            Class that is a singleton.
            """
            pass

        # Usage example
        s1 = Singleton()
        s2 = Singleton()

        print(s1 is s2)  # Will print True, because it's the same object
             </code></pre>
<hr>
<p>4.  <strong>Via a module</strong></p>
<ul>
<li>In <code>Python</code>, a module is a singleton in itself.</li>
<li>I can create an object in a module, and it will be the only instance.</li>
<li><strong><code>Python</code> code:</strong>
<pre class="line-numbers"><code class="language-python">
        # singleton.py file
        class Singleton:
            pass

        instance = Singleton()
</code></pre>
<pre class="line-numbers"><code class="language-python">
        # In another file
        from singleton import instance

        obj1 = instance
        obj2 = instance

        print(obj1 is obj2)  # Will print True, because it's the same object
</code></pre>
</li>
</ul>
<p><strong>Advantages of singleton:</strong></p>
<ul>
<li><strong>Guarantee of a unique instance:</strong> The singleton guarantees that a class will have only one instance. This is useful for managing resources that must be unique.</li>
<li><strong>Global access:</strong> The singleton provides a global access point to the instance of the class, which simplifies the use of this instance in any part of the program.</li>
</ul>
<p><strong>Disadvantages of singleton:</strong></p>
<ul>
<li><strong>Global state:</strong> The singleton can lead to the use of a global state, which can cause unexpected side effects and complicate testing.</li>
<li><strong>Violation of OOP principles:</strong> The singleton can violate the single responsibility principle and encapsulation.</li>
</ul>
<p><strong>When to use singleton?</strong></p>
<ul>
<li>When you need an object to exist as a single instance (e.g., configuration, logging, database connection).</li>
<li>When you need global access to that object.</li>
</ul>
