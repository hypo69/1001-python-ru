<h1>Sorting Algorithms</h1>
<p>In everyday life and in programming, we are faced with the need to order data.
This can be anything: a shopping list, books on a shelf, or search results.
Sorting algorithms are a set of instructions that help us organize elements in a specific order, whether it be ascending,
descending, or according to some other criterion.</p>
<p>As an example, I use fruits of different sizes.</p>
<p><strong>Representation of fruits with sizes:</strong></p>
<p>Let's associate fruits with sizes. We will use tuples, where:</p>
<ul>
<li>The first element is the size of the fruit:
<ul>
<li>ğŸ (small) â€“ apple</li>
<li>ğŸ (medium) â€“ pear</li>
<li>ğŸ‰ (large) â€“ watermelon</li>
<li>ğŸ§º (very large) â€“ basket</li>
</ul>
</li>
<li>The second element is a unique identifier, for the program to work.</li>
</ul>
<p>Example: <code>(ğŸ, 1)</code> â€“ is a small apple with identifier 1.</p>
<pre class="line-numbers"><code class="language-python">
from typing import List, Tuple

def compare_fruits(fruit1: Tuple[str, int], fruit2: Tuple[str, int]) -> int:
    """
    Compares two fruits by their size.

    Args:
        fruit1: Tuple (size, identifier).
        fruit2: Tuple (size, identifier).

    Returns:
        -1 if fruit1 is smaller than fruit2, 1 if fruit1 is larger than fruit2, 0 if equal.
    """
    order = {"ğŸ": 0, "ğŸ": 1, "ğŸ‰": 2, "ğŸ§º": 3}  # Define the order of fruits by size
    size1 = order.get(fruit1[0]) # Get the size of the first fruit
    size2 = order.get(fruit2[0]) # Get the size of the second fruit
    if size1 < size2: # If the size of the first fruit is smaller, return -1
        return -1
    elif size1 > size2: # If the size of the first fruit is larger, return 1
        return 1
    else: # If the sizes are equal, return 0
      return 0
</code></pre>
<p><strong>Sorting algorithms (comparison by fruit size):</strong></p>
<ol>
<li>
<p><strong>Bubble Sort:</strong> (Lighter bubbles rise earlier)</p>
<ul>
<li>The algorithm compares adjacent fruits by their size. If a fruit is larger than its neighbor, it swaps places with it.</li>
<li>This process is repeated until the entire list of fruits is sorted from smallest to largest.</li>
<li>Analogy: Imagine you have an aquarium with air bubbles of different sizes. Lighter bubbles (corresponding to smaller fruits) will rise to the surface earlier than heavier ones (corresponding to larger fruits). Thus, lighter fruits "rise" to the top of the list, and heavier ones sink to the bottom.</li>
</ul>
<pre class="line-numbers"><code class="language-mermaid">
    graph TD
        A[Start] --> B{Are there unsorted fruits?};
        B -- Yes --> C[Compare two adjacent fruits];;
        C -- The first is larger --> D[Swap places];
        D --> E[Move to the next pair];
        C -- The first is not larger --> E;
        E --> F{End of list reached?};
        F -- No --> C;
        F -- Yes --> G{Was there a swap?};
        G -- Yes --> B;
        G -- No --> H[End];
        B -- No --> H;
        H[End]
</code></pre>
<pre class="line-numbers"><code class="language-python">
    def bubble_sort(fruits: List[Tuple[str, int]]) -> List[Tuple[str, int]]:
        """
        Sorts a list of fruits by size, using the "bubble sort" algorithm.

        Args:
            fruits: List of tuples (size, identifier).

        Returns:
            Sorted list of tuples.
        """
        n = len(fruits)  # Get the number of fruits
        for i in range(n):  # Loop through the list n times
            for j in range(0, n - i - 1):  # Loop through the unsorted part of the list
                if compare_fruits(fruits[j], fruits[j + 1]) == 1:  # If the left fruit is larger than the right fruit
                    fruits[j], fruits[j + 1] = fruits[j + 1], fruits[j]  # Swap places
        return fruits

</code></pre>
</li>
<li>
<p><strong>Insertion Sort:</strong></p>
<ul>
<li>The algorithm builds a sorted list by adding fruits to it one by one. A new fruit is inserted in the correct position to maintain the order by size.</li>
<li>Insertion sort is good for small lists or for those where the data is already almost sorted.</li>
</ul>
</li>
<li>
<p><strong>Selection Sort:</strong></p>
<ul>
<li>The algorithm finds the smallest fruit in the unsorted part of the list. Then, it places this fruit in the first position of the unsorted part of the list.</li>
<li>This process is repeated until all fruits are sorted.</li>
<li>Selection sort is simple but inefficient for large lists.</li>
</ul>
</li>
</ol>
<pre class="line-numbers"><code class="language-python">
def insertion_sort(fruits: List[Tuple[str, int]]) -> List[Tuple[str, int]]:
    """
    Sorts a list of fruits by size, using the "insertion sort" algorithm.

    Args:
        fruits: List of tuples (size, identifier).

    Returns:
        Sorted list of tuples.
    """
    for i in range(1, len(fruits)): # Start with the second fruit (the first is considered sorted)
        key = fruits[i] # Take the next fruit
        j = i - 1 # Index of the previous fruit
        while j >= 0 and compare_fruits(fruits[j], key) == 1: # Find the position in the sorted part to insert the fruit
            fruits[j + 1] = fruits[j] # Shift the fruits to make room for the new one
            j -= 1
        fruits[j + 1] = key # Insert the fruit in the correct position
    return fruits

def selection_sort(fruits: List[Tuple[str, int]]) -> List[Tuple[str, int]]:
    """
    Sorts a list of fruits by size, using the "selection sort" algorithm.

    Args:
        fruits: List of tuples (size, identifier).

    Returns:
        Sorted list of tuples.
    """
    n = len(fruits) # Get the number of fruits in the list
    for i in range(n): # Loop through all the fruits in the list
        min_index = i # Index of the smallest fruit
        for j in range(i + 1, n): # Find the smallest fruit in the unsorted part
            if compare_fruits(fruits[j], fruits[min_index]) == -1: # If a fruit smaller than the current minimum is found
                min_index = j # Remember the index of the new minimum
        fruits[i], fruits[min_index] = fruits[min_index], fruits[i] # Swap the current fruit with the smallest in the unsorted part
    return fruits

def display_fruits(fruits: List[Tuple[str, int]]) -> str:
    """
    Converts a list of fruits into a string for display.

    Args:
        fruits: List of tuples (size, identifier).

    Returns:
        String for displaying the list of fruits.
    """
    return ", ".join(f"{fruit[0]}{fruit[1]}" for fruit in fruits)  # Assemble the string for output


# Create a list of fruits to sort
fruits = [
    ("ğŸ‰", 1), ("ğŸ", 2), ("ğŸ", 3), ("ğŸ§º", 4), ("ğŸ", 5), ("ğŸ‰", 6), ("ğŸ", 7),
    ("ğŸ", 8), ("ğŸ§º", 9), ("ğŸ‰", 10), ("ğŸ", 11), ("ğŸ", 12)
]

print("Original list of fruits: " + display_fruits(fruits))  # Display the original list
print("Examples: Apple (ğŸ) < Pears (ğŸ) < Watermelon (ğŸ‰) < Baskets (ğŸ§º)")  # Display the order of the fruits

# Bubble sort
sorted_fruits_bubble = bubble_sort(fruits.copy()) # Sort a copy of the list
print("Bubble sort: " + display_fruits(sorted_fruits_bubble)) # Display the result

# Insertion sort
sorted_fruits_insertion = insertion_sort(fruits.copy()) # Sort a copy of the list
print("Insertion sort: " + display_fruits(sorted_fruits_insertion)) # Display the result

# Selection sort
sorted_fruits_selection = selection_sort(fruits.copy()) # Sort a copy of the list
print("Selection sort: " + display_fruits(sorted_fruits_selection)) # Display the result
</code></pre>
<p><strong>Code explanation:</strong></p>
<ol>
<li><strong><code>compare_fruits(fruit1, fruit2)</code>:</strong> This function compares two fruits by their size and returns -1 if the first fruit is smaller, 1 if it is larger, and 0 if they are equal. I use the <code>order</code> dictionary to define the order of fruit sizes.</li>
<li><strong><code>bubble_sort(fruits)</code>:</strong> I implement the bubble sort algorithm, where adjacent fruits are compared and swapped if they are in the wrong order.</li>
<li><strong><code>insertion_sort(fruits)</code>:</strong> I implement the insertion sort algorithm, where each new fruit is inserted in the correct position in the already sorted part of the list.</li>
<li><strong><code>selection_sort(fruits)</code>:</strong> I implement the selection sort algorithm, where on each pass I find the smallest fruit and place it in the correct position.</li>
<li><strong><code>display_fruits(fruits)</code>:</strong> This function converts a list of fruits into a string for convenient output.</li>
<li><strong>Examples:</strong> At the end, I create a list of fruits and apply the three sorting algorithms, displaying the results of each. I also show you the order in which the fruits are sorted.</li>
</ol>
