<h1>Sorting Algorithms</h1>
<p>In everyday life and in programming, we are faced with the need to order data.
This can be anything: a shopping list, books on a shelf, or search results.
Sorting algorithms are a set of instructions that help us arrange elements in a specific order, whether it be ascending,
descending, or according to some other criterion.</p>
<p>As an example, I will use fruits of different sizes.</p>
<p><strong>Representation of fruits with sizes:</strong></p>
<p>Let's associate fruits with sizes. We will use tuples, where:</p>
<ul>
<li>The first element is the size of the fruit:
<ul>
<li>🍎 (small) – apple</li>
<li>🍐 (medium) – pear</li>
<li>🍉 (large) – watermelon</li>
<li>🧺 (very large) – basket</li>
</ul>
</li>
<li>The second element is a unique identifier, for the program to work.</li>
</ul>
<p>Example: <code>(🍎, 1)</code> – this is a small apple with identifier 1.</p>
<pre class="line-numbers"><code class="language-python">
from typing import List, Tuple

def compare_fruits(fruit1: Tuple[str, int], fruit2: Tuple[str, int]) -> int:
    """
    Compares two fruits by size.

    Args:
        fruit1: Tuple (size, identifier).
        fruit2: Tuple (size, identifier).

    Returns:
        -1 if fruit1 is smaller than fruit2, 1 if fruit1 is larger than fruit2, 0 if equal.
    """
    order = {"🍎": 0, "🍐": 1, "🍉": 2, "🧺": 3}  # Defines the order of fruits by size
    size1 = order.get(fruit1[0]) # Gets the size of the first fruit
    size2 = order.get(fruit2[0]) # Gets the size of the second fruit
    if size1 < size2: # If the size of the first fruit is smaller, return -1
        return -1
    elif size1 > size2: # If the size of the first fruit is larger, return 1
        return 1
    else: # If the sizes are equal, return 0
      return 0
</code></pre>
<p><strong>Sorting algorithms (comparison by fruit size):</strong></p>
<ol>
<li>
<p><strong>Bubble Sort:</strong> (Lighter bubbles rise earlier)</p>
<ul>
<li>The algorithm compares adjacent fruits by size. If a fruit is larger than its neighbor, it swaps places with it.</li>
<li>This process is repeated until the entire list of fruits is sorted from smallest to largest.</li>
<li>Analogy: Imagine you have an aquarium with air bubbles of different sizes. Lighter bubbles (corresponding to smaller fruits) will rise to the surface earlier than heavier ones (corresponding to larger fruits). Thus, lighter fruits "float" to the top of the list, and heavier ones sink to the bottom.</li>
</ul>
<pre class="line-numbers"><code class="language-mermaid">
graph TD
    A[Start] --> B{Are there unsorted fruits?};
    B -- Yes --> C[Compare two adjacent fruits];
    C -- The first is larger --> D[Swap places];
    D --> E[Move to the next pair];
    C -- The first is not larger --> E;
    E --> F{End of the list reached?};
    F -- No --> C;
    F -- Yes --> G{Was there a swap?};
    G -- Yes --> B;
    G -- No --> H[End];
    B -- No --> H;
    H[End]
</code></pre>
<pre class="line-numbers"><code class="language-python">
def bubble_sort(fruits: List[Tuple[str, int]]) -> List[Tuple[str, int]]:
    """
    Sorts a list of fruits by size, using the "bubble sort" algorithm.

    Args:
        fruits: List of tuples (size, identifier).

    Returns:
        Sorted list of tuples.
    """
    n = len(fruits)  # Gets the number of fruits
    for i in range(n):  # Iterates through the list n times
        for j in range(0, n - i - 1):  # Iterates through the unsorted part of the list
            if compare_fruits(fruits[j], fruits[j + 1]) == 1:  # If the left fruit is larger than the right fruit
                fruits[j], fruits[j + 1] = fruits[j + 1], fruits[j]  # Swap places
    return fruits

</code></pre>
</li>
<li>
<p><strong>Insertion Sort:</strong></p>
<ul>
<li>The algorithm builds a sorted list by adding fruits to it one by one. A new fruit is inserted in the correct place to maintain the order by size.</li>
<li>Insertion sort is good for small lists or for those where the data is already almost sorted.</li>
</ul>
</li>
<li>
<p><strong>Selection Sort:</strong></p>
<ul>
<li>The algorithm finds the smallest fruit in the unsorted part of the list. Then, it places this fruit in the first place in the unsorted part of the list.</li>
<li>This process is repeated until all fruits are sorted.</li>
<li>Selection sort is simple, but inefficient for large lists.</li>
</ul>
</li>
</ol>
<pre class="line-numbers"><code class="language-python">
def insertion_sort(fruits: List[Tuple[str, int]]) -> List[Tuple[str, int]]:
    """
    Sorts a list of fruits by size, using the "insertion sort" algorithm.

    Args:
        fruits: List of tuples (size, identifier).

    Returns:
        Sorted list of tuples.
    """
    for i in range(1, len(fruits)): # Starts with the second fruit (the first is considered sorted)
        key = fruits[i] # Takes the next fruit
        j = i - 1 # Index of the previous fruit
        while j >= 0 and compare_fruits(fruits[j], key) == 1: # Looks for the position in the sorted part to insert the fruit
            fruits[j + 1] = fruits[j] # Shifts the fruits to make room for the new one
            j -= 1
        fruits[j + 1] = key # Inserts the fruit in the correct place
    return fruits

def selection_sort(fruits: List[Tuple[str, int]]) -> List[Tuple[str, int]]:
    """
    Sorts a list of fruits by size, using the "selection sort" algorithm.

    Args:
        fruits: List of tuples (size, identifier).

    Returns:
        Sorted list of tuples.
    """
    n = len(fruits) # Gets the number of fruits in the list
    for i in range(n): # Iterates through all the fruits in the list
        min_index = i # Index of the smallest fruit
        for j in range(i + 1, n): # Looks for the smallest fruit in the unsorted part
            if compare_fruits(fruits[j], fruits[min_index]) == -1: # If a fruit smaller than the current minimum is found
                min_index = j # Remembers the index of the new minimum
        fruits[i], fruits[min_index] = fruits[min_index], fruits[i] # Swaps the current fruit with the smallest in the unsorted part
    return fruits

def display_fruits(fruits: List[Tuple[str, int]]) -> str:
    """
    Converts a list of fruits into a string for display.

    Args:
        fruits: List of tuples (size, identifier).

    Returns:
        String for displaying the list of fruits.
    """
    return ", ".join(f"{fruit[0]}{fruit[1]}" for fruit in fruits)  # Builds the string for display


# Creates a list of fruits to sort
fruits = [
    ("🍉", 1), ("🍎", 2), ("🍐", 3), ("🧺", 4), ("🍎", 5), ("🍉", 6), ("🍐", 7),
    ("🍎", 8), ("🧺", 9), ("🍉", 10), ("🍐", 11), ("🍎", 12)
]

print("Original list of fruits: " + display_fruits(fruits))  # Displays the original list
print("Examples: Apple (🍎) < Pear (🍐) < Watermelon (🍉) < Baskets (🧺)")  # Displays the order of the fruits

# Bubble sort
sorted_fruits_bubble = bubble_sort(fruits.copy()) # Sorts a copy of the list
print("Bubble sort: " + display_fruits(sorted_fruits_bubble)) # Displays the result

# Insertion sort
sorted_fruits_insertion = insertion_sort(fruits.copy()) # Sorts a copy of the list
print("Insertion sort: " + display_fruits(sorted_fruits_insertion)) # Displays the result

# Selection sort
sorted_fruits_selection = selection_sort(fruits.copy()) # Sorts a copy of the list
print("Selection sort: " + display_fruits(sorted_fruits_selection)) # Displays the result
</code></pre>
<p><strong>Code analysis:</strong></p>
<ol>
<li><strong><code>compare_fruits(fruit1, fruit2)</code>:</strong> This function compares two fruits by size and returns -1 if the first fruit is smaller, 1 if larger, and 0 if equal. I use the <code>order</code> dictionary to define the order of fruit sizes.</li>
<li><strong><code>bubble_sort(fruits)</code>:</strong> I implement the bubble sort algorithm, where adjacent fruits are compared and swapped if they are in the wrong order.</li>
<li><strong><code>insertion_sort(fruits)</code>:</strong> I implement the insertion sort algorithm, where each new fruit is inserted in the correct place in the already sorted part of the list.</li>
<li><strong><code>selection_sort(fruits)</code>:</strong> I implement the selection sort algorithm, where on each pass I find the smallest fruit and place it in the correct position.</li>
<li><strong><code>display_fruits(fruits)</code>:</strong> This function converts a list of fruits into a string for convenient display.</li>
<li><strong>Examples:</strong> At the end, I create a list of fruits and apply the three sorting algorithms to it, displaying the results of each. I also show you the order in which the fruits are sorted.</li>
</ol>
